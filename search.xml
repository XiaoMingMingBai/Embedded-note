<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>底层 IO 模型</title>
    <url>/2023/04/10/IOModel/</url>
    <content><![CDATA[<p>本文包含4种 <code>IO模型</code> 的介绍、实现原理分层解析、驱动编写思路和代码实现、以及应用层使用方法。</p>
<span id="more"></span>

<h1 id="IO模型的分析"><a href="#IO模型的分析" class="headerlink" title="IO模型的分析"></a>IO模型的分析</h1><p>IO 模型是指应用程序在调用 <code>read</code> 函数的时候，如果数据没有准备好，此时进程会发生什么样的状态转换，以及什么时候会返回。在Linux中有五种IO模型，分别是阻塞IO模型，非阻塞IO模型，IO多路复用IO模型，信号驱动IO模型，异步IO模型。下面是对它的分析<br>以下内容仅为我的个人积累，详细内容请参考官方文档和相关书籍。</p>
<h1 id="阻塞IO模型"><a href="#阻塞IO模型" class="headerlink" title="阻塞IO模型"></a>阻塞IO模型</h1><p>在使用open打开设备文件的时候，如果没有指定 <code>O_NONBLOCK</code>，就说明使用的阻塞方式打开的文件。调用read函数想要从硬件中读取数据的时候，如果数据准备好了 <code>read</code> 就会立即返回，如果调用 <code>read</code> 的时候硬件的数据没有准备好进程休眠。当数据准备好的时候底层硬件会产生中断，内核的中断处理函数就会执行了，在中断处理函数中唤醒休眠的进程，将准备好的数据拷贝到用户空间即可。</p>
<h2 id="阻塞IO模型的代码实现流程"><a href="#阻塞IO模型的代码实现流程" class="headerlink" title="阻塞IO模型的代码实现流程"></a>阻塞IO模型的代码实现流程</h2><h3 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">fd = open(<span class="string">&quot;/dev/mycdev&quot;</span>,O_RDWR);  <span class="comment">//阻塞打开</span></span><br><span class="line">read(fd,buf,<span class="keyword">sizeof</span>(buf));</span><br></pre></td></tr></table></figure>
<h3 id="驱动层"><a href="#驱动层" class="headerlink" title="驱动层"></a>驱动层</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* file_operations: */</span></span><br><span class="line">driver_read(file,ubuf,size,offs)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(file-&gt;f_flags &amp; O_NONBLOCK)&#123;</span><br><span class="line">        <span class="comment">//非阻塞</span></span><br><span class="line">        <span class="keyword">return</span> -EINVAL;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="comment">//阻塞 （硬件数据是否准备好）</span></span><br><span class="line">        <span class="comment">//如果数据没有准备好此时进程需要休眠</span></span><br><span class="line">        wait_event(wq_head, condition)</span><br><span class="line">        wait_event_interruptible(wq_head, condition)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//读取底层硬件的数据</span></span><br><span class="line">    <span class="comment">//将读取到的数据拷贝到用户空间（copy_to_user）</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 中断处理函数中：*/</span></span><br><span class="line">    condition = <span class="number">1</span>;</span><br><span class="line">    wake_up(&amp;wq_head);</span><br><span class="line">    wake_up_interruptible(&amp;wq_head)</span><br></pre></td></tr></table></figure>


<hr>
<h1 id="IO多路复用IO模型"><a href="#IO多路复用IO模型" class="headerlink" title="IO多路复用IO模型"></a>IO多路复用IO模型</h1><p>在同一个app应用程序中如果想要同时监听多个fd对应数据。就需要使用 <code>select/poll/epoll</code> 来完成监听。如果所有的文件描述符的数据都没有准备好，此时进程休眠。如果有一个或者多个硬件的数据准备好就会产生硬件中断，在处理函数中唤醒休眠的进程。此时 <code>select/poll/epoll</code> 就会返回，从就绪的表中找到准备好数据的文件描述符，然后调用 <code>read</code> 将数据读取到用户空间即可。</p>
<h2 id="IO多路复用IO模型的代码实现流程"><a href="#IO多路复用IO模型的代码实现流程" class="headerlink" title="IO多路复用IO模型的代码实现流程"></a>IO多路复用IO模型的代码实现流程</h2><h3 id="应用层-1"><a href="#应用层-1" class="headerlink" title="应用层"></a>应用层</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> fd1,fd2;</span><br><span class="line">fd_set rfds; <span class="comment">//定义读表</span></span><br><span class="line">fd1 = open(<span class="string">&quot;/dev/mycdev0&quot;</span>,O_RDWR);</span><br><span class="line">fd2 = open(<span class="string">&quot;/dev/input/mouse0&quot;</span>,O_RDWR);</span><br><span class="line"> </span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">    FD_ZERO(&amp;rfds); <span class="comment">//清空表</span></span><br><span class="line">    FD_SET(fd1,&amp;rfds); <span class="comment">//将fd1放到读表中</span></span><br><span class="line">    FD_SET(fd2,&amp;rfds); <span class="comment">//将fd2放到读表中</span></span><br><span class="line">    select(fd2+<span class="number">1</span>,&amp;rfds,<span class="literal">NULL</span>,<span class="literal">NULL</span>,<span class="literal">NULL</span>); <span class="comment">//监听文件描述符</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(FD_ISSET(fd1,&amp;rfds))&#123;</span><br><span class="line">        read(fd1,buf1,<span class="keyword">sizeof</span>(buf1));</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;mycdev:%s\n&quot;</span>,buf1);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(FD_ISSET(fd2,&amp;rfds))&#123;</span><br><span class="line">        read(fd2,buf2,<span class="keyword">sizeof</span>(buf2));</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;mouse0:%s\n&quot;</span>,buf2);</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h3 id="驱动层-1"><a href="#驱动层-1" class="headerlink" title="驱动层"></a>驱动层</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* file_operations:(应用层select/poll/epoll对应驱动都是poll函数) */</span></span><br><span class="line"><span class="type">__poll_t</span> (*poll) (<span class="keyword">struct</span> file *file, <span class="keyword">struct</span> poll_table_struct *wait)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 1.定义返回值变量</span></span><br><span class="line">    <span class="type">__poll_t</span> mask=<span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 2.调用poll_wait完成阻塞</span></span><br><span class="line">    poll_wait(file,&amp;wq_head,wait);</span><br><span class="line">    <span class="comment">// 3.如果数据准备好置位mask</span></span><br><span class="line">    <span class="keyword">if</span>(condition)&#123;</span><br><span class="line">        mask |= EPOLLIN;       <span class="comment">//EPOLLIN 读  EPOLLOUT写</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 4.返回mask</span></span><br><span class="line">    <span class="keyword">return</span> mask;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="IO多路复用IO模型的实现原理"><a href="#IO多路复用IO模型的实现原理" class="headerlink" title="IO多路复用IO模型的实现原理"></a>IO多路复用IO模型的实现原理</h2><h3 id="应用层-2"><a href="#应用层-2" class="headerlink" title="应用层"></a>应用层</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">select(fd2 + <span class="number">1</span>, &amp;rfds, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br></pre></td></tr></table></figure>
<h3 id="虚拟文件系统层"><a href="#虚拟文件系统层" class="headerlink" title="虚拟文件系统层"></a>虚拟文件系统层</h3><p>首先使用 <code>vi -t sys_select</code> 命令查看 <code>select</code> 函数的实现</p>
<ol>
<li>对最大文件描述符的值作校验工作</li>
<li>在内核空间分配6张表的内存，其中前3张表用于保存用户传递到内核的文件描述符后三张表用于保存就绪的文件描述符（后三张表此时是空的）</li>
<li>遍历文件描述符<br><code>mask = rfds--&gt;fd--&gt;fd_array[fd]--&gt;file--&gt;f_op--&gt;poll(file,wait);</code><br>判断mask返回的值，如果所有的文件描述对应驱动poll函数返回的值都是0，说明所有文件描述符的数据都没准备好，构造等待队列，进程休眠</li>
<li>如果一个或者多个文件描述符对应的数据准备好了，就会唤醒这个休眠的进程</li>
<li>再次遍历文件描述符<br><code>mask = rfds--&gt;fd--&gt;fd_array[fd]--&gt;file--&gt;f_op--&gt;poll(file,wait);</code><br>找出mask不为0的文件描述符，将这个文件描述符放到就绪的文件描述符表中</li>
<li>将就绪的文件描述表拷贝到用户空间</li>
</ol>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>总的来说 <code>select</code> <code>poll</code> <code>epoll</code> 的实现原理都是一样的，只是在实现的时候有一些细节上的差别。</p>
<h4 id="select-结构体"><a href="#select-结构体" class="headerlink" title="select (结构体)"></a>select (结构体)</h4><ol>
<li>select监听的最大文件描述符限制1024</li>
<li>select的内部实现又清空表的过程，需要反复构造表，从用户空间向内核空间拷贝表，效率低</li>
<li>select从休眠状态被唤醒之后需要再次遍历文件描述符表，效率比较低</li>
</ol>
<h4 id="poll-链表"><a href="#poll-链表" class="headerlink" title="poll (链表)"></a>poll (链表)</h4><ol>
<li>poll监听的文件描述符没有个数限制</li>
<li>poll没有清空表的过程，效率高</li>
<li>poll从休眠状态被唤醒之后需要再次遍历文件描述符表，效率比较低</li>
</ol>
<h4 id="epoll-红黑树-双链表"><a href="#epoll-红黑树-双链表" class="headerlink" title="epoll (红黑树+双链表)"></a>epoll (红黑树+双链表)</h4><ol>
<li>epoll监听的文件描述符没有个数限制</li>
<li>epoll没有清空表的过程，效率高</li>
<li>epoll监听的文件描述符就绪之后它能够直接拿到就绪的文件描述符，不需要遍历，效率高</li>
</ol>
<p><code>epoll_ctl</code> 支持管道，FIFO，套接字，POSIX消息队列，终端，设备等，但是就是不支持普通文件或目录的fd</p>
<hr>
<h1 id="异步通知IO模型"><a href="#异步通知IO模型" class="headerlink" title="异步通知IO模型"></a>异步通知IO模型</h1><p>当底层硬件的数据准备好的时候会产生硬件中断，在驱动的中断处理函数中给对应的进程发送信号，当进程收到信号的时候去读取数据，当没有收到信号的时候进程可以执行任意操作。<br>信号和中断不同，中断是基于硬件实现的，而信号是基于软件实现的是中断的一种模拟，如果没有操作系统那么就没有信号。</p>
<h2 id="异步通知IO模型的代码实现流程"><a href="#异步通知IO模型的代码实现流程" class="headerlink" title="异步通知IO模型的代码实现流程"></a>异步通知IO模型的代码实现流程</h2><h3 id="应用层-3"><a href="#应用层-3" class="headerlink" title="应用层"></a>应用层</h3><p>首先在系统的信号中有一个 <code>29) SIGIO</code> 就是专门留给IO模型使用的，可以在终端通过 <code>kill -l</code> 命令查看</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 信号处理函数</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">signal_handle</span><span class="params">(<span class="type">int</span> signo)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//从底层读取数据</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 1.打开设备文件</span></span><br><span class="line">fd = open(<span class="string">&quot;/dev/mycdev0&quot;</span>,O_RDWR);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2.使用signal函数为信号绑定处理函数</span></span><br><span class="line"><span class="comment">//      要明白signal函数并不会调用file_operations中的任何函数，只是为信号绑定了一个处理函数</span></span><br><span class="line">signal(SIGIO,signal_handle);</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 3.调用驱动的fasync函数，做初始化工作</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> flags = fcntl(fd,F_GETFL);</span><br><span class="line">fcntl(fd,F_SETFL,flags|FASYNC);</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 4.告诉内核接收信号的进程是当前进程</span></span><br><span class="line">fcntl(fd,F_SETOWN,getpid());</span><br></pre></td></tr></table></figure>
<h3 id="虚拟文件系统层-1"><a href="#虚拟文件系统层-1" class="headerlink" title="虚拟文件系统层"></a>虚拟文件系统层</h3><p>首先可以使用 <code>vi -t sys_fcntl</code> 命令查看 <code>fcntl</code> 函数的实现</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 可知首先执行的是</span></span><br><span class="line">SYSCALL_DEFINE3(fcntl, <span class="type">unsigned</span> <span class="type">int</span>, fd, <span class="type">unsigned</span> <span class="type">int</span>, cmd, <span class="type">unsigned</span> <span class="type">long</span>, arg) </span><br><span class="line"><span class="comment">// 经过替换后可以得到</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> <span class="title function_">sys_fcntl</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> fd, <span class="type">unsigned</span> <span class="type">int</span> cmd, <span class="type">unsigned</span> <span class="type">long</span> arg)</span></span><br><span class="line">---&gt;err = do_fcntl(fd, cmd, arg, f.file);</span><br><span class="line"><span class="comment">// 然后知道会调用 do_fcntl 函数</span></span><br><span class="line"><span class="type">static</span> <span class="type">long</span> <span class="title function_">do_fcntl</span><span class="params">(<span class="type">int</span> fd, <span class="type">unsigned</span> <span class="type">int</span> cmd, <span class="type">unsigned</span> <span class="type">long</span> arg,<span class="keyword">struct</span> file *filp)</span></span><br><span class="line">---&gt;<span class="title function_">switch</span> <span class="params">(cmd)</span> &#123;  </span><br><span class="line">    <span class="keyword">case</span> F_GETFL:</span><br><span class="line">        err = filp-&gt;f_flags;   <span class="comment">//open函数的第二个参数，代表文件打开式</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> F_SETFL:</span><br><span class="line">        err = setfl(fd, filp, arg); <span class="comment">//arg = filp-&gt;f_flags|FASYNC</span></span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">setfl</span><span class="params">(<span class="type">int</span> fd, <span class="keyword">struct</span> file * filp, <span class="type">unsigned</span> <span class="type">long</span> arg)</span>  </span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//arg = filp-&gt;f_flags|FASYNC</span></span><br><span class="line">    <span class="keyword">if</span> (((arg ^ filp-&gt;f_flags) &amp; FASYNC) &amp;&amp; filp-&gt;f_op-&gt;fasync) &#123;</span><br><span class="line">        <span class="comment">//调用底层驱动的fasync函数执行</span></span><br><span class="line">        error = filp-&gt;f_op-&gt;fasync(fd, filp, (arg &amp; FASYNC) != <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="驱动层-2"><a href="#驱动层-2" class="headerlink" title="驱动层"></a>驱动层</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* file_operations: */</span></span><br><span class="line"><span class="comment">// 在内核中查看函数的实现，通过注释发现 fasnc_helper 函数是用来初始化异步通知的队列的，因为如果有多个进程都要异步通知，那么就需要一个队列来存储这些进程</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">mycdev_fasync</span><span class="params">(<span class="type">int</span> fd, <span class="keyword">struct</span> file *file, <span class="type">int</span> on)</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//发信号前的初始化工作</span></span><br><span class="line">    <span class="comment">//初始化一个异步通知的队列，你可以通过fapp成员拿到队列</span></span><br><span class="line">    <span class="keyword">return</span>  fasync_helper(fd, file, on, &amp;fapp);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 发送信号：</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">kill_fasync</span><span class="params">(&amp;fapp, SIGIO, POLL_IN)</span>;   <span class="comment">//POLL_IN 发送可读事件   POLL_OUT  发送可写事件</span></span><br></pre></td></tr></table></figure>
]]></content>
  </entry>
  <entry>
    <title>BOA 服务器移植</title>
    <url>/2023/01/15/BOA%20%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%A7%BB%E6%A4%8D/</url>
    <content><![CDATA[<p>本文包含 <code>BOA</code> 服务器的介绍、移植、配置、参数介绍、错误解决等。</p>
<span id="more"></span>

<p>以下内容仅为我的个人积累，详细内容请参考 <a href="http://www.boa.org/">BOA 官方文档</a>。</p>
<h1 id="BOA-服务器"><a href="#BOA-服务器" class="headerlink" title="BOA 服务器"></a>BOA 服务器</h1><p>BOA 是一个小型的 HTTP 服务器，它的特点是占用资源少，运行速度快，是嵌入式 Linux 系统的首选 HTTP 服务器。   </p>
<h1 id="BOA-服务器移植"><a href="#BOA-服务器移植" class="headerlink" title="BOA 服务器移植"></a>BOA 服务器移植</h1><ol>
<li><p>解压源码</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">tar xvf boa-0.94.13.tar.tar</span><br><span class="line"><span class="built_in">cd</span> boa-0.94.13</span><br></pre></td></tr></table></figure></li>
<li><p>进入 src&#x2F; 目录，生成并修改 Makefile 文件</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> src/</span><br><span class="line">./configure      <span class="comment"># 生成 Makefile 文件</span></span><br><span class="line">vim Makefile</span><br></pre></td></tr></table></figure>
<p>修改如下：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">CC = arm-linux-gnueabihf-gcc <span class="comment"># 修改编译器</span></span><br><span class="line">CPP = arm-linux-gnueabihf-gcc -E <span class="comment"># 修改预处理器</span></span><br></pre></td></tr></table></figure></li>
<li><p>make 编译<br>编译一个linux下的c系统，包含词法和语法分析模块，Linux上用bison和flex。yacc是一个文法分析器的生成器,bison即是yacc的GNU版本.Lex和YACC是用于构造词法分析机和语法解释器的工具，利用Lex和YACC你可以轻松的构造一个语法解释器。</p>
 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt-get install bison flex <span class="comment"># 安装bison和flex</span></span><br><span class="line">make <span class="comment"># 编译</span></span><br></pre></td></tr></table></figure></li>
<li><p>给 boa 瘦身</p>
 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">arm-linux-gnueabihf-strip boa <span class="comment"># 去掉符号表</span></span><br></pre></td></tr></table></figure></li>
</ol>
<h1 id="BOA-服务器配置"><a href="#BOA-服务器配置" class="headerlink" title="BOA 服务器配置"></a>BOA 服务器配置</h1><p>开发板的根目录文件 <code>rootfsmy</code></p>
<ol>
<li><p>创建目录</p>
 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> /etc/boa <span class="comment"># 创建 boa 配置文件目录</span></span><br></pre></td></tr></table></figure></li>
<li><p>将 <code>boa</code> 源码目录下的 <code>boa.conf</code> 拷贝到 <code>/etc/boa/</code> 目录下</p>
 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cp</span> boa.conf /rootfsmy/etc/boa/ </span><br></pre></td></tr></table></figure></li>
<li><p>修改配置文件 boa.conf</p>
 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">vim /rootfsmy/etc/boa/boa.conf</span><br></pre></td></tr></table></figure>
<p> 修改如下：</p>
 <figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 1. Group nogroup </span></span><br><span class="line">Group 0 <span class="comment"># Group 的修改</span></span><br><span class="line"><span class="comment"># 2. User nobody</span></span><br><span class="line">User 0 <span class="comment"># User 的修改</span></span><br><span class="line"><span class="comment"># 3. ScriptAlias /cgi-bin/ /usr/lib/cgi-bin/</span></span><br><span class="line">ScriptAlias /cgi-bin/ /www/cgi-bin/ <span class="comment"># ScriptAlias 的修改</span></span><br><span class="line"><span class="comment"># 4. DocumentRoot /var/www/</span></span><br><span class="line">DocumentRoot /www <span class="comment"># DocumentRoot 的修改</span></span><br><span class="line"><span class="comment"># 5. #ServerName www.example.com</span></span><br><span class="line">ServerName www.your.org.here <span class="comment"># ServerName 的修改</span></span><br><span class="line"><span class="comment"># 6. AccessLog /var/log/boa/access_log</span></span><br><span class="line"><span class="comment">#AccessLog /var/log/boa/access_log # AccessLog 的修改</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>一下配置和 <code>boa.conf</code> 有关，都是在 ARM 根文件系统中创建</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> /www <span class="comment"># 创建网页根目录</span></span><br><span class="line"><span class="built_in">mkdir</span> /www/cgi-bin <span class="comment"># 创建 CGI 脚本所在目录  </span></span><br></pre></td></tr></table></figure>
<p>当不能用 <code>cgi</code> 时</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="comment"># #AddType application/x-httpd-cgi cgi</span></span><br><span class="line">AddType application/x-httpd-cgi cgi <span class="comment"># AddType 的修改</span></span><br></pre></td></tr></table></figure></li>
</ol>
<h1 id="BOA-服务器测试"><a href="#BOA-服务器测试" class="headerlink" title="BOA 服务器测试"></a>BOA 服务器测试</h1><ol>
<li>将 <code>boa</code> 拷贝到开发板的 <code>/etc/boa</code> 目录下 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cp</span> src/boa /rootfsmy/etc/boa/</span><br></pre></td></tr></table></figure></li>
<li>将 <code>ubuntu</code> 下 <code>/etc/mime.types</code> 拷贝到开发板根文件系统的 <code>/etc</code> 下 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cp</span> /etc/mime.types /rootfsmy/etc/</span><br></pre></td></tr></table></figure></li>
<li>将主页index.html拷贝到www目录下</li>
<li>运行 boa <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">./boa <span class="comment"># /etc/boa/boa</span></span><br></pre></td></tr></table></figure>
<img src="/../image/boaTest.png" alt="Alt text"></li>
</ol>
<h1 id="boa-配置文件参数解释"><a href="#boa-配置文件参数解释" class="headerlink" title="boa 配置文件参数解释"></a>boa 配置文件参数解释</h1><ol>
<li><code>boa</code> 的配置文件是 <code>/etc/boa/boa.conf</code>。</li>
<li><code>Port</code>：boa服务器监听的端口，默认的端口是80。如果端口小于1024，则必须是root用户启动服务器。</li>
<li><code>Listen</code>：绑定的ip地址。不使用这个参数时，将绑定所有的地址。</li>
<li><code>User</code>：连接到服务器的客户端的身份，可以是用户名或UID。</li>
<li><code>Group</code>：连接到服务器的客户端的组，可以是组名或GID。</li>
<li><code>ServerAdmin</code>：服务器出故障时要通知的邮箱地址。</li>
<li><code>ErrorLog</code>：指定错误日志文件。如果路径没有以“&#x2F;”开始，则相对于ServerRoot路径。没有配置时默认的文件是&#x2F;dev&#x2F;stderr。若不想记录日志，指定文件为&#x2F;dev&#x2F;null。</li>
<li><code>AccessLog</code>：设置存取日志文件，与ErrorLog类似。UseLocaltime：设置使用本地时间，使用UTC时注释这个参数。这个参数没有值。</li>
<li><code>VerboseCGILogs</code>：在错误日志文件中记录CGI启动和停止时间，若不记录，注释这个参数。这个参数没有值。</li>
<li><code>ServerName</code>：指定服务器的名称，当客户端使用gethostname + gethostbyname时返回给客户端。</li>
<li><code>VirtualHost</code>：虚拟主机开关。使用此参数，则会在DocumentRoot设定的目录添加一个ip地址作为新的DocumentRoot来 处理客户端的请求。如DocumentRoot设置为&#x2F;var&#x2F;www，<a href="http://localhost/">http://localhost/</a> 则转换成&#x2F;var&#x2F;www&#x2F;127.0.0.1&#x2F;，若注释此参数，则为&#x2F;var&#x2F;www&#x2F;。</li>
<li>   <code>DocumentRoot</code>：HTML文件的根目录（也就是网站的目录）。</li>
<li>   <code>UserDir</code>：指定用户目录。</li>
<li>   <code>DirectoryIndex</code>：指定预生成目录信息的文件，注释此变量将使用DirectoryMaker变量。这个变量也就是设置默认主页的文件名。</li>
<li>   <code>DirectoryMaker</code>：指定用于生成目录的程序，注释此变量将不允许列目录。</li>
<li>   <code>KeepAliveMax</code>：每个连接允许的请求数量。如果将此值设为” 0 “，将不限制请求的数目 </li>
<li>   <code>KeepAliveTimeOut</code>：在关闭持久连接前等待下一个请求的秒数。（秒）。</li>
<li>   <code>MimeTypes</code>：设置包含mimetypes信息的文件，一般是&#x2F;etc&#x2F;mime.types。</li>
<li>   <code>DefaultType</code>：默认的mimetype类型，一般是text&#x2F;html。</li>
<li>   <code>CGIPath</code>：相当于给CGI程序使用的$PATH变量。</li>
<li>   <code>Aliases</code>：指定路径的别名。</li>
<li>   <code>ScriptAlias</code>：指定脚本路径的虚拟路径。</li>
</ol>
<h1 id="BOA-服务器错误解决"><a href="#BOA-服务器错误解决" class="headerlink" title="BOA 服务器错误解决"></a>BOA 服务器错误解决</h1><h2 id="error-pasting-t-and-does-not-give-a-valid-preprocessing-token"><a href="#error-pasting-t-and-does-not-give-a-valid-preprocessing-token" class="headerlink" title="error: pasting &quot;t&quot; and &quot;-&gt;&quot; does not give a valid preprocessing token"></a><code>error: pasting &quot;t&quot; and &quot;-&gt;&quot; does not give a valid preprocessing token</code></h2><p>在 make 的时候出现这个错误，<br>修改 <code>src/compat.h</code></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// #define TIMEZONE_OFFSET(foo) foo##-&gt;tm_gmtoff</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TIMEZONE_OFFSET(foo) (foo)-&gt;tm_gmtoff</span></span><br></pre></td></tr></table></figure>
<p>然后 <code>make clean</code> 后重新 <code>make</code> 即可。</p>
<h2 id="log-c-73-unable-to-dup2-the-error-log-Bad-file-descriptor"><a href="#log-c-73-unable-to-dup2-the-error-log-Bad-file-descriptor" class="headerlink" title="log.c:73 - unable to dup2 the error log: Bad file descriptor"></a><code>log.c:73 - unable to dup2 the error log: Bad file descriptor</code></h2><p>在运行 boa 的时候出现这个错误，<br>修改 <code>src/log.c</code></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// if (dup2(error_log, STDERR_FILENO) == -1) &#123;</span></span><br><span class="line"><span class="comment">//      DIE(&quot;unable to dup2 the error log&quot;);</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"><span class="comment">// 注释掉上面的代码</span></span><br><span class="line"><span class="comment">/*  if (dup2(error_log, STDERR_FILENO) == -1) &#123;</span></span><br><span class="line"><span class="comment">        DIE(&quot;unable to dup2 the error log&quot;);</span></span><br><span class="line"><span class="comment">&#125; */</span></span><br></pre></td></tr></table></figure>
<h2 id="boa-c-211-getpwuid-No-such-file-or-directory"><a href="#boa-c-211-getpwuid-No-such-file-or-directory" class="headerlink" title="boa.c:211 - getpwuid: No such file or directory"></a><code>boa.c:211 - getpwuid: No such file or directory</code></h2><p>在运行 boa 的时候出现这个错误，<br>修改 <code>src/boa.c</code></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// if (passwdbuf == NULL) &#123;</span></span><br><span class="line"><span class="comment">//      DIE(”getpwuid”);</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"><span class="comment">// if (initgroups(passwdbuf-&gt;pw_name, passwdbuf-&gt;pw_gid) == -1) &#123;</span></span><br><span class="line"><span class="comment">//      DIE(”initgroups”);</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"><span class="comment">// 注释掉上面的代码</span></span><br><span class="line"><span class="comment">/* if (passwdbuf == NULL) &#123;</span></span><br><span class="line"><span class="comment">    DIE(”getpwuid”);</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">if (initgroups(passwdbuf-&gt;pw_name, passwdbuf-&gt;pw_gid) == -1) &#123;</span></span><br><span class="line"><span class="comment">    DIE(”initgroups”);</span></span><br><span class="line"><span class="comment">&#125; */</span></span><br></pre></td></tr></table></figure>

<h2 id="boa-c-228-icky-Linux-kernel-bug-No-such-file-or-directory"><a href="#boa-c-228-icky-Linux-kernel-bug-No-such-file-or-directory" class="headerlink" title="boa.c:228 - icky Linux kernel bug!: No such file or directory"></a><code>boa.c:228 - icky Linux kernel bug!: No such file or directory</code></h2><p>在运行 boa 的时候出现这个错误，<br>修改 <code>src/boa.c</code></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// if(setuid(0) != -1) &#123;</span></span><br><span class="line"><span class="comment">//     DIE(”icky Linux kernel bug!”);</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"><span class="comment">// 注释掉上面的代码</span></span><br><span class="line"><span class="comment">/* if(setuid(0) != -1) &#123;</span></span><br><span class="line"><span class="comment">    DIE(”icky Linux kernel bug!”);</span></span><br><span class="line"><span class="comment">&#125; */</span></span><br></pre></td></tr></table></figure>
]]></content>
  </entry>
  <entry>
    <title>C</title>
    <url>/2022/07/15/C/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>SQLite3 移植</title>
    <url>/2023/01/22/SQLite3%20%E7%A7%BB%E6%A4%8D/</url>
    <content><![CDATA[<p>本文包含 <code>SQLite3</code> 的介绍、移植过程、注意事项和使用方式。</p>
<span id="more"></span>

<h1 id="SQLite3"><a href="#SQLite3" class="headerlink" title="SQLite3"></a>SQLite3</h1><p>SQLite3 是一个开源的嵌入式关系数据库，我们可以将其嵌入到我们的应用程序中，从而实现对数据的管理。SQLite3 的源代码可以从 <a href="https://www.sqlite.org/index.html">SQLite3 官网</a> 下载。<br>以下内容仅为对我所做项目移植的记录，详细内容请参考 <a href="https://www.sqlite.org/docs.html">SQLite3 官方文档</a>。</p>
<h1 id="SQLite3-移植"><a href="#SQLite3-移植" class="headerlink" title="SQLite3 移植"></a>SQLite3 移植</h1><ol>
<li>获取源码 <a href="https://www.sqlite.org/index.html">https://www.sqlite.org/index.html</a></li>
<li>解压源码<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">tar xvf sqlite-autoconf-3340000.tar.gz</span><br><span class="line"><span class="built_in">cd</span> sqlite-autoconf-3340000</span><br></pre></td></tr></table></figure></li>
<li>配置生成 Makefile <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">./configure  --host=arm-linux-gnueabihf  --prefix=<span class="variable">$&#123;PWD&#125;</span>/install</span><br></pre></td></tr></table></figure></li>
<li>make 编译 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">make</span><br></pre></td></tr></table></figure></li>
<li>make install 安装 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">make install</span><br></pre></td></tr></table></figure></li>
<li>将 <code>install</code> 目录下文件和主目录下 <code>sqlite3</code> 下文件进行移植到开发板根文件系统 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cp</span> install/bin/sqlite3  /home/ming/rootfs/bin</span><br><span class="line"><span class="built_in">cp</span> lib/libsqlite3.so.0.8.6  /home/ming/rootfs/lib</span><br></pre></td></tr></table></figure></li>
<li>对 <code>libsqlite3.so.0.8.6</code> 创建符号链接 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> /home/ming/rootfs/lib</span><br><span class="line"><span class="built_in">ln</span> -s libsqlite3.so.0.8.6 libsqlite3.so.0</span><br></pre></td></tr></table></figure></li>
</ol>
<h1 id="SQLite3-注意"><a href="#SQLite3-注意" class="headerlink" title="SQLite3 注意"></a>SQLite3 注意</h1><ol>
<li>实际开发中移植工作尽量在 root 用户下进行</li>
<li>类库移植首先要拿到源码 和 所依赖的库或源码</li>
<li>确定类库运行的硬件平台 (X86架构 或 ARM架构)，可以确定编译器的类型</li>
<li>修改Makefile 编译器(匹配硬件平台)</li>
<li>明确类库的调用方法(如何包含头文件 和 链接类库)<br>在开发中 移植库的工作尽量在 root 用户下移植。因为操作资源是不单单是权限问题</li>
</ol>
<h1 id="SQLite3-类库使用"><a href="#SQLite3-类库使用" class="headerlink" title="SQLite3 类库使用"></a>SQLite3 类库使用</h1><p>参考手册对 <code>sqlite3</code> 源码进行了编译 <code>sqlite3</code> 要运行在 157a 平台上(ARM 架构)，所以我们需要修改 <code>Makefile</code> 对应的编译器</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">./configure --host arm-linux-gnueabi --prefix ./install</span><br><span class="line"><span class="comment"># --host:指定运行主机平台的  指定编译器编译源码   </span></span><br><span class="line"><span class="comment"># --prefix:指定编译好的类库二进制文件的安装路径</span></span><br></pre></td></tr></table></figure>
<h2 id="污染交叉编译器-（不推荐）"><a href="#污染交叉编译器-（不推荐）" class="headerlink" title="污染交叉编译器 （不推荐）"></a>污染交叉编译器 （不推荐）</h2><ol>
<li>将 <code>install/include</code> 目录下的所有 <code>.h</code> 文件拷贝到 <code>toolchain/gcc-7.5.0/arm-linux-gnueabihf/include</code> 下， <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> install/include</span><br><span class="line">sudo <span class="built_in">cp</span> *.h  toolchain/gcc-7.5.0/arm-linux-gnueabihf/include  -arf</span><br></pre></td></tr></table></figure>
此操作解决包含头文件的问题   </li>
<li>将 <code>install/lib/libsqlite3.*</code> 所有文件拷贝到 <code>toolchain/gcc-7.5.0/arm-linux-gnueabihf/lib</code> 下后，<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> install/lib</span><br><span class="line"><span class="built_in">cp</span> libsqlite3.* ~/toolchain/gcc-7.5.0/arm-linux-gnueabihf/lib -arf</span><br></pre></td></tr></table></figure>
此操作解决的是使用 <code>sqlite3</code> 时链接库的问题 <code>arm-linux-gnueabihf-gcc xxx.c -o xxx -lsqlite3</code> 之所以将头文件和编译生成的库文件拷贝到交叉编译器对应的路径下能够解决问题，是因为交叉编译器的预处理包含头文件的路径在交叉编译器中链接器链接的路径也在交叉编译器中</li>
</ol>
<h2 id="添加环境变量"><a href="#添加环境变量" class="headerlink" title="添加环境变量"></a>添加环境变量</h2><p>依据 <code>pkgconfig</code> 目录下的 <code>sqlite3.pc</code> 文件内容进行链接使用</p>
<ol>
<li>打开 <code>bash.bashrc</code> 文件 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">vim /etc/bash.bashrc</span><br></pre></td></tr></table></figure></li>
<li>添加环境变量 <code>PKG_CONFIG_PATH</code> <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">export</span> PKG_CONFIG_PATH=<span class="variable">$PKG_CONFIG_PATH</span>:/home/ming/sqlite-autoconf-3340000/install/lib/pkgconfig/</span><br></pre></td></tr></table></figure></li>
<li>使环境变量生效 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">source</span> /etc/bash.bashrc</span><br></pre></td></tr></table></figure></li>
<li>编译源码链接操作 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">arm-linux-gnueabihf-gcc server.c -o server `pkg-config --cflags --libs sqlite3`</span><br></pre></td></tr></table></figure></li>
</ol>
]]></content>
  </entry>
  <entry>
    <title>子系统</title>
    <url>/2023/03/10/%E5%AD%90%E7%B3%BB%E7%BB%9F/</url>
    <content><![CDATA[<p>本文包含 <code>GPIO</code> <code>IIC</code> <code>SPI</code> 子系统的解析，使用方法，驱动编写思路，代码实现和应用层使用方法，</p>
<span id="more"></span>


<h1 id="子系统"><a href="#子系统" class="headerlink" title="子系统"></a>子系统</h1><h2 id="GPIO"><a href="#GPIO" class="headerlink" title="GPIO"></a>GPIO</h2><h2 id="IIC"><a href="#IIC" class="headerlink" title="IIC"></a>IIC</h2><h2 id="SPI"><a href="#SPI" class="headerlink" title="SPI"></a>SPI</h2>]]></content>
  </entry>
  <entry>
    <title>Git &amp; Github 的使用</title>
    <url>/2021/05/10/git/</url>
    <content><![CDATA[<p>本文包含 <code>Git</code> 和 <code>Github</code> 的介绍和使用方法，对于不了解Git和Github的同志，可以快速入门享受Git和Github的乐趣。   </p>
<span id="more"></span>

<h1 id="Git-Github"><a href="#Git-Github" class="headerlink" title="Git &amp; Github"></a>Git &amp; Github</h1><p>git 和 github 的合作就像是一个人和他的硬盘的关系，git 是一个版本控制系统，它是为了更好地管理和跟踪软件代码的变化而开发的。版本控制系统的主要目标是记录文件的历史变化，允许多人协同开发，并且能够轻松回滚到之前的代码状态。而 github 是一个基于 git 的代码托管平台和开发者社交网络。它提供了一个云端的代码仓库，允许开发者将他们的项目代码存储在云端，并通过 git 进行版本控制。github 允许开发者在云端进行代码管理，方便地与其他开发者协作、共享代码和追踪项目的变化。<br>以下内容仅为我的个人积累，详细内容请参考 <a href="https://git-scm.com/doc">Git 官方文档</a> 和 <a href="https://docs.github.com/en">Github 官方文档</a>。</p>
<h1 id="Git"><a href="#Git" class="headerlink" title="Git"></a>Git</h1><p>Git是一个版本控制系统，使用它就可以对本地的代码进行版本管理，比如可以回滚到之前的代码状态、以及查看代码的修改历史、设置标签或者分支等等。</p>
<h2 id="Git的基本使用"><a href="#Git的基本使用" class="headerlink" title="Git的基本使用"></a>Git的基本使用</h2><ol>
<li>安装 <strong><a href="https://git-scm.com/downloads">Git</a></strong>  </li>
<li>在本第新建一个文件夹，然后右键选择<code>Git Bash Here</code></li>
<li>配置用户信息<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git config --global user.name <span class="string">&quot;Your Name&quot;</span></span><br><span class="line">git config --global user.email <span class="string">&quot;Your Email&quot;</span></span><br></pre></td></tr></table></figure></li>
<li>输入命令初始化仓库  <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git init</span><br></pre></td></tr></table></figure></li>
<li>添加文件到暂存区 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git add . <span class="comment"># 添加所有文件</span></span><br><span class="line">git add [filename] <span class="comment"># 添加指定文件</span></span><br></pre></td></tr></table></figure></li>
<li>提交更改到仓库 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git commit -m <span class="string">&quot;提交说明&quot;</span> <span class="comment"># 提交到仓库</span></span><br></pre></td></tr></table></figure></li>
<li>创建分支和合并分支 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git branch [branchname] <span class="comment"># 创建分支</span></span><br><span class="line">git checkout [branchname] <span class="comment"># 切换分支</span></span><br><span class="line">git merge [branchname] <span class="comment"># 合并分支</span></span><br></pre></td></tr></table></figure></li>
<li>查看分支 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">log</span> <span class="comment"># 查看提交日志</span></span><br><span class="line">git status <span class="comment"># 查看状态</span></span><br><span class="line">git diff <span class="comment"># 查看修改内容</span></span><br></pre></td></tr></table></figure></li>
</ol>
<h1 id="Github"><a href="#Github" class="headerlink" title="Github"></a>Github</h1><p>GitHub是一个基于Git的代码托管平台和开发者社交网络。使用它可以让我们的代码托管在云端，这样就可以与其他开发者合作开发项目等等。</p>
<h2 id="Github的基本使用"><a href="#Github的基本使用" class="headerlink" title="Github的基本使用"></a>Github的基本使用</h2><ol>
<li>注册 <strong><a href="https://github.com/">Github</a></strong></li>
<li>创建仓库<br>登录GitHub后，点击页面右上角的加号图标，选择 <code>&quot;New Repository&quot;</code> 创建一个新的远程仓库。给仓库取一个名称，并设置仓库的可见性（公开或私有）。</li>
<li>关联本地仓库，在这里有两种关联，一种是 <code>HTTPS</code>，一种是 <code>SSH</code>。  <h4 id="HTTPS"><a href="#HTTPS" class="headerlink" title="HTTPS"></a>HTTPS</h4><ol>
<li>在本地仓库中的<code>Git Bash Here</code>中输入命令  <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git remote add origin [YUOR HTTPS URL] <span class="comment"># 关联远程仓库</span></span><br></pre></td></tr></table></figure></li>
</ol>
<h4 id="SSH"><a href="#SSH" class="headerlink" title="SSH"></a>SSH</h4><ol>
<li>在本地仓库中的<code>Git Bash Here</code>中输入命令  <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ssh-keygen -t rsa <span class="comment"># 用RSA算法生成SSH密钥</span></span><br></pre></td></tr></table></figure></li>
<li>在本地家目录下的 <code>.ssh</code> 文件夹中找到 <code>id_rsa.pub</code> 文件，打开并复制里面的内容 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cat</span> ~/.ssh/id_rsa.pub</span><br></pre></td></tr></table></figure></li>
<li>添加到仓库的 <code>SSH Keys</code> 中<br> 登录GitHub后，点击页面右上角的头像，选择 <code>Settings</code>，然后选择 <code>SSH and GPG keys</code>，点击 <code>New SSH key</code>，将复制的内容粘贴到 <code>Key</code> 中，然后点击 <code>Add SSH key</code>。<br> 当然也可以在仓库的 <code>Settings</code> 中选择 <code>Deploy keys</code>，点击 <code>Add deploy key</code>，将复制的内容粘贴到 <code>Key</code> 中，然后点击 <code>Add key</code>。<br> 它们的区别是如果是在 <code>SSH and GPG keys</code> 中添加的话，你可以通过 <code>SSH</code> 访问自己所有仓库，如果是在 <code>Deploy keys</code> 中添加的话，那么只有你添加了密钥的仓库。</li>
<li>在本地仓库中的<code>Git Bash Here</code>中输入命令 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git remote add origin [YUOR SSH URL] <span class="comment"># 关联远程仓库</span></span><br></pre></td></tr></table></figure></li>
</ol>
</li>
<li>推送代码到远程仓库 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git push -u origin master <span class="comment"># 推送到远程仓库并创建 master 分支，当远程仓库没有 master 分支时使用</span></span><br><span class="line">git push origin master <span class="comment"># 推送到远程仓库的 master 分支</span></span><br></pre></td></tr></table></figure></li>
<li>克隆远程仓库 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">clone</span> [YUOR HTTPS URL] <span class="comment"># 通过HTTP克隆远程仓库</span></span><br><span class="line">git <span class="built_in">clone</span> [YUOR SSH URL] <span class="comment"># 通过SSH克隆远程仓库</span></span><br></pre></td></tr></table></figure></li>
<li>拉取远程仓库 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git pull origin master <span class="comment"># 将远程仓库的 master 分支合并到本地仓库的 master 分支</span></span><br></pre></td></tr></table></figure></li>
<li>创建 Pull Request<br>如果您想将您的更改合并到项目的主分支中，您可以在GitHub上创建一个Pull Request。在项目页面中，点击”Pull Request”按钮，然后选择”New Pull Request”创建一个新的拉取请求，并进行描述和讨论。</li>
</ol>
<h1 id="git-github-的使用"><a href="#git-github-的使用" class="headerlink" title="git &amp; github 的使用"></a>git &amp; github 的使用</h1><h2 id="Git-基础"><a href="#Git-基础" class="headerlink" title="Git 基础"></a>Git 基础</h2><h3 id="获取-Git-仓库"><a href="#获取-Git-仓库" class="headerlink" title="获取 Git 仓库"></a>获取 Git 仓库</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git init <span class="comment"># 初始化仓库</span></span><br><span class="line">git add *.c <span class="comment"># 添加所有 .c 文件</span></span><br><span class="line">git add LICENSE <span class="comment"># 添加 LICENSE 文件</span></span><br><span class="line">git commit -m <span class="string">&#x27;initial project version&#x27;</span> <span class="comment"># 提交到仓库 message</span></span><br><span class="line">git <span class="built_in">clone</span> https://github.com/libgit2/libgit2 <span class="comment"># 克隆远程仓库</span></span><br><span class="line">git <span class="built_in">clone</span> https://github.com/libgit2/libgit2 mylibgit <span class="comment"># 在当前目录下新建一个文件夹并初始化并克隆远程仓库</span></span><br></pre></td></tr></table></figure>
<h3 id="记录每次更新到仓库"><a href="#记录每次更新到仓库" class="headerlink" title="记录每次更新到仓库"></a>记录每次更新到仓库</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git status <span class="comment"># 查看状态</span></span><br><span class="line">git status -s <span class="comment"># 简短输出 short</span></span><br><span class="line">git diff <span class="comment"># 比较工作目录中当前文件和暂存区域快照之间的差异</span></span><br><span class="line">git diff --staged <span class="comment"># 比较暂存区域和最后一次提交的差异</span></span><br><span class="line">git diff --cached <span class="comment"># 查看已经暂存起来的变化（ --staged 和 --cached 是同义词）</span></span><br><span class="line">git commit <span class="comment"># 提交到仓库并打开编辑器输入提交说明</span></span><br><span class="line">git commit -m <span class="string">&#x27;message&#x27;</span> <span class="comment"># 将提交信息和命令放在同一行</span></span><br><span class="line">git commit -a -m <span class="string">&#x27;message&#x27;</span> <span class="comment"># 跳过使用暂存区域，直接将所有已经跟踪过的文件暂存起来一并提交</span></span><br><span class="line">git <span class="built_in">rm</span> PROJECTS.md <span class="comment"># 从暂存区域移除文件</span></span><br><span class="line">git <span class="built_in">rm</span> -f PROJECTS.md <span class="comment"># 强制从暂存区域移除文件 force</span></span><br><span class="line">git <span class="built_in">rm</span> --cached README <span class="comment"># 从暂存区域移除文件但不删除文件</span></span><br><span class="line">git <span class="built_in">rm</span> <span class="built_in">log</span>/\*.<span class="built_in">log</span> <span class="comment"># 删除log/目录下所有.log文件</span></span><br><span class="line">git <span class="built_in">rm</span> \*~ <span class="comment"># 删除所有名字以~结尾的文件</span></span><br><span class="line">git <span class="built_in">mv</span> file_from file_to <span class="comment"># 对文件改名 rm + add</span></span><br></pre></td></tr></table></figure>

<h2 id="Git-分支"><a href="#Git-分支" class="headerlink" title="Git 分支"></a>Git 分支</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git branch testing <span class="comment"># 创建分支</span></span><br><span class="line">git <span class="built_in">log</span> --oneline --decorate <span class="comment"># 查看各个分支当前所指的对象，由 --decorate 选项可以看到每一个分支的最后一次提交</span></span><br><span class="line">git <span class="built_in">log</span> --oneline --decorate --graph --all <span class="comment"># 输出你的提交历史、各个分支的指向以及项目的分支分叉情况</span></span><br><span class="line">git checkout testing <span class="comment"># 切换分支</span></span><br><span class="line">git checkout -b iss53 <span class="comment"># 创建并切换到 iss53 分支 branch</span></span><br><span class="line">git merge hotfix <span class="comment"># 合并 hotfix 分支到当前分支</span></span><br><span class="line">git branch -d hotfix <span class="comment"># 删除 hotfix 分支 delete</span></span><br><span class="line">git mergetool <span class="comment"># 合并冲突可视化工具</span></span><br></pre></td></tr></table></figure>]]></content>
  </entry>
  <entry>
    <title>sys_select 剖析</title>
    <url>/2022/07/10/sys_select%E5%86%85%E9%83%A8%E5%AE%9E%E7%8E%B0/</url>
    <content><![CDATA[<p>本文包含对 <code>sys_select</code> 从内核层面的实现进行剖析</p>
<span id="more"></span>

<h1 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h1><p><code>sys_select</code> 函数是一个系统调用，它的作用是监视一组文件描述符，并在这组文件描述符中的任何一个上发生变化时通知进程。下面对它进行分析<br>以下内容仅为我的个人积累，详细内容请参考官方文档和相关书籍。</p>
<h2 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h2><p>首先在应用层调用接口  </p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">select(fd2 + <span class="number">1</span>, &amp;rfds, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br></pre></td></tr></table></figure>

<h2 id="内核"><a href="#内核" class="headerlink" title="内核"></a>内核</h2><p>vi -t sys_select</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">SYSCALL_DEFINE5(select, <span class="type">int</span>, n, fd_set __user *, inp, fd_set __user *, outp,</span><br><span class="line">        fd_set __user *, <span class="built_in">exp</span>, <span class="keyword">struct</span> __kernel_old_timeval __user *, tvp) </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> kern_select(n, inp, outp, <span class="built_in">exp</span>, tvp);</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">sys_select</span><span class="params">(<span class="type">int</span> n,fd_set __user * inp, fd_set __user * outp,</span></span><br><span class="line"><span class="params">        fd_set __user * <span class="built_in">exp</span>, <span class="keyword">struct</span> __kernel_old_timeval __user * tvp)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> kern_select(n, inp, outp, <span class="built_in">exp</span>, tvp);</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">kern_select</span><span class="params">(<span class="type">int</span> n, fd_set __user *inp, fd_set __user *outp,</span></span><br><span class="line"><span class="params">		       fd_set __user *<span class="built_in">exp</span>, <span class="keyword">struct</span> __kernel_old_timeval __user *tvp)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> ret;</span><br><span class="line">	</span><br><span class="line">	ret = core_sys_select(n, inp, outp, <span class="built_in">exp</span>, to);</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> poll_select_finish(&amp;end_time, tvp, PT_TIMEVAL, ret);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">core_sys_select</span><span class="params">(<span class="type">int</span> n, fd_set __user *inp, fd_set __user *outp,</span></span><br><span class="line"><span class="params">			   fd_set __user *<span class="built_in">exp</span>, <span class="keyword">struct</span> timespec64 *end_time)</span></span><br><span class="line">&#123;</span><br><span class="line">	fd_set_bits fds;</span><br><span class="line">	<span class="type">void</span> *bits;</span><br><span class="line">	<span class="type">int</span> ret, max_fds;</span><br><span class="line">	<span class="type">size_t</span> size, alloc_size;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">fdtable</span> *<span class="title">fdt</span>;</span></span><br><span class="line">	<span class="comment">/* Allocate small arguments on the stack to save memory and be faster */</span></span><br><span class="line">	<span class="type">long</span> stack_fds[SELECT_STACK_ALLOC/<span class="keyword">sizeof</span>(<span class="type">long</span>)];</span><br><span class="line"></span><br><span class="line">	ret = -EINVAL;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//1.如果用户写的最大文件描述符的值小于0，直接报错返回</span></span><br><span class="line">	<span class="keyword">if</span> (n &lt; <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">goto</span> out_nofds;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//2.从当前进程中获取最大文件描述符个数和用户传递的n做比较</span></span><br><span class="line">	<span class="comment">//如果用户传递的文件描述符的值不合法，强制更正。</span></span><br><span class="line">	<span class="comment">//current---&gt;task_struct功能?</span></span><br><span class="line">	<span class="comment">//#define current get_current()</span></span><br><span class="line">	<span class="comment">//#define get_current() (current_thread_info()-&gt;task)  获取了当前进程的结构体</span></span><br><span class="line">	fdt = files_fdtable(current-&gt;files);</span><br><span class="line">	max_fds = fdt-&gt;max_fds;</span><br><span class="line">	<span class="keyword">if</span> (n &gt; max_fds)</span><br><span class="line">		n = max_fds;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//3.分配6张表的内存，前3张表存用户的文件描述符集合</span></span><br><span class="line">	<span class="comment">//后3张表存放就绪的文件描述符</span></span><br><span class="line">	alloc_size = <span class="number">6</span> * size;</span><br><span class="line">	bits = kvmalloc(alloc_size, GFP_KERNEL);</span><br><span class="line"></span><br><span class="line">	fds.in      = bits;</span><br><span class="line">	fds.out     = bits +   size;</span><br><span class="line">	fds.ex      = bits + <span class="number">2</span>*size;</span><br><span class="line">	fds.res_in  = bits + <span class="number">3</span>*size;</span><br><span class="line">	fds.res_out = bits + <span class="number">4</span>*size;</span><br><span class="line">	fds.res_ex  = bits + <span class="number">5</span>*size;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//将用户空间表中的数据拷贝到内核空间中</span></span><br><span class="line">	<span class="keyword">if</span> ((ret = get_fd_set(n, inp, fds.in)) ||</span><br><span class="line">	    (ret = get_fd_set(n, outp, fds.out)) ||</span><br><span class="line">	    (ret = get_fd_set(n, <span class="built_in">exp</span>, fds.ex)))</span><br><span class="line">		<span class="keyword">goto</span> out;</span><br><span class="line">	<span class="comment">//将就绪的三张表清零</span></span><br><span class="line">	zero_fd_set(n, fds.res_in);</span><br><span class="line">	zero_fd_set(n, fds.res_out);</span><br><span class="line">	zero_fd_set(n, fds.res_ex);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//4.文件描述符遍历工作</span></span><br><span class="line">	ret = do_select(n, &amp;fds, end_time);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (ret &lt; <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">goto</span> out;</span><br><span class="line">	<span class="keyword">if</span> (!ret) &#123;</span><br><span class="line">		ret = -ERESTARTNOHAND;</span><br><span class="line">		<span class="keyword">if</span> (signal_pending(current))</span><br><span class="line">			<span class="keyword">goto</span> out;</span><br><span class="line">		ret = <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//5.将就绪的文件描述符拷贝到用户空间</span></span><br><span class="line">	<span class="keyword">if</span> (set_fd_set(n, inp, fds.res_in) ||</span><br><span class="line">	    set_fd_set(n, outp, fds.res_out) ||</span><br><span class="line">	    set_fd_set(n, <span class="built_in">exp</span>, fds.res_ex))</span><br><span class="line">		ret = -EFAULT;</span><br><span class="line"></span><br><span class="line">out:</span><br><span class="line">	<span class="keyword">if</span> (bits != stack_fds)</span><br><span class="line">		kvfree(bits);</span><br><span class="line">out_nofds:</span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">do_select</span><span class="params">(<span class="type">int</span> n, fd_set_bits *fds, <span class="keyword">struct</span> timespec64 *end_time)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">ktime_t</span> expire, *to = <span class="literal">NULL</span>;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">poll_wqueues</span> <span class="title">table</span>;</span></span><br><span class="line">	poll_table *wait;</span><br><span class="line">	<span class="type">int</span> retval, i, timed_out = <span class="number">0</span>;</span><br><span class="line">	u64 slack = <span class="number">0</span>;</span><br><span class="line">	<span class="type">__poll_t</span> busy_flag = net_busy_loop_on() ? POLL_BUSY_LOOP : <span class="number">0</span>;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> busy_start = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//1.对最大的文件描述符的值做校验工作</span></span><br><span class="line">	n = retval;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//2.初始化了一个构造等待队列的函数(这个函数没有被调用)</span></span><br><span class="line">	poll_initwait(&amp;table);</span><br><span class="line">	wait = &amp;table.pt;</span><br><span class="line"></span><br><span class="line">	retval = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (;;) &#123;</span><br><span class="line">		<span class="type">unsigned</span> <span class="type">long</span> *rinp, *routp, *rexp, *inp, *outp, *<span class="built_in">exp</span>;</span><br><span class="line">		<span class="type">bool</span> can_busy_loop = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">		<span class="comment">//分配6个unsigned long的指针用于从6张表中获取第一个unsigned long的整数</span></span><br><span class="line">		inp = fds-&gt;in; outp = fds-&gt;out; <span class="built_in">exp</span> = fds-&gt;ex;</span><br><span class="line">		rinp = fds-&gt;res_in; routp = fds-&gt;res_out; rexp = fds-&gt;res_ex;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; ++rinp, ++routp, ++rexp) &#123;</span><br><span class="line">			<span class="type">unsigned</span> <span class="type">long</span> in, out, ex, all_bits, bit = <span class="number">1</span>, j;</span><br><span class="line">			<span class="type">unsigned</span> <span class="type">long</span> res_in = <span class="number">0</span>, res_out = <span class="number">0</span>, res_ex = <span class="number">0</span>;</span><br><span class="line">			<span class="type">__poll_t</span> mask;</span><br><span class="line"></span><br><span class="line">			<span class="comment">//从表中取出第一个unsigned long的整数，如果这个值不为0，说明</span></span><br><span class="line">			<span class="comment">//里面有要监听的文件描述符，如果为0说明没有监听的文件描述符，</span></span><br><span class="line">			<span class="comment">//执行continue，判断下一个unsigned long是否有数据</span></span><br><span class="line">			in = *inp++; out = *outp++; ex = *<span class="built_in">exp</span>++;</span><br><span class="line">			all_bits = in | out | ex;</span><br><span class="line">			<span class="keyword">if</span> (all_bits == <span class="number">0</span>) &#123;</span><br><span class="line">				i += BITS_PER_LONG;</span><br><span class="line">				<span class="keyword">continue</span>;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="comment">//如果all_bits不为0 ，说明里面有bit为是1，找出bit位为1</span></span><br><span class="line">			<span class="comment">//的文件描述符</span></span><br><span class="line">			<span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; BITS_PER_LONG; ++j, ++i, bit &lt;&lt;= <span class="number">1</span>) &#123;</span><br><span class="line">				<span class="class"><span class="keyword">struct</span> <span class="title">fd</span> <span class="title">f</span>;</span></span><br><span class="line">				<span class="keyword">if</span> (i &gt;= n)</span><br><span class="line">					<span class="keyword">break</span>;</span><br><span class="line">				<span class="keyword">if</span> (!(bit &amp; all_bits))</span><br><span class="line">					<span class="keyword">continue</span>;</span><br><span class="line">				<span class="comment">//这里的i就是找到的文件描述，比如i=3或者i=4</span></span><br><span class="line">				<span class="comment">//i==fd--&gt;fd_array[fd]---&gt;file--&gt;f_op--&gt;poll</span></span><br><span class="line">				f = fdget(i);</span><br><span class="line">				<span class="keyword">if</span> (f.file) &#123;</span><br><span class="line">					<span class="comment">//调用驱动的poll函数</span></span><br><span class="line">					mask = file-&gt;f_op-&gt;poll(f.file, wait);</span><br><span class="line"></span><br><span class="line">					<span class="keyword">if</span> ((mask &amp; POLLIN_SET) &amp;&amp; (in &amp; bit)) &#123;</span><br><span class="line">						res_in |= bit;</span><br><span class="line">						retval++;</span><br><span class="line">						wait-&gt;_qproc = <span class="literal">NULL</span>;</span><br><span class="line">					&#125;</span><br><span class="line">					<span class="keyword">if</span> ((mask &amp; POLLOUT_SET) &amp;&amp; (out &amp; bit)) &#123;</span><br><span class="line">						res_out |= bit;</span><br><span class="line">						retval++;</span><br><span class="line">						wait-&gt;_qproc = <span class="literal">NULL</span>;</span><br><span class="line">					&#125;</span><br><span class="line">					<span class="keyword">if</span> ((mask &amp; POLLEX_SET) &amp;&amp; (ex &amp; bit)) &#123;</span><br><span class="line">						res_ex |= bit;</span><br><span class="line">						retval++;</span><br><span class="line">						wait-&gt;_qproc = <span class="literal">NULL</span>;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;	</span><br><span class="line">		&#125;</span><br><span class="line">	</span><br><span class="line">		<span class="comment">//select退出的三个条件:1.数据准备好了，2.超时时间到了，3.收到了信号</span></span><br><span class="line">		<span class="keyword">if</span> (retval || timed_out || signal_pending(current))</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//进程休眠</span></span><br><span class="line">		<span class="keyword">if</span> (!poll_schedule_timeout(&amp;table, TASK_INTERRUPTIBLE,</span><br><span class="line">					   to, slack))</span><br><span class="line">			timed_out = <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	poll_freewait(&amp;table);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> retval;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
  </entry>
  <entry>
    <title>库的制作及使用</title>
    <url>/2022/10/25/%E5%BA%93%E7%9A%84%E5%88%B6%E4%BD%9C%E5%8F%8A%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<p>本文包含</p>
<span id="more"></span>

<h1 id="库"><a href="#库" class="headerlink" title="库"></a>库</h1>]]></content>
  </entry>
  <entry>
    <title>总线协议</title>
    <url>/2023/01/14/%E6%80%BB%E7%BA%BF%E5%8D%8F%E8%AE%AE/</url>
    <content><![CDATA[<p>本文包括 <code>UART</code> <code>IIC</code> <code>SCCB</code> <code>SPI</code> 总线协议的解析，使用方法，驱动编写思路。</p>
<span id="more"></span>

<h1 id="IIC"><a href="#IIC" class="headerlink" title="IIC"></a>IIC</h1><p>一种<strong>同步串行</strong>的<strong>半双工</strong>总线，使用一根数据线<strong>SDA</strong>和一根时钟线<strong>SCL</strong>来传输数据，具有结构简单，接口连接方便，成本低的特点，速率再100kbps-400kbps之间。</p>
<h2 id="连接方式"><a href="#连接方式" class="headerlink" title="连接方式"></a>连接方式</h2><p><img src="/../image/IIClink.png" alt="IIC link"></p>
<h2 id="通信方式"><a href="#通信方式" class="headerlink" title="通信方式"></a>通信方式</h2><h3 id="起始信号-和-终止信号"><a href="#起始信号-和-终止信号" class="headerlink" title="起始信号 和 终止信号"></a>起始信号 和 终止信号</h3><p>在时钟线为<strong>高电平</strong>时，数据线<strong>由高电平跳变到低</strong>电平，表示起始信号。<br>在时钟线为<strong>高电平</strong>时，数据线<strong>由低电平跳变到高</strong>电平，表示终止信号。<br><img src="/../image/IICstart.png" alt="IIC start"></p>
<h3 id="数据"><a href="#数据" class="headerlink" title="数据"></a>数据</h3><p>数据传输时，在时钟线为高电平时，要求数据线的数据保持稳定，只有在时钟线为低电平时，数据线的数据才能发生变化。一个时钟周期完成1bit数据的传输。<br>每一个字节必须保证是<strong>8</strong>位长度。数据传送时，先传送最<strong>高位</strong>（MSB），每一个被传送的字节后面都必须跟随一位<strong>应答位</strong>（即一帧共有9位）。<br><img src="/../image/IICdata.png" alt="IIC data"></p>
<h3 id="应答"><a href="#应答" class="headerlink" title="应答"></a>应答</h3><p>在时钟线为高电平时，数据线由高电平跳变到低电平，表示应答位。<br>在时钟线为高电平时，数据线由低电平跳变到高电平，表示非应答位。</p>
<h3 id="寻址"><a href="#寻址" class="headerlink" title="寻址"></a>寻址</h3><p>IIC总线支持7、8、10位寻址，主机在起始信号后必须传送一个从机的地址（7位），第<strong>8位</strong>是数据的传送方向位（R&#x2F;W），用“0”表示主机发送数据（W），“1”表示主机接收数据（R）。总线上的每个从机都将这7位地址码与自己的地址进行比较，如果相同，则认为自己被主机寻址，根据R&#x2F;W位将自己定为发送器或接收器。<br><img src="/../image/IIC7.png" alt="IIC 7"><br>8位寻址和7位相似，只不过厂商在提供地址时，将第八位读写位包含在了地址中，所以前7位才是真正的地址。<br><img src="/../image/IIC8.png" alt="IIC 8"><br>10位寻址略有不同，10位地址需要分两帧发送，其中第一帧的前5位是固定的<code>11110</code>,后跟地址的高两位，最后一位为读写位，第二帧为地址的低8位。<br><img src="/../image/IIC10.png" alt="IIC 10"></p>
<h2 id="数据读写"><a href="#数据读写" class="headerlink" title="数据读写"></a>数据读写</h2><p><strong>写操作</strong>：主机发送起始信号，发送从机地址和写信号，从机应答，主机发送数据，从机应答，主机发送终止信号。<br><code>start + (7bit从机地址+1bit写0) + ack + (8bit/16bit寄存器地址) + ack + (8bit/16bit数据) + ack + stop</code><br><img src="/../image/IICwrite.png" alt="IIC write"><br><strong>读操作</strong>：主机发送起始信号，发送从机地址和写信号，从机应答，主机再次发送起始信号，发送从机地址和读信号，应答，主机接受数据，不给应答，主机发送终止信号。<br><img src="/../image/IICread.png" alt="IIC read"></p>
<h2 id="速率"><a href="#速率" class="headerlink" title="速率"></a>速率</h2><p>100KHz 高速、400KHz全速、3.4MHz高速</p>
<h2 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h2><ul>
<li>串行通信，只需要两根线，数据线和时钟线</li>
<li>半双工通信，数据只能单向传输</li>
<li>串行数据传输，具备应答机制。</li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>系统移植</title>
    <url>/2023/01/10/%E7%B3%BB%E7%BB%9F%E7%A7%BB%E6%A4%8D/</url>
    <content><![CDATA[<p>本文包含 <code>u-boot</code> 、<code>kernel</code> 、<code>rootfs</code> 的解析编译移植，<code>rootfs</code> 的介绍、语法、编写，<code>kernel</code> 的裁剪。</p>
<span id="more"></span>

<h1 id="系统移植"><a href="#系统移植" class="headerlink" title="系统移植"></a>系统移植</h1><h2 id="移植前准备"><a href="#移植前准备" class="headerlink" title="移植前准备"></a>移植前准备</h2><h3 id="1-Ubuntu-系统安装交叉编译器"><a href="#1-Ubuntu-系统安装交叉编译器" class="headerlink" title="1. Ubuntu 系统安装交叉编译器"></a>1. Ubuntu 系统安装<strong>交叉编译器</strong></h3><p>用来编译 <code>u-boot</code> 、<code>kernel</code> 、<code>rootfs</code> 。</p>
<ol>
<li>创建文件夹并拷贝文件<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> toolchain</span><br><span class="line"><span class="built_in">cp</span> /mnt/hgfs/gcc-linaro-7.5.0-2019.12-x86_64_arm-linux-gnueabihf.tar toolchain/</span><br></pre></td></tr></table></figure></li>
<li>解压文件<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> toolchain</span><br><span class="line">tar -xvf gcc-linaro-7.5.0-2019.12-x86_64_arm-linux-gnueabihf.tar</span><br><span class="line"><span class="built_in">mv</span> gcc-linaro-7.5.0-2019.12-x86_64_arm-linux-gnueabihf  gcc-7.5.0 <span class="comment">## 简化目录名</span></span><br></pre></td></tr></table></figure></li>
<li>配置PATH环境变量<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">vim /etc/bash.bashrc</span><br><span class="line"><span class="comment"># 在文件末尾添加</span></span><br><span class="line"><span class="built_in">export</span> PATH=<span class="variable">$PATH</span>:/home/ming/toolchain/gcc-7.5.0/bin</span><br><span class="line"><span class="comment"># 使环境变量生效</span></span><br><span class="line"><span class="built_in">source</span> /etc/bash.bashrc</span><br></pre></td></tr></table></figure></li>
<li>测试<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">arm-linux-gnueabihf-gcc -v</span><br><span class="line"><span class="comment"># gcc version 7.5.0 (Linaro GCC 7.5-2019.12)</span></span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="2-Ubuntu-系统安装tftp服务"><a href="#2-Ubuntu-系统安装tftp服务" class="headerlink" title="2. Ubuntu 系统安装tftp服务"></a>2. Ubuntu 系统安装<strong>tftp服务</strong></h3><p>用来传输各种文件，比如 <code>uImage</code> 、<code>dtb</code> 等。<br><img src="/../image/SYStftp.png" alt="tftp"></p>
<ol>
<li>安装<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo apt-get install tftpd-hpa tftp-hpa</span><br></pre></td></tr></table></figure></li>
<li>修改tftp配置文件 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo vim /etc/default/tftpd-hpa</span><br><span class="line"><span class="comment"># 修改配置文件</span></span><br><span class="line"><span class="comment"># TFTP_USERNAME=&quot;tftp&quot; # 服务用户名</span></span><br><span class="line"><span class="comment"># TFTP_DIRECTORY=&quot;/home/ming/tftpboot&quot; # 服务目录</span></span><br><span class="line"><span class="comment"># TFTP_ADDRESS=&quot;:69&quot; # 服务端口</span></span><br><span class="line"><span class="comment"># TFTP_OPTIONS=&quot;-c -s -l&quot; # 服务参数</span></span><br><span class="line"><span class="built_in">mkdir</span> /home/ming/tftpboot</span><br></pre></td></tr></table></figure></li>
<li>重启服务<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo service tftpd-hpa restart</span><br></pre></td></tr></table></figure></li>
<li>本地测试<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">tftp 127.0.0.1</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="3-Ubuntu-系统安装nfs服务"><a href="#3-Ubuntu-系统安装nfs服务" class="headerlink" title="3. Ubuntu 系统安装nfs服务"></a>3. Ubuntu 系统安装<strong>nfs服务</strong></h3><p>用来通过网络的方式从ubuntu服务器中挂载根文件系统。<br><img src="/../image/SYSnfs.png" alt="nfs"></p>
<ol>
<li>安装nfs服务<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt-get install nfs-kernel-server</span><br></pre></td></tr></table></figure></li>
<li>修改nfs服务的配置文件<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo vim /etc/exports</span><br><span class="line"><span class="comment"># 最后添加</span></span><br><span class="line"><span class="comment"># /home/ming/rootfs *(rw,sync,no_root_squash,no_subtree_check)</span></span><br><span class="line"><span class="comment"># 解释：</span></span><br><span class="line"><span class="comment"># /home/ming/rootfs：根文件系统的路径，修改为自己的路径</span></span><br><span class="line"><span class="comment"># * ---&gt; 指所有的用户</span></span><br><span class="line"><span class="comment"># rw ---&gt; 对根文件系统可读可写的权限</span></span><br><span class="line"><span class="comment"># sync ---&gt; 同步文件</span></span><br><span class="line"><span class="comment"># no_root_squash ---&gt; 来访的root用户保持root帐号权限</span></span><br><span class="line"><span class="comment"># no_subtree_check ---&gt; 即使输出目录是一个子目录，</span></span><br><span class="line"><span class="comment"># nfs服务器也不检查其父目录的权限，这样可以提高效率；</span></span><br></pre></td></tr></table></figure></li>
<li>在Ubuntu系统中创建根文件系统的目录<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo <span class="built_in">mkdir</span> /home/ming/rootfs</span><br><span class="line"><span class="built_in">mv</span> /mnt/hgfs/rootfs.tar.xz /home/ming/rootfs/</span><br><span class="line">tar -xvf rootfs.tar.xz</span><br></pre></td></tr></table></figure></li>
<li>重启nfs服务<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo service nfs-kernel-server restart</span><br></pre></td></tr></table></figure></li>
<li>本地测试<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo mount -t nfs 127.0.0.1:/home/ming/rootfs    /mnt</span><br><span class="line"><span class="comment"># 没有问题后取消挂载</span></span><br><span class="line">sudo umount /mnt</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="开发阶段部署和启动"><a href="#开发阶段部署和启动" class="headerlink" title="开发阶段部署和启动"></a>开发阶段部署和启动</h2><p><img src="/../image/SYSnfs.png" alt="nfs"></p>
<ol>
<li>拷贝 <strong>uImage</strong> 和 <strong>stm32mp157a-fsmp1a.dtb</strong> 文件到ubuntu系统的~&#x2F;tftpboot目录下<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cp</span> /mnt/hgfs/uImage ~/tftpboot/</span><br><span class="line"><span class="built_in">cp</span> /mnt/hgfs/stm32mp157a-fsmp1a.dtb ~/tftpboot/</span><br></pre></td></tr></table></figure></li>
<li>使用 tftp 命令下载 <strong>uImage</strong> 到内存中<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">tftp 0xc2000000 uImage</span><br></pre></td></tr></table></figure></li>
<li>使用 tftp 命令下载 <strong>stm32mp157a-fsmp1a.dtb</strong> 文件到内存中<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">tftp 0xc4000000 stm32mp157a-fsmp1a.dtb</span><br></pre></td></tr></table></figure></li>
<li>设置 u-boot 中的环境变量 <strong>bootargs</strong> 自启动参数<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">setenv bootargs root=/dev/nfs  nfsroot=192.168.2.250:/home/linux/rootfs,tcp,v4 rw console=ttySTM0,115200 init=/linuxrc ip=192.168.2.100</span><br><span class="line">saveenv</span><br><span class="line"><span class="comment"># 解析:</span></span><br><span class="line"><span class="comment"># bootargs环境变量中的值：</span></span><br><span class="line"><span class="comment"># root=/dev/nfs  ：使用nfs网络文件系统</span></span><br><span class="line"><span class="comment"># nfsroot=192.168.2.250:/home/linux/rootfs,</span></span><br><span class="line"><span class="comment"># tcp,v4  ： nfs基于TCP实现，v4版本</span></span><br><span class="line"><span class="comment"># rw ： 对跟文件系统具有可读可写的权限</span></span><br><span class="line"><span class="comment"># console=ttySTM0,115200 	：使用的是哪个串口，及串口的波特率</span></span><br><span class="line"><span class="comment"># init=/linuxrc  ： 挂载根文件系统之后，允许的第一个程序</span></span><br><span class="line"><span class="comment"># ip=192.168.2.100  ： 开发板的IP地址</span></span><br></pre></td></tr></table></figure></li>
<li>启动开发板的 linux 系统 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">bootm 0xc2000000 - 0xc4000000</span><br></pre></td></tr></table></figure></li>
<li>设置开发板的系统为自动加载自动启动的方式<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">setenv bootcmd <span class="string">&quot;tftp 0xc2000000 uImage;tftp 0xc4000000 stm32mp157a-fsmp1a.dtb;bootm 0xc2000000 - 0xc4000000&quot;</span></span><br><span class="line">saveenv</span><br></pre></td></tr></table></figure></li>
<li>编写应用程序，在开发板中允许应用程序<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 1. 编写应用程序</span></span><br><span class="line"><span class="comment"># 2. 交叉编译</span></span><br><span class="line">arm-linux-gnueabihf-gcc hello.c -o hello</span><br><span class="line"><span class="comment"># 3. 拷贝到ubuntu系统的~/rootfs目录下</span></span><br><span class="line"><span class="built_in">cp</span> hello ~/rootfs/</span><br><span class="line"><span class="comment"># 4. 在开发板中运行</span></span><br><span class="line">./hello</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="产品阶段部署和启动"><a href="#产品阶段部署和启动" class="headerlink" title="产品阶段部署和启动"></a>产品阶段部署和启动</h2><p><img src="/../image/SYSproduct.png" alt="system product"><br><img src="/../image/SYSproduct1.png" alt="system product"></p>
<ol>
<li>拷贝 <strong>uImage</strong> 和 <strong>stm32mp157a-fsmp1a.dtb</strong> <strong>ramdisk.img</strong> 文件到ubuntu系统的~&#x2F;tftpboot目录下<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cp</span> /mnt/hgfs/uImage ~/tftpboot/</span><br><span class="line"><span class="built_in">cp</span> /mnt/hgfs/stm32mp157a-fsmp1a.dtb ~/tftpboot/</span><br><span class="line"><span class="built_in">cp</span> /mnt/hgfs/ramdisk.img ~/tftpboot/</span><br></pre></td></tr></table></figure></li>
<li>部署 <strong>uImage</strong> 镜像到TF卡的 <strong>bootfs</strong> 分区<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mmc dev 0</span><br><span class="line">tftp 0xc2000000 uImage</span><br><span class="line">mmc write 0xc2000000 0x2000 0x4000</span><br><span class="line"><span class="comment"># 解释：</span></span><br><span class="line"><span class="comment"># 0x2000 : TF卡的bootfs分区的起始地址</span></span><br><span class="line"><span class="comment"># 0x4000 : 搬移的大小</span></span><br><span class="line"><span class="comment"># Bytes transferred = 7497520 (726730 hex) ，7497520 / 512 = 14643 = 0x3933</span></span><br></pre></td></tr></table></figure></li>
<li>部署 <strong>stm32mp157a-fsmp1a.dtb</strong> 文件到TF卡的 <strong>rootfs</strong> 分区<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mmc dev 0</span><br><span class="line">tftp 0xc2000000 stm32mp157a-fsmp1a.dtb</span><br><span class="line">mmc write 0xc2000000 0x10000 0x200</span><br><span class="line"><span class="comment"># 解释：</span></span><br><span class="line"><span class="comment"># Bytes transferred = 76186 (1299a hex), 76186 / 512 = 148 = 0x94</span></span><br></pre></td></tr></table></figure></li>
<li>部署 <strong>ramdisk.img</strong> 镜像文件到tf卡的 <strong>rootfs</strong> 分区<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mmc dev 0</span><br><span class="line">tftp 0xc2000000 ramdisk.img</span><br><span class="line">mmc write 0xc2000000 0x21500 0x21500</span><br><span class="line"><span class="comment"># 解释：</span></span><br><span class="line"><span class="comment"># Bytes transferred = 16345960 (f96b68 hex), 16345960 / 512 = 31925 = 0x7CB5</span></span><br></pre></td></tr></table></figure></li>
<li>设置 u-boot 中的 bootargs 自启动参数<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">setenv bootargs root=/dev/ram console=ttySTM0,115200 initrd=0xc5000040,0x1000000 rw init=/linuxrc rootfstype=ext4</span><br><span class="line">saveenv</span><br><span class="line"><span class="comment"># 解释：</span></span><br><span class="line"><span class="comment"># root=/dev/ram : 使用ram文件系统</span></span><br><span class="line"><span class="comment"># console=ttySTM0,115200 : 使用串口打印内核信息，波特率115200</span></span><br><span class="line"><span class="comment"># initrd=0xc5000040,0x1000000 : 根文件系统的加载地址，大小</span></span><br><span class="line"><span class="comment">#    根文件系统的加载地址为 ：0xc5000000</span></span><br><span class="line"><span class="comment">#    + 0x40 ：表示跳过ramdisk.img镜像文件的64字节的文件头</span></span><br><span class="line"><span class="comment"># rw : 可读可写的权限</span></span><br><span class="line"><span class="comment"># init=/linuxrc : 挂载根文件系统之后运行的1号程序</span></span><br><span class="line"><span class="comment"># rootfstype=ext4 : 根文件系统的格式</span></span><br></pre></td></tr></table></figure></li>
<li>启动开发板的 linux 系统 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mmc dev 0</span><br><span class="line">mmc <span class="built_in">read</span> 0xc2000000 0x200 0x4000</span><br><span class="line">mmc <span class="built_in">read</span> 0xc4000000 0x10000 0x200</span><br><span class="line">mmc <span class="built_in">read</span> 0xc5000000 0x21500 0x21500</span><br><span class="line">bootm 0xc2000000 0xc5000000 0xc4000000</span><br></pre></td></tr></table></figure></li>
<li>设置开发板的系统为自动加载自动启动的方式<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">setenv bootcmd <span class="string">&quot;mmc dev 0;mmc read 0xc2000000 0x2000 0x4000;mmc read 0xc4000000 0x10000 0x200;mmc read 0xc5000000 0x21500 0x21500;bootm 0xc2000000 0xc5000000 0xc4000000&quot;</span></span><br><span class="line">saveenv</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="TF-卡的分区"><a href="#TF-卡的分区" class="headerlink" title="TF 卡的分区"></a>TF 卡的分区</h3><ol>
<li>删除原有分区<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo parted -s /dev/sdv mklabel msdos</span><br><span class="line"><span class="comment"># 如果正在使用需要卸载</span></span><br><span class="line"><span class="comment"># sudo umount /dev/sdvx (x = 1 ~ 5)</span></span><br></pre></td></tr></table></figure></li>
<li>重新分区<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo sgdisk --resize-table=128 -a 1 -n 1:34:545 -c 1:fsbl1 -n 2:546:1057 -c 2:fsbl2 -n 3:1058:5153 -c 3:ssbl -n 4:5154:136225 -c 4:bootfs -n 5:136226 -c 5:rootfs -A 4:<span class="built_in">set</span>:2 -p /dev/sdb -g</span><br><span class="line"><span class="comment"># 解释：</span></span><br><span class="line"><span class="comment"># sgdisk : 分区的命令</span></span><br><span class="line"><span class="comment"># --resize-table=128 -a 1 : 分区对齐处理</span></span><br><span class="line"><span class="comment"># -n 1:34:545 -c 1:fsbl1 </span></span><br><span class="line"><span class="comment"># -n 2:546:1057 -c 2:fsbl2 </span></span><br><span class="line"><span class="comment"># -n 3:1058:5153 -c 3:ssbl </span></span><br><span class="line"><span class="comment"># -n 4:5154:136225 -c 4:bootfs </span></span><br><span class="line"><span class="comment"># -n 5:136226 -c 5:rootfs </span></span><br><span class="line"><span class="comment"># -n(创建分区) 分区编号:起始块号:终止块号 -c(分区名) 分区编号:分区名</span></span><br><span class="line"><span class="comment"># -A 4:set:2 	---&gt; 设置分区的属性</span></span><br><span class="line"><span class="comment"># -p /dev/sdb -g	----&gt; 打印分区的结果</span></span><br></pre></td></tr></table></figure></li>
</ol>
<h1 id="u-boot"><a href="#u-boot" class="headerlink" title="u-boot"></a>u-boot</h1><h2 id="分析-u-boot-源码"><a href="#分析-u-boot-源码" class="headerlink" title="分析 u-boot 源码"></a>分析 u-boot 源码</h2><ol>
<li>拷贝 <strong>u-boot</strong> 源码到 ubuntu 系统的 ~&#x2F;u-boot 目录下<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cp</span> -r /mnt/hgfs/u-boot-2021.07.tar.bz2 ~/u-boot</span><br><span class="line">tar -xvf u-boot-2021.07.tar.bz2</span><br><span class="line"><span class="built_in">cd</span> u-boot-2021.07</span><br></pre></td></tr></table></figure></li>
<li><strong>u-boot</strong> 目录<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># api		---&gt; api接口</span></span><br><span class="line"><span class="comment"># arch	---&gt; 架构相关的代码 *</span></span><br><span class="line"><span class="comment"># board	---&gt; 板子相关的代码 *</span></span><br><span class="line"><span class="comment"># cmd		---&gt; 命令相关代码</span></span><br><span class="line"><span class="comment"># configs ---&gt; 板子的默认的配置文件 *</span></span><br><span class="line"><span class="comment"># disk	---&gt; 闪存相关代码</span></span><br><span class="line"><span class="comment"># doc		---&gt; 帮助文档 *</span></span><br><span class="line"><span class="comment"># drivers ---&gt; 驱动相关代码 *</span></span><br><span class="line"><span class="comment"># dts		---&gt; 设备树文件 *</span></span><br><span class="line"><span class="comment"># env		---&gt; 环境配置文件</span></span><br><span class="line"><span class="comment"># examples	---&gt; 案例</span></span><br><span class="line"><span class="comment"># fs		---&gt; 文件系统</span></span><br><span class="line"><span class="comment"># include ---&gt; 头文件</span></span><br><span class="line"><span class="comment"># lib		---&gt; 库</span></span><br><span class="line"><span class="comment"># Makefile ---&gt; 工程配置编译 *</span></span><br><span class="line"><span class="comment"># net		---&gt; 网络相关代码</span></span><br><span class="line"><span class="comment"># post	---&gt; 电源相关代码</span></span><br><span class="line"><span class="comment"># README	---&gt; 帮助文件 *</span></span><br><span class="line"><span class="comment"># scripts	----&gt; 脚本文件</span></span><br><span class="line"><span class="comment"># test	---&gt; 测试代码</span></span><br><span class="line"><span class="comment"># tools	---&gt; 工具代码</span></span><br></pre></td></tr></table></figure></li>
<li>阅读参考文档</li>
</ol>
<h2 id="u-boot-启动流程"><a href="#u-boot-启动流程" class="headerlink" title="u-boot 启动流程"></a>u-boot 启动流程</h2><ul>
<li>第一阶段-汇编</li>
</ul>
<ol>
<li>初始化异常向量表</li>
<li>设置ARM核为SVC模式，关中断</li>
<li>关闭页表，cache，mmu</li>
<li>关看门狗</li>
<li>初始化时钟</li>
<li>初始化内存</li>
<li>初始化串口</li>
<li>初始化栈</li>
<li>清bss段</li>
</ol>
<ul>
<li>第二阶段-C</li>
</ul>
<ol>
<li>各种硬件的初始化（解析设备树，板级初始化，时钟初始化，串口初始化，emmc初始化，网卡初始化）</li>
<li>读取bootdelay参数，如果倒计时为0前按下了任意键进入交互模式，就可以通过命令来操作uboot如果倒计时为0的时候没有安下任意键，系统读取bootcmd来启动内核。</li>
</ol>
<h2 id="配置编译"><a href="#配置编译" class="headerlink" title="配置编译"></a>配置编译</h2><ol>
<li>拷贝 <strong>u-boot</strong> 源码到ubuntu中，解压<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cp</span> /mnt/hgfs/u-boot-2021.07.tar.bz2 ~/</span><br><span class="line">tar -xvf u-boot-2021.07.tar.bz2</span><br><span class="line"><span class="built_in">cd</span> u-boot-2021.07</span><br></pre></td></tr></table></figure></li>
<li>修改 <strong>Makefile</strong><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">vim Makefile</span><br><span class="line"><span class="comment"># 266 ifeq ($(HOSTARCH),$(ARCH))</span></span><br><span class="line"><span class="comment"># 267 CROSS_COMPILE ?= </span></span><br><span class="line"><span class="comment"># 268 endif</span></span><br><span class="line"><span class="comment"># 修改</span></span><br><span class="line"><span class="comment"># 266 ifeq (arm,arm)</span></span><br><span class="line"><span class="comment"># 267 CROSS_COMPILE ?= arm-linux-gnueabihf-</span></span><br><span class="line"><span class="comment"># 268 endif</span></span><br></pre></td></tr></table></figure></li>
<li>生成 <code>.config</code> 文件<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">make stm32mp15_basic_defconfig</span><br></pre></td></tr></table></figure></li>
<li>根据 DK1 板子的设备树文件拷贝生成 FSMP1A 板子的设备树文件<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">ls</span> <span class="built_in">arch</span>/arm/dts/stm32mp15*dk*</span><br><span class="line"><span class="built_in">cp</span> <span class="built_in">arch</span>/arm/dts/stm32mp157a-dk1.dts  <span class="built_in">arch</span>/arm/dts/stm32mp157a-fsmp1a.dts</span><br><span class="line"><span class="built_in">cp</span> <span class="built_in">arch</span>/arm/dts/stm32mp157a-dk1-u-boot.dtsi  <span class="built_in">arch</span>/arm/dts/stm32mp157a-fsmp1a-u-boot.dtsi </span><br><span class="line"><span class="built_in">cp</span> <span class="built_in">arch</span>/arm/dts/stm32mp15xx-dkx.dtsi  <span class="built_in">arch</span>/arm/dts/stm32mp15xx-fsmp1x.dtsi</span><br></pre></td></tr></table></figure></li>
<li>修改 <code>stm32mp157a-fsmp1a.dts</code><figure class="highlight dts"><figcaption><span>&#123;.line-numbers&#125;</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stm32mp15xx-dkx.dtsi&quot;</span>                </span></span><br><span class="line"><span class="title class_">/</span> <span class="punctuation">&#123;</span></span><br><span class="line"><span class="attr">model</span> <span class="operator">=</span> <span class="string">&quot;STMicroelectronics STM32MP157A-DK1 Discovery Board&quot;</span><span class="punctuation">;</span></span><br><span class="line"><span class="attr">compatible</span> <span class="operator">=</span> <span class="string">&quot;st,stm32mp157a-dk1&quot;</span>, <span class="string">&quot;st,stm32mp157&quot;</span><span class="punctuation">;</span></span><br><span class="line"><span class="comment">// 修改为：</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stm32mp15xx-fsmp1x.dtsi&quot;</span></span></span><br><span class="line"><span class="title class_">/</span> <span class="punctuation">&#123;</span>       </span><br><span class="line"><span class="attr">model</span> <span class="operator">=</span> <span class="string">&quot;MING STM32MP157A-FSMP1A Discovery Board&quot;</span><span class="punctuation">;</span></span><br><span class="line"><span class="attr">compatible</span> <span class="operator">=</span> <span class="string">&quot;st,stm32mp157a-fsmp1a&quot;</span>, <span class="string">&quot;st,stm32mp157&quot;</span><span class="punctuation">;</span></span><br></pre></td></tr></table></figure></li>
<li>添加 fsmp1a 设备树编译信息 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">vim <span class="built_in">arch</span>/arm/dts/Makefile</span><br><span class="line"><span class="comment"># 1061 dtb-$(CONFIG_STM32MP15x) += \</span></span><br><span class="line"><span class="comment"># 1062     stm32mp157a-dk1.dtb \</span></span><br><span class="line"><span class="comment"># 添加</span></span><br><span class="line"><span class="comment"># 1063     stm32mp157a-fsmp1a.dtb \  </span></span><br></pre></td></tr></table></figure></li>
<li>编译<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">make -j8 all</span><br></pre></td></tr></table></figure></li>
<li>将编译生成的 <code>u-boot</code> 镜像文件部署到TF卡<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> ~/sdtools</span><br><span class="line"><span class="built_in">cp</span> 路径/u-boot-spl.stm32   路径/sdtools</span><br><span class="line"><span class="built_in">cp</span> 路径/u-boot.img   路径/sdtools</span><br></pre></td></tr></table></figure></li>
<li>使用 <code>.sh</code> 脚本部署 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="comment"># [] : test 命令， 可以用于整数，字符串比较，文件类型判断</span></span><br><span class="line"><span class="comment"># -eq : 判断整数是否相等</span></span><br><span class="line"><span class="comment"># $# : 执行脚本文件时参数的个数</span></span><br><span class="line"><span class="keyword">if</span> [ <span class="variable">$#</span> -eq 1 ]</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line"><span class="comment"># == ： 判断字符串是否相等</span></span><br><span class="line"><span class="comment"># $1 : 执行脚本文件时传递的第一个参数</span></span><br><span class="line"><span class="keyword">if</span> [ <span class="variable">$1</span> == <span class="string">&quot;help&quot;</span> ]</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;usage: ./sdtools.sh /dev/sdb(blockdevice)&quot;</span></span><br><span class="line"><span class="built_in">exit</span> 1</span><br><span class="line"><span class="comment"># -b : 判断$1参数是否为块设备文件</span></span><br><span class="line"><span class="comment"># ! : 取非运算</span></span><br><span class="line"><span class="keyword">elif</span> [ ! -b <span class="variable">$1</span> ]</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;device <span class="variable">$1</span> :It&#x27;s not a block device&quot;</span></span><br><span class="line"><span class="built_in">exit</span> 1</span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"><span class="keyword">else</span> </span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;usage: ./sdtools.sh /dev/sdb(blockdevice)&quot;</span></span><br><span class="line"><span class="built_in">exit</span> 1</span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">read</span> -p <span class="string">&quot;是否需要重新分区y/n? &quot;</span> chose</span><br><span class="line"><span class="keyword">if</span> [ <span class="variable">$chose</span> == <span class="string">&quot;y&quot;</span> ]</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;*****************开始重新分区****************************&quot;</span></span><br><span class="line"><span class="comment"># 取消分区的挂载</span></span><br><span class="line"><span class="keyword">for</span> (( i=<span class="number">1</span>; i &lt;=<span class="number">5</span>; i++)) </span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">sudo umount <span class="variable">$&#123;1&#125;</span><span class="variable">$&#123;i&#125;</span></span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"><span class="comment"># 删除原有的分区</span></span><br><span class="line">sudo parted -s <span class="variable">$1</span>  mklabel msdos</span><br><span class="line"><span class="comment"># 执行重新分区的命令</span></span><br><span class="line">sudo sgdisk --resize-table=128 -a 1 -n 1:34:545 -c 1:fsbl1 -n 2:546:1057 -c 2:fsbl2 -n 3:1058:5153 -c 3:ssbl -n 4:5154:136225 -c 4:bootfs -n 5:136226 -c 5:rootfs -A 4:<span class="built_in">set</span>:2 -p <span class="variable">$1</span> -g</span><br><span class="line"><span class="comment"># sgdisk ---&gt; 重新分区的命令</span></span><br><span class="line"><span class="comment"># --resize-table=128 -a 1   --&gt; 分区对齐</span></span><br><span class="line"><span class="comment"># -n 1:34:545 -c 1:fsbl1 </span></span><br><span class="line"><span class="comment">#   ---&gt; -n(重新分区的参数)  分区编号:起始块号:终止块号 -c(分区名)  分区编号:分区名字</span></span><br><span class="line"><span class="comment"># -n 2:546:1057 -c 2:fsbl2 </span></span><br><span class="line"><span class="comment"># -n 3:1058:5153 -c 3:ssbl </span></span><br><span class="line"><span class="comment"># -n 4:5154:136225 -c 4:bootfs </span></span><br><span class="line"><span class="comment"># -n 5:136226 -c 5:rootfs </span></span><br><span class="line"><span class="comment">#   ---&gt; -n(重新分区的参数)  分区编号:起始块号(剩余空间都属于这个分区) -c(分区名)  分区编号:分区名字</span></span><br><span class="line"><span class="comment"># -A 4:set:2    ---&gt; 设置分区的属性</span></span><br><span class="line"><span class="comment"># -p $1 -g		---&gt; 打印分区的结果信息</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 关于更多sgdisk命令的使用可以man sgdisk或者sgdisk --help查看帮助手册</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;*****************分区完成********************************&quot;</span></span><br><span class="line"><span class="keyword">elif</span> [ <span class="variable">$chose</span> == <span class="string">&quot;n&quot;</span> ]</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;*****************跳过分区********************************&quot;</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;选择错误，请重试...&quot;</span></span><br><span class="line"><span class="built_in">exit</span> 1</span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;选择烧写模式&quot;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;0.basic非安全烧写&quot;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;1.trusted安全烧写&quot;</span></span><br><span class="line"><span class="built_in">read</span> -p <span class="string">&quot;请输入你的选择&gt; &quot;</span> <span class="built_in">which</span></span><br><span class="line"><span class="keyword">if</span> [ <span class="variable">$which</span> -eq 0 ]</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;****************开始basic烧写****************************&quot;</span></span><br><span class="line"><span class="comment"># dd : 拷贝烧写的命令</span></span><br><span class="line"><span class="comment"># if : 指定输入文件</span></span><br><span class="line"><span class="comment"># of : 指定输出文件</span></span><br><span class="line"><span class="comment"># conv=fdatasync：将输入文件中的内容读到缓冲区之后，在写入到输出文件中</span></span><br><span class="line"><span class="comment"># sudo dd if=u-boot-spl.stm32 of=/dev/sdb1 conv=fdatasync</span></span><br><span class="line">sudo <span class="built_in">dd</span> <span class="keyword">if</span>=u-boot-spl.stm32 of=<span class="string">&quot;<span class="variable">$11</span>&quot;</span> conv=fdatasync</span><br><span class="line"></span><br><span class="line"><span class="comment"># sudo dd if=u-boot-spl.stm32 of=/dev/sdb2 conv=fdatasync</span></span><br><span class="line">sudo <span class="built_in">dd</span> <span class="keyword">if</span>=u-boot-spl.stm32 of=<span class="string">&quot;<span class="variable">$12</span>&quot;</span> conv=fdatasync</span><br><span class="line"></span><br><span class="line"><span class="comment"># sudo dd if=u-boot.img  of=/dev/sdb3 conv=fdatasync</span></span><br><span class="line">sudo <span class="built_in">dd</span> <span class="keyword">if</span>=u-boot.img  of=<span class="string">&quot;<span class="variable">$13</span>&quot;</span> conv=fdatasync</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;****************烧写完成*********************************&quot;</span></span><br><span class="line"><span class="keyword">elif</span> [ <span class="variable">$which</span> -eq 1 ]</span><br><span class="line"><span class="keyword">then</span> </span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;****************开始trusted烧写**************************&quot;</span></span><br><span class="line">sudo <span class="built_in">dd</span> <span class="keyword">if</span>=tf-a-stm32mp157a-fsmp1a-trusted.stm32 of=<span class="string">&quot;<span class="variable">$11</span>&quot;</span> conv=fdatasync</span><br><span class="line">sudo <span class="built_in">dd</span> <span class="keyword">if</span>=tf-a-stm32mp157a-fsmp1a-trusted.stm32 of=<span class="string">&quot;<span class="variable">$12</span>&quot;</span> conv=fdatasync</span><br><span class="line">sudo <span class="built_in">dd</span> <span class="keyword">if</span>=u-boot.stm32  of=<span class="string">&quot;<span class="variable">$13</span>&quot;</span> conv=fdatasync</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;****************烧写完成*********************************&quot;</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;选择错误，退出，请重试.......&quot;</span></span><br><span class="line"><span class="built_in">exit</span> 1</span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure></li>
<li>解决错误<br><img src="/../image/U-BOOTerr1.png" alt="u-boot error 1"><br>当前u-boot源码是支持DK1板子的，而FSMP1A板子的设备树文件是基于DK1板子的设备树文件拷贝生成的。猜测导致FSMP1A板子的u-boot启动失败的原因是DK1板子和FSMP1A板子的电源管理单元的电路图设计不同，对比DK1和FSMP1A板子的电源管理单元的电路图。<br>在 <code>stm32mp15xx-fsmp1x.dtsi</code> 中，删除 <code>i2c4</code> <code>cpu0</code> <code>cpu1</code> <code>usbotg_hs 中的 port</code> <code>pmic</code> 设备树节点，并添加固定电源设备树节点信息。<figure class="highlight dts"><table><tr><td class="code"><pre><span class="line">   <span class="comment">// delete</span></span><br><span class="line">   <span class="variable">&amp;i2c4</span> <span class="punctuation">&#123;</span></span><br><span class="line">       <span class="attr">pinctrl-names</span> <span class="operator">=</span> <span class="string">&quot;default&quot;</span>, <span class="string">&quot;sleep&quot;</span><span class="punctuation">;</span></span><br><span class="line">       pinctrl<span class="number">-0</span> = <span class="params">&lt;<span class="variable">&amp;i2c4_pins_a</span>&gt;</span><span class="punctuation">;</span></span><br><span class="line">   <span class="comment">/* ...... */</span>   </span><br><span class="line">       <span class="punctuation">&#125;;</span></span><br><span class="line">   <span class="punctuation">&#125;;</span></span><br><span class="line"></span><br><span class="line">   <span class="variable">&amp;cpu0</span><span class="punctuation">&#123;</span></span><br><span class="line">       <span class="attr">cpu-supply</span> <span class="operator">=</span> <span class="params">&lt;<span class="variable">&amp;vddcore</span>&gt;</span><span class="punctuation">;</span></span><br><span class="line">   <span class="punctuation">&#125;;</span></span><br><span class="line">                                                                                           </span><br><span class="line">   <span class="variable">&amp;cpu1</span><span class="punctuation">&#123;</span></span><br><span class="line">       <span class="attr">cpu-supply</span> <span class="operator">=</span> <span class="params">&lt;<span class="variable">&amp;vddcore</span>&gt;</span><span class="punctuation">;</span></span><br><span class="line">   <span class="punctuation">&#125;;</span></span><br><span class="line"></span><br><span class="line">   <span class="title class_">port</span> <span class="punctuation">&#123;</span></span><br><span class="line"><span class="symbol">       usbotg_hs_ep:</span> <span class="title class_">endpoint</span> <span class="punctuation">&#123;</span></span><br><span class="line">           <span class="attr">remote-endpoint</span> <span class="operator">=</span> <span class="params">&lt;<span class="variable">&amp;con_usbotg_hs_ep</span>&gt;</span><span class="punctuation">;</span></span><br><span class="line">       <span class="punctuation">&#125;;</span></span><br><span class="line">   <span class="punctuation">&#125;;</span></span><br><span class="line"></span><br><span class="line">   <span class="variable">&amp;pmic</span> <span class="punctuation">&#123;</span></span><br><span class="line">       <span class="attr">u-boot,dm-pre-reloc</span><span class="punctuation">;</span></span><br><span class="line">   <span class="punctuation">&#125;;</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">// add</span></span><br><span class="line"><span class="symbol">   vin:</span> <span class="title class_">vin</span> <span class="punctuation">&#123;</span></span><br><span class="line">       <span class="attr">compatible</span> <span class="operator">=</span> <span class="string">&quot;regulator-fixed&quot;</span><span class="punctuation">;</span></span><br><span class="line">       <span class="attr">regulator-name</span> <span class="operator">=</span> <span class="string">&quot;vin&quot;</span><span class="punctuation">;</span></span><br><span class="line">       <span class="attr">regulator-min-microvolt</span> <span class="operator">=</span> <span class="params">&lt;<span class="number">5000000</span>&gt;</span><span class="punctuation">;</span></span><br><span class="line">       <span class="attr">regulator-max-microvolt</span> <span class="operator">=</span> <span class="params">&lt;<span class="number">5000000</span>&gt;</span><span class="punctuation">;</span></span><br><span class="line">       <span class="attr">regulator-always-on</span><span class="punctuation">;</span></span><br><span class="line">   <span class="punctuation">&#125;;</span></span><br><span class="line">在vin节点的下边添加以下内容</span><br><span class="line"><span class="symbol">   v3v3:</span> <span class="title class_">regulator-3p3v</span> <span class="punctuation">&#123;</span></span><br><span class="line">       <span class="attr">compatible</span> <span class="operator">=</span> <span class="string">&quot;regulator-fixed&quot;</span><span class="punctuation">;</span></span><br><span class="line">       <span class="attr">regulator-name</span> <span class="operator">=</span> <span class="string">&quot;v3v3&quot;</span><span class="punctuation">;</span></span><br><span class="line">       <span class="attr">regulator-min-microvolt</span> <span class="operator">=</span> <span class="params">&lt;<span class="number">3300000</span>&gt;</span><span class="punctuation">;</span></span><br><span class="line">       <span class="attr">regulator-max-microvolt</span> <span class="operator">=</span> <span class="params">&lt;<span class="number">3300000</span>&gt;</span><span class="punctuation">;</span></span><br><span class="line">       <span class="attr">regulator-always-on</span><span class="punctuation">;</span></span><br><span class="line">       <span class="attr">regulator-boot-on</span><span class="punctuation">;</span></span><br><span class="line">   <span class="punctuation">&#125;;</span></span><br><span class="line"><span class="symbol">   v1v8_audio:</span> <span class="title class_">regulator-v1v8-audio</span> <span class="punctuation">&#123;</span></span><br><span class="line">       <span class="attr">compatible</span> <span class="operator">=</span> <span class="string">&quot;regulator-fixed&quot;</span><span class="punctuation">;</span></span><br><span class="line">       <span class="attr">regulator-name</span> <span class="operator">=</span> <span class="string">&quot;v1v8_audio&quot;</span><span class="punctuation">;</span></span><br><span class="line">       <span class="attr">regulator-min-microvolt</span> <span class="operator">=</span> <span class="params">&lt;<span class="number">1800000</span>&gt;</span><span class="punctuation">;</span></span><br><span class="line">       <span class="attr">regulator-max-microvolt</span> <span class="operator">=</span> <span class="params">&lt;<span class="number">1800000</span>&gt;</span><span class="punctuation">;</span></span><br><span class="line">       <span class="attr">regulator-always-on</span><span class="punctuation">;</span></span><br><span class="line">       <span class="attr">regulator-boot-on</span><span class="punctuation">;</span></span><br><span class="line">   <span class="punctuation">&#125;;</span></span><br><span class="line"><span class="symbol">   v3v3_hdmi:</span> <span class="title class_">regulator-v3v3-hdmi</span> <span class="punctuation">&#123;</span></span><br><span class="line">       <span class="attr">compatible</span> <span class="operator">=</span> <span class="string">&quot;regulator-fixed&quot;</span><span class="punctuation">;</span></span><br><span class="line">       <span class="attr">regulator-name</span> <span class="operator">=</span> <span class="string">&quot;v3v3_hdmi&quot;</span><span class="punctuation">;</span></span><br><span class="line">       <span class="attr">regulator-min-microvolt</span> <span class="operator">=</span> <span class="params">&lt;<span class="number">3300000</span>&gt;</span><span class="punctuation">;</span></span><br><span class="line">       <span class="attr">regulator-max-microvolt</span> <span class="operator">=</span> <span class="params">&lt;<span class="number">3300000</span>&gt;</span><span class="punctuation">;</span></span><br><span class="line">       <span class="attr">regulator-always-on</span><span class="punctuation">;</span></span><br><span class="line">       <span class="attr">regulator-boot-on</span><span class="punctuation">;</span></span><br><span class="line">   <span class="punctuation">&#125;;</span></span><br><span class="line"><span class="symbol">   v1v2_hdmi:</span> <span class="title class_">regulator-v1v2-hdmi</span> <span class="punctuation">&#123;</span></span><br><span class="line">       <span class="attr">compatible</span> <span class="operator">=</span> <span class="string">&quot;regulator-fixed&quot;</span><span class="punctuation">;</span></span><br><span class="line">       <span class="attr">regulator-name</span> <span class="operator">=</span> <span class="string">&quot;v1v2_hdmi&quot;</span><span class="punctuation">;</span></span><br><span class="line">       <span class="attr">regulator-min-microvolt</span> <span class="operator">=</span> <span class="params">&lt;<span class="number">1200000</span>&gt;</span><span class="punctuation">;</span></span><br><span class="line">       <span class="attr">regulator-max-microvolt</span> <span class="operator">=</span> <span class="params">&lt;<span class="number">1200000</span>&gt;</span><span class="punctuation">;</span></span><br><span class="line">       <span class="attr">regulator-always-on</span><span class="punctuation">;</span></span><br><span class="line">       <span class="attr">regulator-boot-on</span><span class="punctuation">;</span></span><br><span class="line">   <span class="punctuation">&#125;;</span></span><br><span class="line"><span class="symbol">   vdd:</span> <span class="title class_">regulator-vdd</span> <span class="punctuation">&#123;</span></span><br><span class="line">       <span class="attr">compatible</span> <span class="operator">=</span> <span class="string">&quot;regulator-fixed&quot;</span><span class="punctuation">;</span></span><br><span class="line">       <span class="attr">regulator-name</span> <span class="operator">=</span> <span class="string">&quot;vdd&quot;</span><span class="punctuation">;</span></span><br><span class="line">       <span class="attr">regulator-min-microvolt</span> <span class="operator">=</span> <span class="params">&lt;<span class="number">3300000</span>&gt;</span><span class="punctuation">;</span></span><br><span class="line">       <span class="attr">regulator-max-microvolt</span> <span class="operator">=</span> <span class="params">&lt;<span class="number">3300000</span>&gt;</span><span class="punctuation">;</span></span><br><span class="line">       <span class="attr">regulator-always-on</span><span class="punctuation">;</span></span><br><span class="line">       <span class="attr">regulator-boot-on</span><span class="punctuation">;</span></span><br><span class="line">   <span class="punctuation">&#125;;</span></span><br><span class="line"><span class="symbol">   vdd_usb:</span> <span class="title class_">regulator-vdd-usb</span> <span class="punctuation">&#123;</span></span><br><span class="line">       <span class="attr">compatible</span> <span class="operator">=</span> <span class="string">&quot;regulator-fixed&quot;</span><span class="punctuation">;</span></span><br><span class="line">       <span class="attr">regulator-name</span> <span class="operator">=</span> <span class="string">&quot;vdd_usb&quot;</span><span class="punctuation">;</span></span><br><span class="line">       <span class="attr">regulator-min-microvolt</span> <span class="operator">=</span> <span class="params">&lt;<span class="number">3300000</span>&gt;</span><span class="punctuation">;</span></span><br><span class="line">       <span class="attr">regulator-max-microvolt</span> <span class="operator">=</span> <span class="params">&lt;<span class="number">3300000</span>&gt;</span><span class="punctuation">;</span></span><br><span class="line">       <span class="attr">regulator-always-on</span><span class="punctuation">;</span></span><br><span class="line">       <span class="attr">regulator-boot-on</span><span class="punctuation">;</span></span><br><span class="line">   <span class="punctuation">&#125;;</span></span><br></pre></td></tr></table></figure>
移出 PMIC 的驱动代码<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">make menuconfig</span><br><span class="line"><span class="comment"># Device Drivers  ---&gt; power  ---&gt;  [] Enable support for STMicroelectronics STPMIC1PMIC</span></span><br></pre></td></tr></table></figure>
重新编译   </li>
<li>解决错误<br><img src="/../image/U-BOOTerr2.png" alt="u-boot error 2"><br>当前u-boot源码是支持DK1板子的，而FSMP1A板子的设备树文件是基于DK1板子的设备树文件拷贝生成的。猜测导致FSMP1A板子的u-boot启动失败的原因是DK1板子和FSMP1A板子的DARM电路图的设计不同，对比DK1和FSMP1A板子的DRAM的电路图。<br>修改使用的设备树<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">make menuconfig</span><br><span class="line"><span class="comment"># Device Tree Control ---&gt;  (stm32mp157a-fsmp1a) Default Device Tree for DT control</span></span><br></pre></td></tr></table></figure>
重新编译</li>
<li>解决错误<br><img src="/../image/U-BOOTerr3.png" alt="u-boot error 3"><br>当前FSMP1A板子的启动方式为TF卡启动，因此mmc初始化失败的错误跟eMMC设备的驱动无关。因此造成mmc初始化失败的原因应该是TF卡的驱动的问题。分析DK1板子和FSMP1A板子的TF卡的电路图。<br>修改 <code>stm32mp15xx-fsmp1x.dtsi</code><figure class="highlight dts"><table><tr><td class="code"><pre><span class="line"><span class="variable">&amp;sdmmc1</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">pinctrl-names</span> <span class="operator">=</span> <span class="string">&quot;default&quot;</span>, <span class="string">&quot;opendrain&quot;</span>, <span class="string">&quot;sleep&quot;</span><span class="punctuation">;</span></span><br><span class="line">    pinctrl<span class="number">-0</span> = <span class="params">&lt;<span class="variable">&amp;sdmmc1_b4_pins_a</span>&gt;</span><span class="punctuation">;</span></span><br><span class="line">    pinctrl<span class="number">-1</span> = <span class="params">&lt;<span class="variable">&amp;sdmmc1_b4_od_pins_a</span>&gt;</span><span class="punctuation">;</span></span><br><span class="line">    pinctrl<span class="number">-2</span> = <span class="params">&lt;<span class="variable">&amp;sdmmc1_b4_sleep_pins_a</span>&gt;</span><span class="punctuation">;</span></span><br><span class="line">    <span class="attr">cd-gpios</span> <span class="operator">=</span> <span class="params">&lt;<span class="variable">&amp;gpioh</span> <span class="number">3</span> (GPIO_ACTIVE_LOW | GPIO_PULL_UP)&gt;</span><span class="punctuation">;</span></span><br><span class="line">    <span class="attr">disable-wp</span><span class="punctuation">;</span></span><br><span class="line">    <span class="attr">st,neg-edge</span><span class="punctuation">;</span></span><br><span class="line">    <span class="attr">bus-width</span> <span class="operator">=</span> <span class="params">&lt;<span class="number">4</span>&gt;</span><span class="punctuation">;</span></span><br><span class="line">    <span class="attr">vmmc-supply</span> <span class="operator">=</span> <span class="params">&lt;<span class="variable">&amp;v3v3</span>&gt;</span><span class="punctuation">;</span></span><br><span class="line">    <span class="attr">status</span> <span class="operator">=</span> <span class="string">&quot;okay&quot;</span><span class="punctuation">;</span></span><br><span class="line"><span class="punctuation">&#125;;</span></span><br></pre></td></tr></table></figure>
重新编译</li>
<li>解决ADC错误 <code>can&#39;t enable vdd-supply! single shot failed for adc@0[18]</code><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">make menuconfig</span><br><span class="line"><span class="comment"># Command line interface  ---&gt; Device access commands  ---&gt; [ ] adc - Access Analog to Digital Converters info and data</span></span><br><span class="line"><span class="comment"># Device Drivers  ---&gt; [ ] Enable ADC drivers using Driver Model</span></span><br></pre></td></tr></table></figure>
重新编译</li>
<li>修改命令提示符<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">make menuconfig</span><br><span class="line"><span class="comment"># Command line interface  ---&gt; (FSMP1A&gt; ) Shell prompt</span></span><br></pre></td></tr></table></figure>
重新编译</li>
</ol>
<h2 id="移植eMMC驱动"><a href="#移植eMMC驱动" class="headerlink" title="移植eMMC驱动"></a>移植eMMC驱动</h2><p>分析eMMC的电路图<br><code>arch/arm/dts/stm32mp15xx-fsmp1x.dtsi</code> 增加 <code>SDMMC2</code> 的信息在原有 sdmmc1 节点下增加 sdmmc<br><code>arch/arm/dts/stm32mp157a-fsmp1a-u-boot.dtsi</code> 增加 <code>mmc 映射</code></p>
<pre><code><figure class="highlight dts"><table><tr><td class="code"><pre><span class="line"><span class="variable">&amp;sdmmc2</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">pinctrl-names</span> <span class="operator">=</span> <span class="string">&quot;default&quot;</span>, <span class="string">&quot;opendrain&quot;</span>, <span class="string">&quot;sleep&quot;</span><span class="punctuation">;</span></span><br><span class="line">    pinctrl<span class="number">-0</span> = <span class="params">&lt;<span class="variable">&amp;sdmmc2_b4_pins_a</span> <span class="variable">&amp;sdmmc2_d47_pins_a</span>&gt;</span><span class="punctuation">;</span></span><br><span class="line">    pinctrl<span class="number">-1</span> = <span class="params">&lt;<span class="variable">&amp;sdmmc2_b4_od_pins_a</span> <span class="variable">&amp;sdmmc2_d47_pins_a</span>&gt;</span><span class="punctuation">;</span></span><br><span class="line">    pinctrl<span class="number">-2</span> = <span class="params">&lt;<span class="variable">&amp;sdmmc2_b4_sleep_pins_a</span> <span class="variable">&amp;sdmmc2_d47_sleep_pins_a</span>&gt;</span><span class="punctuation">;</span></span><br><span class="line">    <span class="attr">non-removable</span><span class="punctuation">;</span></span><br><span class="line">    <span class="attr">no-sd</span><span class="punctuation">;</span></span><br><span class="line">    <span class="attr">no-sdio</span><span class="punctuation">;</span></span><br><span class="line">    <span class="attr">st,neg-edge</span><span class="punctuation">;</span></span><br><span class="line">    <span class="attr">bus-width</span> <span class="operator">=</span> <span class="params">&lt;<span class="number">8</span>&gt;</span><span class="punctuation">;</span></span><br><span class="line">    <span class="attr">vmmc-supply</span> <span class="operator">=</span> <span class="params">&lt;<span class="variable">&amp;v3v3</span>&gt;</span><span class="punctuation">;</span></span><br><span class="line">    <span class="attr">vqmmc-supply</span> <span class="operator">=</span> <span class="params">&lt;<span class="variable">&amp;vdd</span>&gt;</span><span class="punctuation">;</span></span><br><span class="line">    mmc-ddr<span class="number">-3</span>_3v<span class="punctuation">;</span></span><br><span class="line">    <span class="attr">status</span> <span class="operator">=</span> <span class="string">&quot;okay&quot;</span><span class="punctuation">;</span></span><br><span class="line"><span class="punctuation">&#125;;</span>    </span><br><span class="line"></span><br><span class="line"><span class="title class_">aliases</span> <span class="punctuation">&#123;</span></span><br><span class="line">    i2c3 = <span class="variable">&amp;i2c4</span><span class="punctuation">;</span></span><br><span class="line">    mmc0 = <span class="variable">&amp;sdmmc1</span><span class="punctuation">;</span></span><br><span class="line">    mmc1 = <span class="variable">&amp;sdmmc2</span><span class="punctuation">;</span></span><br><span class="line">    usb0 = <span class="variable">&amp;usbotg_hs</span><span class="punctuation">;</span></span><br><span class="line"><span class="punctuation">&#125;;</span></span><br><span class="line"><span class="comment">// 在 sdmmc1 节点后 添加sdmmc2 的内容：</span></span><br><span class="line"><span class="variable">&amp;sdmmc1</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">u-boot,dm-spl</span><span class="punctuation">;</span></span><br><span class="line"><span class="punctuation">&#125;;</span></span><br><span class="line"><span class="comment">// 以下内容为添加的新的内容：</span></span><br><span class="line"><span class="variable">&amp;sdmmc2</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">u-boot,dm-spl</span><span class="punctuation">;</span></span><br><span class="line"><span class="punctuation">&#125;;</span></span><br></pre></td></tr></table></figure>
</code></pre>
<h1 id="kernel"><a href="#kernel" class="headerlink" title="kernel"></a>kernel</h1><h2 id="分析-kernel-源码"><a href="#分析-kernel-源码" class="headerlink" title="分析 kernel 源码"></a>分析 kernel 源码</h2><ol>
<li>拷贝 kernel 源码 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cp</span> /mnt/hgfs/en.SOURCES-stm32mp1-openstlinux-5.10-dunfell-mp1-21-11-17_tar_v3.1.0.x ~/</span><br><span class="line">tar -xvf en.SOURCES-stm32mp1-openstlinux-5.10-dunfell-mp1-21-11-17_tar_v3.1.0.x</span><br></pre></td></tr></table></figure></li>
<li>目录结构<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 0001-ARM-5.10.61-stm32mp1-r2-MACHINE.patch  &lt;===内核的补丁文件</span></span><br><span class="line"><span class="comment"># 0002-ARM-5.10.61-stm32mp1-r2-CLOCK.patch</span></span><br><span class="line"><span class="comment"># 0003-ARM-5.10.61-stm32mp1-r2-CPUFREQ.patch</span></span><br><span class="line"><span class="comment"># 0004-ARM-5.10.61-stm32mp1-r2-CRYPTO.patch</span></span><br><span class="line"><span class="comment"># 0005-ARM-5.10.61-stm32mp1-r2-DMA.patch</span></span><br><span class="line"><span class="comment"># 0006-ARM-5.10.61-stm32mp1-r2-DRM.patch</span></span><br><span class="line"><span class="comment"># 0007-ARM-5.10.61-stm32mp1-r2-HWSPINLOCK.patch</span></span><br><span class="line"><span class="comment"># 0008-ARM-5.10.61-stm32mp1-r2-I2C-IIO-IRQCHIP.patch</span></span><br><span class="line"><span class="comment"># 0009-ARM-5.10.61-stm32mp1-r2-MAILBOX-REMOTEPROC-RPMSG.patch</span></span><br><span class="line"><span class="comment"># 0010-ARM-5.10.61-stm32mp1-r2-MEDIA-SOC-THERMAL.patch</span></span><br><span class="line"><span class="comment"># 0011-ARM-5.10.61-stm32mp1-r2-MFD.patch</span></span><br><span class="line"><span class="comment"># 0012-ARM-5.10.61-stm32mp1-r2-MMC.patch</span></span><br><span class="line"><span class="comment"># 0013-ARM-5.10.61-stm32mp1-r2-NET-TTY.patch</span></span><br><span class="line"><span class="comment"># 0014-ARM-5.10.61-stm32mp1-r2-PERF.patch</span></span><br><span class="line"><span class="comment"># 0015-ARM-5.10.61-stm32mp1-r2-PHY-USB.patch</span></span><br><span class="line"><span class="comment"># 0016-ARM-5.10.61-stm32mp1-r2-PINCTRL-REGULATOR-SPI.patch</span></span><br><span class="line"><span class="comment"># 0017-ARM-5.10.61-stm32mp1-r2-RESET-RTC-WATCHDOG.patch</span></span><br><span class="line"><span class="comment"># 0018-ARM-5.10.61-stm32mp1-r2-SCMI.patch</span></span><br><span class="line"><span class="comment"># 0019-ARM-5.10.61-stm32mp1-r2-SOUND.patch</span></span><br><span class="line"><span class="comment"># 0020-ARM-5.10.61-stm32mp1-r2-MISC.patch</span></span><br><span class="line"><span class="comment"># 0021-ARM-5.10.61-stm32mp1-r2-CPUIDLE-POWER.patch</span></span><br><span class="line"><span class="comment"># 0022-ARM-5.10.61-stm32mp1-r2-DEVICETREE.patch</span></span><br><span class="line"><span class="comment"># 0023-ARM-5.10.61-stm32mp1-r2-CONFIG.patch</span></span><br><span class="line"><span class="comment"># fragment-03-systemd.config       &lt;====内核配置的补丁文件</span></span><br><span class="line"><span class="comment"># fragment-04-modules.config</span></span><br><span class="line"><span class="comment"># fragment-05-signature.config</span></span><br><span class="line"><span class="comment"># linux-5.10.61.tar.xz            &lt;======内核源代码</span></span><br><span class="line"><span class="comment"># README.HOW_TO.txt               &lt;======帮助文档</span></span><br><span class="line"><span class="comment"># series                           &lt;======补丁文件的层级</span></span><br></pre></td></tr></table></figure></li>
<li>解压内核<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">tar -xvf linux-5.10.61.tar.xz</span><br><span class="line"><span class="built_in">cd</span> linux-5.10.61</span><br></pre></td></tr></table></figure></li>
<li>目录结构<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># arch：</span></span><br><span class="line"><span class="comment">#  arm ：arm架构相关信息都在这个目录下   </span></span><br><span class="line"><span class="comment">#  linux-5.10.61/arch/arm/boot/uImage : 编译之后生成的内核镜像文件</span></span><br><span class="line"><span class="comment">#  linux-5.10.61/arch/arm/boot/dts : 设备树的源文件及二进制文件(stm32mp157a-fsmp1a.dtb)</span></span><br><span class="line"><span class="comment">#  arm/configs/xxx_defconfig : 内核中的默认配置文件    </span></span><br><span class="line"><span class="comment"># block : 块设备相关代码</span></span><br><span class="line"><span class="comment"># CREDITS : 内核的贡献者</span></span><br><span class="line"><span class="comment"># MAINTAINERS : 当前内核版本的维护者</span></span><br><span class="line"><span class="comment"># crypto : 加密解密算法</span></span><br><span class="line"><span class="comment"># Documentation : 内核帮助文档</span></span><br><span class="line"><span class="comment"># drivers ：这个目录下存放的是驱动</span></span><br><span class="line"><span class="comment"># fs      ：文件系统的相关代码</span></span><br><span class="line"><span class="comment"># include ：内核目录下的头文件</span></span><br><span class="line"><span class="comment"># init    ：系统初始化的代码</span></span><br><span class="line"><span class="comment"># ipc     ：进程间通信相关代码</span></span><br><span class="line"><span class="comment"># scripts ：内核编译相关的脚本文件，及Makefile库文件 </span></span><br><span class="line"><span class="comment"># kernel  ： 操作系统相关代码</span></span><br><span class="line"><span class="comment"># lib     ：内核的库文件</span></span><br><span class="line"><span class="comment"># mm      ：内存管理相关代码</span></span><br><span class="line"><span class="comment"># net     ：网络协议栈相关代码</span></span><br><span class="line"><span class="comment"># security：内核安全技术相关代码    </span></span><br></pre></td></tr></table></figure></li>
<li>打补丁<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> p <span class="keyword">in</span> `<span class="built_in">ls</span> -1 ../*.patch`; <span class="keyword">do</span> patch -p1 &lt; <span class="variable">$p</span>; <span class="keyword">done</span></span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="kernel-启动流程"><a href="#kernel-启动流程" class="headerlink" title="kernel 启动流程"></a>kernel 启动流程</h2><p><img src="/../image/KERstart.png" alt="kernel start"></p>
<ol>
<li>完成内核自解压</li>
<li>判断CPUID是否正确，如果不正确就退出</li>
<li>接收uboot给内核传递的bootargs的参数</li>
<li>将物理内存映射得到虚拟内存，通过页表将物理内存和虚拟内存建立联系</li>
<li>跳转到c代码阶段（start_kernel）各种硬件的初始化（中断，终端，时间，调度，定时器）</li>
<li>在rest_init创建init和kthreadd线程，在init线程中执行&#x2F;sbin&#x2F;init</li>
<li>uboot将init&#x3D;&#x2F;linuxrc（&#x2F;bin&#x2F;busybox）传递给内核，此时根文件系统就挂载上去了</li>
</ol>
<h2 id="编译配置"><a href="#编译配置" class="headerlink" title="编译配置"></a>编译配置</h2><ol>
<li>生成自己的 <code>.config</code><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">make ARCH=arm multi_v7_defconfig fragment*.config</span><br></pre></td></tr></table></figure></li>
<li>修改 Makefile<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 370   ARCH  ?= $(SUBARCH)</span></span><br><span class="line"><span class="comment"># 371   ARCH ?= arm</span></span><br><span class="line"><span class="comment"># 372   CROSS_COMPILE ?= arm-linux-gnueabihf-</span></span><br></pre></td></tr></table></figure></li>
<li>设备树参考上文 <code>u-boot</code></li>
<li>错误 <code>can&#39;t create /proc/sys/kernel/hotplug: nonexistent directory</code><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">make menuconfig</span><br><span class="line">Device Drivers  ---&gt; Generic Driver Options  ---&gt; [*] Support <span class="keyword">for</span> uevent helper - (/sbin/hotplug) path to uevent helper (NEW)</span><br></pre></td></tr></table></figure></li>
</ol>
<h1 id="rootfs"><a href="#rootfs" class="headerlink" title="rootfs"></a>rootfs</h1>]]></content>
  </entry>
  <entry>
    <title>线程以及线程间的竞态问题解决</title>
    <url>/2022/10/10/%E7%BA%BF%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1/</url>
    <content><![CDATA[<p>本文包含线程的介绍使用，以及线程间的通信方式，解决多线程中的竞态问题。阅读建议对进程有所了解。</p>
<span id="more"></span>

<h1 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h1><h2 id="线程的概念"><a href="#线程的概念" class="headerlink" title="线程的概念"></a>线程的概念</h2><p><strong>线程（LWP）</strong>：线程是轻量级的进程，进程是分配资源的最小单位（0-3G）,线程是调度的最小单位。线程本身不占用资源它是共享进程的资源。线程没有进程安全，因为如果一个线程导致进程结束，其他所有的线程都不能执行。多线程的并发性比多进程的高，因为线程间切换比进程间切换时间短。线程间资源共享，所以线程间通信要比进程间通信更为容易。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ps -ajx <span class="comment">#看进程附加态（l，代表多线程）</span></span><br><span class="line">ps -eLf <span class="comment">#多线程</span></span><br><span class="line">htop    <span class="comment">#多线程</span></span><br></pre></td></tr></table></figure>

<h2 id="线程的创建及特点"><a href="#线程的创建及特点" class="headerlink" title="线程的创建及特点"></a>线程的创建及特点</h2><h3 id="多线程的创建"><a href="#多线程的创建" class="headerlink" title="多线程的创建"></a>多线程的创建</h3><p>多线程创建的接口是第三方库提供的 <strong>libpthread.so</strong>，所以如果要使用线程相关的函数，在编译的时候就必须链接这个库，线程相关的man手册需要使用apt-get来安装。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt-get install manpages-*</span><br><span class="line">gcc xxx.c -lpthread</span><br></pre></td></tr></table></figure>
<h3 id="线程创建的接口"><a href="#线程创建的接口" class="headerlink" title="线程创建的接口"></a>线程创建的接口</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_create</span><span class="params">(<span class="type">pthread_t</span> *thread, <span class="type">const</span> <span class="type">pthread_attr_t</span> *attr,</span></span><br><span class="line"><span class="params">                  <span class="type">void</span> *(*start_routine) (<span class="type">void</span> *), <span class="type">void</span> *arg)</span>;</span><br><span class="line"><span class="comment">// 功能：创建线程</span></span><br><span class="line"><span class="comment">// 参数：</span></span><br><span class="line"><span class="comment">//     @thread:线程号指针</span></span><br><span class="line"><span class="comment">// 	   @attr:线程属性（一般填写为NULL）</span></span><br><span class="line"><span class="comment">//     @start_routine：线程体（指向线程处理函数）</span></span><br><span class="line"><span class="comment">//     @arg: 向线程体传递的参数（如果没有填写为NULL） </span></span><br><span class="line"><span class="comment">// 返回值：成功返回0，失败返回错误码  </span></span><br><span class="line"><span class="comment">// Compile and link with -pthread.</span></span><br></pre></td></tr></table></figure>
<h3 id="线程创建的实例1-不传参"><a href="#线程创建的实例1-不传参" class="headerlink" title="线程创建的实例1(不传参)"></a>线程创建的实例1(不传参)</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;head.h&gt;</span></span></span><br><span class="line"><span class="type">void</span>* <span class="title function_">task1</span><span class="params">(<span class="type">void</span>* arg)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;我是子线程...\n&quot;</span>);</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span>* argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">pthread_t</span> tid;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((errno = pthread_create(&amp;tid, <span class="literal">NULL</span>, task1, <span class="literal">NULL</span>)) != <span class="number">0</span>)</span><br><span class="line">        PRINT_ERR(<span class="string">&quot;pthread_create error&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;我是主线程...\n&quot;</span>);</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="线程创建的实例2-传参"><a href="#线程创建的实例2-传参" class="headerlink" title="线程创建的实例2(传参)"></a>线程创建的实例2(传参)</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;head.h&gt;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="type">char</span> name[<span class="number">20</span>];</span><br><span class="line">    <span class="type">char</span> sex;</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">&#125;<span class="type">stu_t</span>;</span><br><span class="line"><span class="type">void</span>* <span class="title function_">task1</span><span class="params">(<span class="type">void</span>* arg)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">stu_t</span> *stu = (<span class="type">stu_t</span> *)arg;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;name=%s,sex=%c,age=%d\n&quot;</span>,stu-&gt;name,stu-&gt;sex,stu-&gt;age);</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;我是子线程...\n&quot;</span>);</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span>* argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">pthread_t</span> tid;</span><br><span class="line">    <span class="type">stu_t</span> stu = &#123;</span><br><span class="line">        .name = <span class="string">&quot;zhangsan&quot;</span>,</span><br><span class="line">        .sex = <span class="string">&#x27;m&#x27;</span>,</span><br><span class="line">        .age = <span class="number">20</span>,</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((errno = pthread_create(&amp;tid, <span class="literal">NULL</span>, task1, (<span class="type">void</span> *)&amp;stu)) != <span class="number">0</span>)</span><br><span class="line">        PRINT_ERR(<span class="string">&quot;pthread_create error&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;我是主线程...\n&quot;</span>);</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="线程创建的实例3-全局变量"><a href="#线程创建的实例3-全局变量" class="headerlink" title="线程创建的实例3(全局变量)"></a>线程创建的实例3(全局变量)</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;head.h&gt;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="type">char</span> name[<span class="number">20</span>];</span><br><span class="line">    <span class="type">char</span> sex;</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">&#125; <span class="type">stu_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">stu_t</span> stu = &#123;</span><br><span class="line">    .name = <span class="string">&quot;zhangsan&quot;</span>,</span><br><span class="line">    .sex = <span class="string">&#x27;m&#x27;</span>,</span><br><span class="line">    .age = <span class="number">20</span>,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">void</span>* <span class="title function_">task1</span><span class="params">(<span class="type">void</span>* arg)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;child:name=%s,sex=%c,age=%d\n&quot;</span>, stu.name, stu.sex, stu.age);</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;我是子线程...\n&quot;</span>);</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span>* argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">pthread_t</span> tid;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;parent:name=%s,sex=%c,age=%d\n&quot;</span>, stu.name, stu.sex, stu.age);</span><br><span class="line">    <span class="keyword">if</span> ((errno = pthread_create(&amp;tid, <span class="literal">NULL</span>, task1,<span class="literal">NULL</span>))!=<span class="number">0</span>)</span><br><span class="line">        PRINT_ERR(<span class="string">&quot;pthread_create error&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;我是主线程...\n&quot;</span>);</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="线程创建的实例4-关于资源回收"><a href="#线程创建的实例4-关于资源回收" class="headerlink" title="线程创建的实例4(关于资源回收)"></a>线程创建的实例4(关于资源回收)</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;head.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span>* <span class="title function_">task1</span><span class="params">(<span class="type">void</span>* arg)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;我是子线程...\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span>* argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">pthread_t</span> tid;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((errno = pthread_create(&amp;tid, <span class="literal">NULL</span>, task1, <span class="literal">NULL</span>)) != <span class="number">0</span>)</span><br><span class="line">        PRINT_ERR(<span class="string">&quot;pthread_create error&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;我是主线程...\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//如果不写这个sleep(1),有可能主线程执行结束，子线程还没来及执行</span></span><br><span class="line">    <span class="comment">//进程就退出了，子线程将不能执行</span></span><br><span class="line">    sleep(<span class="number">1</span>); </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="多线程执行顺序"><a href="#多线程执行顺序" class="headerlink" title="多线程执行顺序"></a>多线程执行顺序</h3><p>多线程执行没有先后顺序，时间片轮询，上下文切换</p>
<h3 id="多线程内存空间问题"><a href="#多线程内存空间问题" class="headerlink" title="多线程内存空间问题"></a>多线程内存空间问题</h3><p>多线程共享进程的内存空间，全局变量多线程都可以访问，也都可以修改。</p>
<h2 id="线程相关的函数"><a href="#线程相关的函数" class="headerlink" title="线程相关的函数"></a>线程相关的函数</h2><h3 id="pthread-self-函数"><a href="#pthread-self-函数" class="headerlink" title="pthread_self 函数"></a><code>pthread_self</code> 函数</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="type">pthread_t</span> <span class="title function_">pthread_self</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="comment">// 功能：获取当前线程的线程号</span></span><br><span class="line"><span class="comment">// 参数：</span></span><br><span class="line"><span class="comment">//     @无</span></span><br><span class="line"><span class="comment">// 返回值：总是会成功，返回线程号</span></span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;head.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span>* <span class="title function_">task1</span><span class="params">(<span class="type">void</span>* arg)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;我是子线程...\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;子:tid = %ld\n&quot;</span>,pthread_self());</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span>* argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">pthread_t</span> tid;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((errno = pthread_create(&amp;tid, <span class="literal">NULL</span>, task1, <span class="literal">NULL</span>)) != <span class="number">0</span>)</span><br><span class="line">        PRINT_ERR(<span class="string">&quot;pthread_create error&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;主:tid = %ld,子:tid = %ld\n&quot;</span>,pthread_self(),tid);</span><br><span class="line"></span><br><span class="line">    sleep(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="pthread-exit-函数"><a href="#pthread-exit-函数" class="headerlink" title="pthread_exit 函数"></a><code>pthread_exit</code> 函数</h3><p>在线程中一般不调用exit&#x2F;_exit,因为这些函数会让进程退出，如果进程退出了，所有的线程都将不能执行。所以如果想退出某个线程是用pthread_exit完成。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">pthread_exit</span><span class="params">(<span class="type">void</span> *retval)</span>;</span><br><span class="line"><span class="comment">// 功能：退出线程</span></span><br><span class="line"><span class="comment">// 参数：</span></span><br><span class="line"><span class="comment">//     @retval:线程退出的状态</span></span><br><span class="line"><span class="comment">// 返回值：无</span></span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;head.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span>* <span class="title function_">task1</span><span class="params">(<span class="type">void</span>* arg)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span>* argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">pthread_t</span> tid;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((errno = pthread_create(&amp;tid, <span class="literal">NULL</span>, task1, <span class="literal">NULL</span>)) != <span class="number">0</span>)</span><br><span class="line">        PRINT_ERR(<span class="string">&quot;pthread_create error&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;主:tid = %ld,子:tid = %ld\n&quot;</span>, pthread_self(), tid);</span><br><span class="line"></span><br><span class="line">     <span class="type">int</span> n = <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;我是主线程...\n&quot;</span>);</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">        n--;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>)</span><br><span class="line">            pthread_exit(<span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="pthread-join-函数"><a href="#pthread-join-函数" class="headerlink" title="pthread_join 函数"></a><code>pthread_join</code> 函数</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_join</span><span class="params">(<span class="type">pthread_t</span> thread, <span class="type">void</span> **retval)</span>;</span><br><span class="line"><span class="comment">// 功能：回收线程的资源（阻塞等子线程结束）</span></span><br><span class="line"><span class="comment">// 参数：</span></span><br><span class="line"><span class="comment">//     @thread:线程号</span></span><br><span class="line"><span class="comment">// 	@retval:接收pthread_exit退出时候的线程状态值</span></span><br><span class="line"><span class="comment">// 返回值：成功返回0，失败返回错误码</span></span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;head.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span>* <span class="title function_">task1</span><span class="params">(<span class="type">void</span>* arg)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> n = <span class="number">5</span>;</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> num=<span class="number">12345</span>;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;我是子线程\n&quot;</span>);</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">        n--;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>)</span><br><span class="line">            pthread_exit((<span class="type">void</span> *)&amp;num);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span>* argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">pthread_t</span> tid;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((errno = pthread_create(&amp;tid, <span class="literal">NULL</span>, task1, <span class="literal">NULL</span>)) != <span class="number">0</span>)</span><br><span class="line">        PRINT_ERR(<span class="string">&quot;pthread_create error&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> *retval;</span><br><span class="line">    pthread_join(tid,(<span class="type">void</span> **)&amp;retval);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;retval = %d\n&quot;</span>,*retval);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="多线程拷贝文件"><a href="#多线程拷贝文件" class="headerlink" title="多线程拷贝文件"></a>多线程拷贝文件</h3><p>在主线程中创建两个子线程，让这两个子线程同时拷贝文件，各拷贝一半。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">./a.out srcfile destfile</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;head.h&gt;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>* src;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>* dest;</span><br><span class="line">    <span class="type">int</span> start;</span><br><span class="line">    <span class="type">int</span> len;</span><br><span class="line">&#125; <span class="type">file_t</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">get_file_len</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* file)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> fd, len;</span><br><span class="line">    <span class="keyword">if</span> ((fd = open(file, O_RDONLY)) == <span class="number">-1</span>)</span><br><span class="line">        PRINT_ERR(<span class="string">&quot;open error&quot;</span>);</span><br><span class="line">    len = lseek(fd, <span class="number">0</span>, SEEK_END);</span><br><span class="line">    close(fd);</span><br><span class="line">    <span class="keyword">return</span> len;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">init_src_file</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* file)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> fd;</span><br><span class="line">    <span class="keyword">if</span> ((fd = open(file, O_WRONLY | O_CREAT | O_TRUNC, <span class="number">0666</span>)) == <span class="number">-1</span>)</span><br><span class="line">        PRINT_ERR(<span class="string">&quot;open error&quot;</span>);</span><br><span class="line"></span><br><span class="line">    close(fd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">copy_file</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* src, <span class="type">const</span> <span class="type">char</span>* dest, <span class="type">int</span> start, <span class="type">int</span> len)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> s[<span class="number">20</span>];</span><br><span class="line">    <span class="type">int</span> fd1, fd2;</span><br><span class="line">    <span class="type">int</span> ret, count = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 1.以只读方式打开源文件，以只写方式打开目标文件</span></span><br><span class="line">    <span class="keyword">if</span> ((fd1 = open(src, O_RDONLY)) == <span class="number">-1</span>)</span><br><span class="line">        PRINT_ERR(<span class="string">&quot;open src error&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> ((fd2 = open(dest, O_WRONLY)) == <span class="number">-1</span>)</span><br><span class="line">        PRINT_ERR(<span class="string">&quot;open dest error&quot;</span>);</span><br><span class="line">    <span class="comment">// 2.定位源和目标文件的光标</span></span><br><span class="line">    lseek(fd1, start, SEEK_SET);</span><br><span class="line">    lseek(fd2, start, SEEK_SET);</span><br><span class="line">    <span class="comment">// 3.循环拷贝</span></span><br><span class="line">    <span class="keyword">while</span> (count &lt; len) &#123;</span><br><span class="line">        ret = read(fd1, s, <span class="keyword">sizeof</span>(s)); <span class="comment">// 从源文件中读</span></span><br><span class="line">        count += ret; <span class="comment">// 将每次读的数据加到count中</span></span><br><span class="line">        write(fd2, s, ret);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 4.关闭文件</span></span><br><span class="line">    close(fd1);</span><br><span class="line">    close(fd2);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span>* <span class="title function_">thread</span><span class="params">(<span class="type">void</span>* arg)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">file_t</span> *f = (<span class="type">file_t</span> *)arg;</span><br><span class="line">    copy_file(f-&gt;src, f-&gt;dest, f-&gt;start, f-&gt;len);</span><br><span class="line">    pthread_exit(<span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span>* argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> len;</span><br><span class="line">    <span class="type">pid_t</span> pid;</span><br><span class="line">    <span class="comment">// 1.检查参数个数</span></span><br><span class="line">    <span class="keyword">if</span> (argc != <span class="number">3</span>) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;input error,try again\n&quot;</span>);</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;usage:./a.out srcfile destfile\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 2.获取源文件大小</span></span><br><span class="line">    len = get_file_len(argv[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3.创建出目标文件，并清空</span></span><br><span class="line">    init_src_file(argv[<span class="number">2</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4.创建两个线程拷贝文件</span></span><br><span class="line">    <span class="type">pthread_t</span> tid1, tid2;</span><br><span class="line">    <span class="type">file_t</span> f[] = &#123;</span><br><span class="line">        [<span class="number">0</span>] = &#123;</span><br><span class="line">            .src = argv[<span class="number">1</span>],</span><br><span class="line">            .dest = argv[<span class="number">2</span>],</span><br><span class="line">            .start = <span class="number">0</span>,</span><br><span class="line">            .len = len / <span class="number">2</span>,</span><br><span class="line">        &#125;,</span><br><span class="line">        [<span class="number">1</span>] = &#123;</span><br><span class="line">            .src = argv[<span class="number">1</span>],</span><br><span class="line">            .dest = argv[<span class="number">2</span>],</span><br><span class="line">            .start = len/<span class="number">2</span>,</span><br><span class="line">            .len = (len - len / <span class="number">2</span>),</span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">if</span> ((errno = pthread_create(&amp;tid1, <span class="literal">NULL</span>, thread, (<span class="type">void</span> *)&amp;f[<span class="number">0</span>])))</span><br><span class="line">        PRINT_ERR(<span class="string">&quot;pthread_create error&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> ((errno = pthread_create(&amp;tid2, <span class="literal">NULL</span>, thread, (<span class="type">void</span> *)&amp;f[<span class="number">1</span>])))</span><br><span class="line">        PRINT_ERR(<span class="string">&quot;pthread_create error&quot;</span>);</span><br><span class="line"></span><br><span class="line">    pthread_join(tid1, <span class="literal">NULL</span>);</span><br><span class="line">    pthread_join(tid2, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="pthread-detach-函数"><a href="#pthread-detach-函数" class="headerlink" title="pthread_detach 函数"></a><code>pthread_detach</code> 函数</h3><p>线程的状态：<strong>结合态</strong>，<strong>分离态</strong>。<br>在使用 <code>pthread_create</code> 函数创建线程的时候默认就是结合态的线程，结合态的线程需要调用 <code>pthread_join</code> 来回收资源，如果将线程标记为分离态，分离态的线程资源会被自动回收，不需要其他的线程回收其资源。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">pthread_detach</span><span class="params">(<span class="type">pthread_t</span> thread)</span>;</span><br><span class="line"><span class="comment">// 功能：将线程标记为分离态</span></span><br><span class="line"><span class="comment">// 参数：</span></span><br><span class="line"><span class="comment">//     @thread:线程号</span></span><br><span class="line"><span class="comment">// 返回值：成功返回0，失败返回错误码</span></span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;head.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span>* <span class="title function_">task1</span><span class="params">(<span class="type">void</span>* arg)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> n = <span class="number">5</span>;</span><br><span class="line">    pthread_detach(pthread_self());</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;我是子线程\n&quot;</span>);</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">        n--;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>)</span><br><span class="line">            pthread_exit(<span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span>* argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">pthread_t</span> tid;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((errno = pthread_create(&amp;tid, <span class="literal">NULL</span>, task1, <span class="literal">NULL</span>)) != <span class="number">0</span>)</span><br><span class="line">        PRINT_ERR(<span class="string">&quot;pthread_create error&quot;</span>);</span><br><span class="line"></span><br><span class="line">    sleep(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    pthread_join(tid,<span class="literal">NULL</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;OOOOOOOOOOOOOOOOOO\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="pthread-cancel-函数"><a href="#pthread-cancel-函数" class="headerlink" title="pthread_cancel 函数"></a><code>pthread_cancel</code> 函数</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">pthread_cancel</span><span class="params">(<span class="type">pthread_t</span> thread)</span>;</span><br><span class="line"><span class="comment">// 功能：给thread发送一个取消的信号</span></span><br><span class="line"><span class="comment">// 参数：</span></span><br><span class="line"><span class="comment">//     @thread:线程号</span></span><br><span class="line"><span class="comment">// 返回值：成功返回0，失败返回错误码 </span></span><br><span class="line">        </span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_setcancelstate</span><span class="params">(<span class="type">int</span> state, <span class="type">int</span> *oldstate)</span>;</span><br><span class="line"><span class="comment">// 功能：设置线程是否可被取消</span></span><br><span class="line"><span class="comment">// 参数：</span></span><br><span class="line"><span class="comment">//     @state:</span></span><br><span class="line"><span class="comment">// 		   PTHREAD_CANCEL_ENABLE:线程可被取消（默认）</span></span><br><span class="line"><span class="comment">//         PTHREAD_CANCEL_DISABLE：线程不能被取消</span></span><br><span class="line"><span class="comment">// 	   @oldstate:旧的线程状态</span></span><br><span class="line"><span class="comment">// 返回值：成功返回0，失败返回错误码</span></span><br><span class="line">        </span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_setcanceltype</span><span class="params">(<span class="type">int</span> type, <span class="type">int</span> *oldtype)</span>;</span><br><span class="line"><span class="comment">// 功能：设置线程取消时机</span></span><br><span class="line"><span class="comment">// 参数：</span></span><br><span class="line"><span class="comment">//     @type:</span></span><br><span class="line"><span class="comment">// 		   PTHREAD_CANCEL_DEFERRED:延时取消（默认），线程中如果是while(1),就找不到取消点，线程取消将被延时</span></span><br><span class="line"><span class="comment">//         PTHREAD_CANCEL_ASYNCHRONOUS：立即取消</span></span><br><span class="line"><span class="comment">// 	   @oldtype:旧的线程类型</span></span><br><span class="line"><span class="comment">// 返回值：成功返回0，失败返回错误码</span></span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;head.h&gt;</span></span></span><br><span class="line"><span class="type">pthread_t</span> tid1, tid2;</span><br><span class="line"><span class="type">void</span>* <span class="title function_">task1</span><span class="params">(<span class="type">void</span>* arg)</span></span><br><span class="line">&#123;</span><br><span class="line">    sleep(<span class="number">3</span>);</span><br><span class="line">    pthread_cancel(tid2);</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span>* <span class="title function_">task2</span><span class="params">(<span class="type">void</span>* arg)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//pthread_setcancelstate(PTHREAD_CANCEL_DISABLE, NULL);</span></span><br><span class="line">    pthread_setcanceltype(PTHREAD_CANCEL_ASYNCHRONOUS,<span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">// printf(&quot;我是线程2...\n&quot;);</span></span><br><span class="line">        <span class="comment">// sleep(1);</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span>* argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> ((errno = pthread_create(&amp;tid1, <span class="literal">NULL</span>, task1, <span class="literal">NULL</span>)) != <span class="number">0</span>)</span><br><span class="line">        PRINT_ERR(<span class="string">&quot;pthread_create error&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> ((errno = pthread_create(&amp;tid2, <span class="literal">NULL</span>, task2, <span class="literal">NULL</span>)) != <span class="number">0</span>)</span><br><span class="line">        PRINT_ERR(<span class="string">&quot;pthread_create error&quot;</span>);</span><br><span class="line"></span><br><span class="line">    pthread_join(tid1, <span class="literal">NULL</span>);</span><br><span class="line">    pthread_join(tid2, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="多线程访问全局变量问题"><a href="#多线程访问全局变量问题" class="headerlink" title="多线程访问全局变量问题"></a>多线程访问全局变量问题</h2><p>对于这个代码，如果 <code>num</code> 变量不加 <code>volatile</code>，使用gcc编译的使用如果加上 <strong>-O1 -O2 -O3</strong> 优化等级（数字越大优化等级越高）会发现 <strong>task2</strong> 线程不能够退出，因为编译器对 <code>num</code> 变量进行了优化认为 <code>num</code> 的值一直都是 <code>0</code> ，所以出现了死循环，为了解决这个问题就需要在 <code>num</code> 变量前加 <code>volatile</code>，不让编译器对其优化，每次都能得到想要的结果。   </p>
<p><strong>总结</strong>：多线程访问全局变量的时候，对变量加 <code>volatile</code>。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;head.h&gt;</span></span></span><br><span class="line"><span class="keyword">volatile</span> <span class="type">int</span> num = <span class="number">0</span>;</span><br><span class="line"><span class="type">void</span>* <span class="title function_">task1</span><span class="params">(<span class="type">void</span>* arg)</span></span><br><span class="line">&#123;</span><br><span class="line">    sleep(<span class="number">2</span>);</span><br><span class="line">    num = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;线程1退出了...\n&quot;</span>);</span><br><span class="line">    pthread_exit(<span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span>* <span class="title function_">task2</span><span class="params">(<span class="type">void</span>* arg)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span> (num == <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;线程2退出了...\n&quot;</span>);</span><br><span class="line">    pthread_exit(<span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span>* argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">pthread_t</span> tid1, tid2;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((errno = pthread_create(&amp;tid1, <span class="literal">NULL</span>, task1, <span class="literal">NULL</span>)) != <span class="number">0</span>)</span><br><span class="line">        PRINT_ERR(<span class="string">&quot;pthread_create error&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> ((errno = pthread_create(&amp;tid2, <span class="literal">NULL</span>, task2, <span class="literal">NULL</span>)) != <span class="number">0</span>)</span><br><span class="line">        PRINT_ERR(<span class="string">&quot;pthread_create error&quot;</span>);</span><br><span class="line"></span><br><span class="line">    pthread_join(tid1, <span class="literal">NULL</span>);</span><br><span class="line">    pthread_join(tid2, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="线程间通信"><a href="#线程间通信" class="headerlink" title="线程间通信"></a>线程间通信</h1><p>线程间通信一般在指线程互斥机制和线程的同步机制。</p>
<h2 id="多线程产生竞态的问题"><a href="#多线程产生竞态的问题" class="headerlink" title="多线程产生竞态的问题"></a>多线程产生竞态的问题</h2><p>多个线程同时使用同一个全局变量的时候，两个线程都想操作这个变量，此时竞态就会产生了，可以使用 <strong>互斥锁</strong>、<strong>信号量</strong>、<strong>条件变量</strong>等来解决这个问题。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;head.h&gt;</span></span></span><br><span class="line"><span class="keyword">volatile</span> <span class="type">int</span> money = <span class="number">10000</span>;</span><br><span class="line"><span class="comment">// 张三</span></span><br><span class="line"><span class="type">void</span>* <span class="title function_">task1</span><span class="params">(<span class="type">void</span>* arg)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        money -= <span class="number">50</span>;</span><br><span class="line">        <span class="keyword">if</span> (money &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;张三成功取了50块钱，余额=%d\n&quot;</span>, money);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            money += <span class="number">50</span>;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;张三取钱失败，余额不足\n&quot;</span>);</span><br><span class="line">            pthread_exit(<span class="literal">NULL</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 李四</span></span><br><span class="line"><span class="type">void</span>* <span class="title function_">task2</span><span class="params">(<span class="type">void</span>* arg)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        money -= <span class="number">100</span>;</span><br><span class="line">        <span class="keyword">if</span> (money &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;李四成功取了100块钱，余额=%d\n&quot;</span>, money);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            money += <span class="number">100</span>;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;李四取钱失败，余额不足\n&quot;</span>);</span><br><span class="line">            pthread_exit(<span class="literal">NULL</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span>* argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">pthread_t</span> tid1, tid2;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((errno = pthread_create(&amp;tid1, <span class="literal">NULL</span>, task1, <span class="literal">NULL</span>)) != <span class="number">0</span>)</span><br><span class="line">        PRINT_ERR(<span class="string">&quot;pthread_create error&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((errno = pthread_create(&amp;tid2, <span class="literal">NULL</span>, task2, <span class="literal">NULL</span>)) != <span class="number">0</span>)</span><br><span class="line">        PRINT_ERR(<span class="string">&quot;pthread_create error&quot;</span>);</span><br><span class="line"></span><br><span class="line">    pthread_join(tid1, <span class="literal">NULL</span>);</span><br><span class="line">    pthread_join(tid2, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="线程的互斥锁"><a href="#线程的互斥锁" class="headerlink" title="线程的互斥锁"></a>线程的互斥锁</h2><h3 id="线程互斥锁的API"><a href="#线程互斥锁的API" class="headerlink" title="线程互斥锁的API"></a>线程互斥锁的API</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1.定义互斥锁</span></span><br><span class="line"><span class="type">pthread_mutex_t</span> mutex;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2.初始化线程互斥锁</span></span><br><span class="line"><span class="type">pthread_mutex_t</span> mutex = PTHREAD_MUTEX_INITIALIZER;</span><br><span class="line"><span class="comment">// 静态初始化</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_mutex_init</span><span class="params">(<span class="type">pthread_mutex_t</span> * mutex, <span class="type">const</span> <span class="type">pthread_mutexattr_t</span> * attr)</span>;</span><br><span class="line"><span class="comment">// 动态初始化</span></span><br><span class="line"><span class="comment">// 功能：初始化互斥锁</span></span><br><span class="line"><span class="comment">// 参数：</span></span><br><span class="line"><span class="comment">//     @mutex:被初始化的锁</span></span><br><span class="line"><span class="comment">// 	@attr:锁的属性，一般填写为NULL(默认属性)</span></span><br><span class="line"><span class="comment">// 返回值：成功返回0，失败返回错误码</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 3.上锁</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_mutex_trylock</span><span class="params">(<span class="type">pthread_mutex_t</span> *mutex)</span>;</span><br><span class="line"><span class="comment">// 尝试获取锁，如果锁资源存在那就占用锁，如果锁资源不可利用，立即返回。</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_mutex_lock</span><span class="params">(<span class="type">pthread_mutex_t</span> *mutex)</span>;</span><br><span class="line"><span class="comment">// 功能：上锁（如果线程获取不到锁的资源，线程阻塞，直到其他的线程将锁释放）</span></span><br><span class="line"><span class="comment">// 参数：</span></span><br><span class="line"><span class="comment">//      @mutex:执行锁的指针</span></span><br><span class="line"><span class="comment">// 返回值：成功返回0，失败返回错误码</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 4.解锁</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_mutex_unlock</span><span class="params">(<span class="type">pthread_mutex_t</span> *mutex)</span>;</span><br><span class="line"><span class="comment">// 功能：解锁</span></span><br><span class="line"><span class="comment">// 参数：</span></span><br><span class="line"><span class="comment">//       @mutex:执行锁的指针</span></span><br><span class="line"><span class="comment">// 返回值：成功返回0，失败返回错误码 </span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 5.销毁锁</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_mutex_destroy</span><span class="params">(<span class="type">pthread_mutex_t</span> *mutex)</span>;</span><br><span class="line"><span class="comment">// 功能：销毁互斥锁</span></span><br><span class="line"><span class="comment">// 参数：</span></span><br><span class="line"><span class="comment">//     @mutex:执行锁的指针</span></span><br><span class="line"><span class="comment">// 返回值：成功返回0，失败返回错误码</span></span><br></pre></td></tr></table></figure>

<h3 id="线程互斥锁的实例"><a href="#线程互斥锁的实例" class="headerlink" title="线程互斥锁的实例"></a>线程互斥锁的实例</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;head.h&gt;</span></span></span><br><span class="line"><span class="type">pthread_mutex_t</span> lock; <span class="comment">// 定义锁</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">volatile</span> <span class="type">int</span> money = <span class="number">10000</span>;  <span class="comment">//临界资源</span></span><br><span class="line"><span class="comment">// 张三</span></span><br><span class="line"><span class="type">void</span>* <span class="title function_">task1</span><span class="params">(<span class="type">void</span>* arg)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        pthread_mutex_lock(&amp;lock);</span><br><span class="line">        money -= <span class="number">50</span>;</span><br><span class="line">        <span class="keyword">if</span> (money &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;张三成功取了50块钱,余额=%d\n&quot;</span>, money);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            money += <span class="number">50</span>;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;张三取钱失败,余额不足\n&quot;</span>);</span><br><span class="line">            pthread_mutex_unlock(&amp;lock);</span><br><span class="line">            pthread_exit(<span class="literal">NULL</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// sleep(1);</span></span><br><span class="line">        pthread_mutex_unlock(&amp;lock);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 李四</span></span><br><span class="line"><span class="type">void</span>* <span class="title function_">task2</span><span class="params">(<span class="type">void</span>* arg)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        pthread_mutex_lock(&amp;lock);</span><br><span class="line">        money -= <span class="number">100</span>;</span><br><span class="line">        <span class="keyword">if</span> (money &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;李四成功取了100块钱,余额=%d\n&quot;</span>, money);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            money += <span class="number">100</span>;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;李四取钱失败,余额不足\n&quot;</span>);</span><br><span class="line">            pthread_mutex_unlock(&amp;lock);</span><br><span class="line">            pthread_exit(<span class="literal">NULL</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// sleep(1);</span></span><br><span class="line">        pthread_mutex_unlock(&amp;lock);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span>* argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">pthread_t</span> tid1, tid2;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化互斥锁</span></span><br><span class="line">    pthread_mutex_init(&amp;lock, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((errno = pthread_create(&amp;tid1, <span class="literal">NULL</span>, task1, <span class="literal">NULL</span>)) != <span class="number">0</span>)</span><br><span class="line">        PRINT_ERR(<span class="string">&quot;pthread_create error&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((errno = pthread_create(&amp;tid2, <span class="literal">NULL</span>, task2, <span class="literal">NULL</span>)) != <span class="number">0</span>)</span><br><span class="line">        PRINT_ERR(<span class="string">&quot;pthread_create error&quot;</span>);</span><br><span class="line"></span><br><span class="line">    pthread_join(tid1, <span class="literal">NULL</span>);</span><br><span class="line">    pthread_join(tid2, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 销毁锁</span></span><br><span class="line">    pthread_mutex_destroy(&amp;lock);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="线程互斥锁死锁问题"><a href="#线程互斥锁死锁问题" class="headerlink" title="线程互斥锁死锁问题"></a>线程互斥锁死锁问题</h3><ol>
<li>产生死锁的四个必要条件<ul>
<li>互斥</li>
<li>请求保持</li>
<li>不可剥夺</li>
<li>循环等待</li>
</ul>
</li>
<li>死锁的规避方法<ul>
<li>指定线程获取锁的顺序</li>
<li>尽量避免锁的嵌套使用</li>
<li>给线程上锁指定超时时间 <code>pthread_mutex_timedlock</code></li>
<li>在全局位置指定锁是否被使用的状态，如果被使用就不在获取</li>
</ul>
</li>
</ol>
<h2 id="无名信号量"><a href="#无名信号量" class="headerlink" title="无名信号量"></a>无名信号量</h2><h3 id="无名信号的工作原理"><a href="#无名信号的工作原理" class="headerlink" title="无名信号的工作原理"></a>无名信号的工作原理</h3><p>当多个线程在访问全局变量的时候如果使用互斥锁只能保证有一个线程在操作临界资源，不能保证线程的执行的先后顺序，如果想要控制线程的执行顺序就可以使用无名信号量完成，无名信号量是实现线程同步的机制。线程同步机制一般使用在生产者和消费者模型上。</p>
<h3 id="无名信号量的API"><a href="#无名信号量的API" class="headerlink" title="无名信号量的API"></a>无名信号量的API</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;semaphore.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 1.定义无名信号量</span></span><br><span class="line"><span class="type">sem_t</span> sem;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2.初始化无名信号量</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sem_init</span><span class="params">(<span class="type">sem_t</span> *sem, <span class="type">int</span> pshared, <span class="type">unsigned</span> <span class="type">int</span> value)</span>;</span><br><span class="line"><span class="comment">// 功能：初始化无名信号量</span></span><br><span class="line"><span class="comment">// 参数：</span></span><br><span class="line"><span class="comment">//     @sem:指向无名信号量的指针</span></span><br><span class="line"><span class="comment">//     @pshared:0 线程的同步</span></span><br><span class="line"><span class="comment">//         	 1 进程的同步（亲缘关系进程）</span></span><br><span class="line"><span class="comment">//     @value:信号的初值  1</span></span><br><span class="line"><span class="comment">// 返回值：成功返回0，失败返回-1置位错误码</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 3.获取信号量（P操作）</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sem_wait</span><span class="params">(<span class="type">sem_t</span> *sem)</span>;</span><br><span class="line"><span class="comment">// 功能：申请资源（让信号量的值减去1，然后和0比较如果结果为0，表示获取锁成功了）    </span></span><br><span class="line"><span class="comment">//     如果在调用sem_wait的时候获取不到资源，sem_wait会阻塞</span></span><br><span class="line"><span class="comment">// 参数：</span></span><br><span class="line"><span class="comment">//     @sem:指向无名信号量的指针</span></span><br><span class="line"><span class="comment">// 返回值：成功返回0，失败返回-1置位错误码</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 4.释放信号量（V操作）</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sem_post</span><span class="params">(<span class="type">sem_t</span> *sem)</span>;</span><br><span class="line"><span class="comment">// 功能：释放资源</span></span><br><span class="line"><span class="comment">// 参数：</span></span><br><span class="line"><span class="comment">//     @sem:指向无名信号量的指针</span></span><br><span class="line"><span class="comment">// 返回值：成功返回0，失败返回-1置位错误码</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 5.销毁无名信号量</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sem_destroy</span><span class="params">(<span class="type">sem_t</span> *sem)</span>;</span><br><span class="line"><span class="comment">// 功能：销毁无名信号量</span></span><br><span class="line"><span class="comment">// 参数：</span></span><br><span class="line"><span class="comment">//     @sem:指向无名信号量的指针</span></span><br><span class="line"><span class="comment">// 返回值：成功返回0，失败返回-1置位错误码</span></span><br></pre></td></tr></table></figure>

<h3 id="无名信号量实例"><a href="#无名信号量实例" class="headerlink" title="无名信号量实例"></a>无名信号量实例</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;head.h&gt;</span></span></span><br><span class="line"><span class="type">sem_t</span> sem1, sem2; <span class="comment">// 定义无名信号量</span></span><br><span class="line"><span class="comment">// 生产者线程</span></span><br><span class="line"><span class="type">void</span>* <span class="title function_">task1</span><span class="params">(<span class="type">void</span>* arg)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        sem_wait(&amp;sem1); <span class="comment">//申请资源sem1</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;我生成了一部手机...\n&quot;</span>);</span><br><span class="line">        sem_post(&amp;sem2); <span class="comment">// 释放资源 sem2</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 消费者线程</span></span><br><span class="line"><span class="type">void</span>* <span class="title function_">task2</span><span class="params">(<span class="type">void</span>* arg)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        sem_wait(&amp;sem2); <span class="comment">// 申请资源 sem2</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;我购买了一部手机\n&quot;</span>);</span><br><span class="line">        sem_post(&amp;sem1); <span class="comment">//释放资源 sem1</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span>* argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">pthread_t</span> tid1, tid2;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化无名信号量</span></span><br><span class="line">    sem_init(&amp;sem1, <span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">    sem_init(&amp;sem2, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((errno = pthread_create(&amp;tid1, <span class="literal">NULL</span>, task1, <span class="literal">NULL</span>)) != <span class="number">0</span>)</span><br><span class="line">        PRINT_ERR(<span class="string">&quot;pthread_create error&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((errno = pthread_create(&amp;tid2, <span class="literal">NULL</span>, task2, <span class="literal">NULL</span>)) != <span class="number">0</span>)</span><br><span class="line">        PRINT_ERR(<span class="string">&quot;pthread_create error&quot;</span>);</span><br><span class="line"></span><br><span class="line">    pthread_join(tid1, <span class="literal">NULL</span>);</span><br><span class="line">    pthread_join(tid2, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 销毁无名信号量</span></span><br><span class="line">    sem_destroy(&amp;sem1);</span><br><span class="line">    sem_destroy(&amp;sem2);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="无名信号量的应用"><a href="#无名信号量的应用" class="headerlink" title="无名信号量的应用"></a>无名信号量的应用</h3><p>有三个线程分别打印ABC，使用无名信号量实现三个线程同步，逐次打印 <code>ABCABCABC...</code></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;head.h&gt;</span></span></span><br><span class="line"><span class="type">sem_t</span> sem1, sem2, sem3; <span class="comment">// 定义无名信号量</span></span><br><span class="line"><span class="comment">// A</span></span><br><span class="line"><span class="type">void</span>* <span class="title function_">task1</span><span class="params">(<span class="type">void</span>* arg)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        sem_wait(&amp;sem1); <span class="comment">// 申请资源sem1</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;A&quot;</span>);</span><br><span class="line">        sem_post(&amp;sem2); <span class="comment">// 释放资源 sem2</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// B</span></span><br><span class="line"><span class="type">void</span>* <span class="title function_">task2</span><span class="params">(<span class="type">void</span>* arg)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        sem_wait(&amp;sem2); <span class="comment">// 申请资源 sem2</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;B&quot;</span>);</span><br><span class="line">        sem_post(&amp;sem3); <span class="comment">// 释放资源 sem3</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// C</span></span><br><span class="line"><span class="type">void</span>* <span class="title function_">task3</span><span class="params">(<span class="type">void</span>* arg)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        sem_wait(&amp;sem3); <span class="comment">// 申请资源 sem2</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;C\n&quot;</span>);</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">        sem_post(&amp;sem1); <span class="comment">// 释放资源 sem1</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span>* argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">pthread_t</span> tid1, tid2,tid3;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化无名信号量</span></span><br><span class="line">    sem_init(&amp;sem1, <span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">    sem_init(&amp;sem2, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    sem_init(&amp;sem3, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((errno = pthread_create(&amp;tid1, <span class="literal">NULL</span>, task1, <span class="literal">NULL</span>)) != <span class="number">0</span>)</span><br><span class="line">        PRINT_ERR(<span class="string">&quot;pthread_create error&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((errno = pthread_create(&amp;tid2, <span class="literal">NULL</span>, task2, <span class="literal">NULL</span>)) != <span class="number">0</span>)</span><br><span class="line">        PRINT_ERR(<span class="string">&quot;pthread_create error&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> ((errno = pthread_create(&amp;tid3, <span class="literal">NULL</span>, task3, <span class="literal">NULL</span>)) != <span class="number">0</span>)</span><br><span class="line">        PRINT_ERR(<span class="string">&quot;pthread_create error&quot;</span>);</span><br><span class="line"></span><br><span class="line">    pthread_join(tid1, <span class="literal">NULL</span>);</span><br><span class="line">    pthread_join(tid2, <span class="literal">NULL</span>);</span><br><span class="line">    pthread_join(tid3, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 销毁无名信号量</span></span><br><span class="line">    sem_destroy(&amp;sem1);</span><br><span class="line">    sem_destroy(&amp;sem2);</span><br><span class="line">    sem_destroy(&amp;sem3);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="条件变量"><a href="#条件变量" class="headerlink" title="条件变量"></a>条件变量</h2><h3 id="条件变量的工作原理"><a href="#条件变量的工作原理" class="headerlink" title="条件变量的工作原理"></a>条件变量的工作原理</h3><p>条件变量也是线程的同步机制，条件变量更适合用在多个线程的同步工作。</p>
<h3 id="条件变量的API"><a href="#条件变量的API" class="headerlink" title="条件变量的API"></a>条件变量的API</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1.定义条件变量</span></span><br><span class="line"><span class="type">pthread_cond_t</span> cond;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2.初始化条件变量</span></span><br><span class="line"><span class="type">pthread_cond_t</span> cond = PTHREAD_COND_INITIALIZER;</span><br><span class="line"><span class="comment">// //静态初始化	</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_cond_init</span><span class="params">(<span class="type">pthread_cond_t</span> * cond,<span class="type">const</span> <span class="type">pthread_condattr_t</span> * attr)</span>;</span><br><span class="line"><span class="comment">// 功能：动态初始化一个条件变量</span></span><br><span class="line"><span class="comment">// 参数：</span></span><br><span class="line"><span class="comment">//    @cond：条件变量的指针</span></span><br><span class="line"><span class="comment">//    @attr:NULL使用默认属性</span></span><br><span class="line"><span class="comment">// 返回值：成功返回0，失败返回非0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 3.阻塞等待条件变量</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_cond_wait</span><span class="params">(<span class="type">pthread_cond_t</span> * cond,<span class="type">pthread_mutex_t</span> * mutex)</span>;</span><br><span class="line"><span class="comment">// 功能：阻塞等待条件变量，在条件变量中维护了一个队列，这里的互斥锁就是为</span></span><br><span class="line"><span class="comment">//     了解决在往队列中放线程的时候出现竞态问题的。</span></span><br><span class="line"><span class="comment">// 参数：</span></span><br><span class="line"><span class="comment">//     @cond:条件变量的地址</span></span><br><span class="line"><span class="comment">//     @mutex:互斥锁</span></span><br><span class="line"><span class="comment">// 返回值：成功返回0，失败返回非零</span></span><br><span class="line"><span class="comment">// 使用的步骤：</span></span><br><span class="line"><span class="comment">//     1.使用pthread_mutex_lock上锁</span></span><br><span class="line"><span class="comment">//     2.调用pthread_cond_wait</span></span><br><span class="line"><span class="comment">//         2.1将当前线程放入队列</span></span><br><span class="line"><span class="comment">//         2.2解锁</span></span><br><span class="line"><span class="comment">//         2.3休眠</span></span><br><span class="line"><span class="comment">//         2.4获取锁</span></span><br><span class="line"><span class="comment">//         2.5休眠状态退出</span></span><br><span class="line"><span class="comment">//     3.你的程序</span></span><br><span class="line"><span class="comment">//     4.使用pthread_mutex_unlock解锁</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 4.给休眠的线程发信号或者广播</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_cond_signal</span><span class="params">(<span class="type">pthread_cond_t</span> *cond)</span>;</span><br><span class="line"><span class="comment">// 功能：唤醒(至少)一个休眠的线程</span></span><br><span class="line"><span class="comment">// 参数：</span></span><br><span class="line"><span class="comment">//     @cond:条件变量的地址</span></span><br><span class="line"><span class="comment">// 返回值：成功返回0，失败返回非零</span></span><br><span class="line"><span class="comment">// int pthread_cond_broadcast(pthread_cond_t *cond);</span></span><br><span class="line"><span class="comment">// 功能：唤醒所有休眠的线程</span></span><br><span class="line"><span class="comment">// 参数：</span></span><br><span class="line"><span class="comment">//     @cond:条件变量的地址</span></span><br><span class="line"><span class="comment">// 返回值：成功返回0，失败返回非零     </span></span><br><span class="line">       </span><br><span class="line"><span class="comment">// 5.销毁条件变量     </span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_cond_destroy</span><span class="params">(<span class="type">pthread_cond_t</span> *cond)</span>;</span><br><span class="line"><span class="comment">// 功能：销毁条件变量</span></span><br><span class="line"><span class="comment">// 参数：</span></span><br><span class="line"><span class="comment">//      @cond:条件变量的地址</span></span><br><span class="line"><span class="comment">// 返回值：成功返回0，失败返回非零 </span></span><br></pre></td></tr></table></figure>

<h3 id="条件变量的实例"><a href="#条件变量的实例" class="headerlink" title="条件变量的实例"></a>条件变量的实例</h3><p>一个生产者和多个消费者线程同步：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;head.h&gt;</span></span></span><br><span class="line"><span class="type">pthread_cond_t</span> cond; <span class="comment">//定义条件变量</span></span><br><span class="line"><span class="type">pthread_mutex_t</span> lock; <span class="comment">//定义互斥锁</span></span><br><span class="line"><span class="comment">// 生成者</span></span><br><span class="line"><span class="type">void</span>* <span class="title function_">task1</span><span class="params">(<span class="type">void</span>* arg)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;我生产了一部手机\n&quot;</span>);</span><br><span class="line">        <span class="comment">// pthread_cond_signal(&amp;cond); //释放资源</span></span><br><span class="line">        pthread_cond_broadcast(&amp;cond);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 消费者</span></span><br><span class="line"><span class="type">void</span>* <span class="title function_">task2</span><span class="params">(<span class="type">void</span>* arg)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        pthread_mutex_lock(&amp;lock);</span><br><span class="line">        pthread_cond_wait(&amp;cond,&amp;lock);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%#lx购买了一部手机\n&quot;</span>,pthread_self());</span><br><span class="line">        pthread_mutex_unlock(&amp;lock);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span>* argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">pthread_t</span> tid1, tid2, tid3, tid4, tid5;</span><br><span class="line">    pthread_mutex_init(&amp;lock,<span class="literal">NULL</span>);<span class="comment">//初始化互斥锁</span></span><br><span class="line">    pthread_cond_init(&amp;cond,<span class="literal">NULL</span>); <span class="comment">//初始化条件变量</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((errno = pthread_create(&amp;tid1, <span class="literal">NULL</span>, task1, <span class="literal">NULL</span>)) != <span class="number">0</span>)</span><br><span class="line">        PRINT_ERR(<span class="string">&quot;pthread_create error&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((errno = pthread_create(&amp;tid2, <span class="literal">NULL</span>, task2, <span class="literal">NULL</span>)) != <span class="number">0</span>)</span><br><span class="line">        PRINT_ERR(<span class="string">&quot;pthread_create error&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> ((errno = pthread_create(&amp;tid3, <span class="literal">NULL</span>, task2, <span class="literal">NULL</span>)) != <span class="number">0</span>)</span><br><span class="line">        PRINT_ERR(<span class="string">&quot;pthread_create error&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> ((errno = pthread_create(&amp;tid4, <span class="literal">NULL</span>, task2, <span class="literal">NULL</span>)) != <span class="number">0</span>)</span><br><span class="line">        PRINT_ERR(<span class="string">&quot;pthread_create error&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> ((errno = pthread_create(&amp;tid5, <span class="literal">NULL</span>, task2, <span class="literal">NULL</span>)) != <span class="number">0</span>)</span><br><span class="line">        PRINT_ERR(<span class="string">&quot;pthread_create error&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;tid2=%#lx,tid3=%#lx,tid3=%#lx,tid5=%#lx\n&quot;</span>,</span><br><span class="line">        tid2, tid3, tid4, tid5);</span><br><span class="line"></span><br><span class="line">    pthread_join(tid1, <span class="literal">NULL</span>);</span><br><span class="line">    pthread_join(tid2, <span class="literal">NULL</span>);</span><br><span class="line">    pthread_join(tid3, <span class="literal">NULL</span>);</span><br><span class="line">    pthread_join(tid4, <span class="literal">NULL</span>);</span><br><span class="line">    pthread_join(tid5, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    pthread_cond_destroy(&amp;cond);</span><br><span class="line">    pthread_mutex_destroy(&amp;lock);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>（一个）生产者线程和消费者线程同步</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;head.h&gt;</span></span></span><br><span class="line"><span class="type">pthread_cond_t</span> cond; <span class="comment">// 定义条件变量</span></span><br><span class="line"><span class="type">pthread_mutex_t</span> lock; <span class="comment">// 定义互斥锁</span></span><br><span class="line"><span class="type">int</span> flags = <span class="number">0</span>; <span class="comment">// 标志位变量</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//情况1： B(pthread_cond_wait) A    A(pthread_cond_wait) B  </span></span><br><span class="line"><span class="comment">//情况2： B(pthread_cond_wait) A B</span></span><br><span class="line"><span class="comment">//情况3： A A(pthread_cond_wait) B</span></span><br><span class="line"><span class="comment">//情况4： A B</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 生成者 A</span></span><br><span class="line"><span class="type">void</span>* <span class="title function_">task1</span><span class="params">(<span class="type">void</span>* arg)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        pthread_mutex_lock(&amp;lock);</span><br><span class="line">        <span class="keyword">if</span> (flags == <span class="number">1</span>)</span><br><span class="line">            pthread_cond_wait(&amp;cond, &amp;lock);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;我生产了一部手机\n&quot;</span>);</span><br><span class="line">        pthread_cond_signal(&amp;cond); <span class="comment">// 释放资源</span></span><br><span class="line">        flags = <span class="number">1</span>;</span><br><span class="line">        pthread_mutex_unlock(&amp;lock);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 消费者 B</span></span><br><span class="line"><span class="type">void</span>* <span class="title function_">task2</span><span class="params">(<span class="type">void</span>* arg)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        pthread_mutex_lock(&amp;lock);</span><br><span class="line">        <span class="keyword">if</span> (flags == <span class="number">0</span>)</span><br><span class="line">            pthread_cond_wait(&amp;cond, &amp;lock);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;购买了一部手机\n&quot;</span>);</span><br><span class="line">        pthread_cond_signal(&amp;cond); <span class="comment">// 释放资源</span></span><br><span class="line">        flags = <span class="number">0</span>;</span><br><span class="line">        pthread_mutex_unlock(&amp;lock);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span>* argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">pthread_t</span> tid1, tid2;</span><br><span class="line">    pthread_mutex_init(&amp;lock, <span class="literal">NULL</span>); <span class="comment">// 初始化互斥锁</span></span><br><span class="line">    pthread_cond_init(&amp;cond, <span class="literal">NULL</span>); <span class="comment">// 初始化条件变量</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((errno = pthread_create(&amp;tid1, <span class="literal">NULL</span>, task1, <span class="literal">NULL</span>)) != <span class="number">0</span>)</span><br><span class="line">        PRINT_ERR(<span class="string">&quot;pthread_create error&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((errno = pthread_create(&amp;tid2, <span class="literal">NULL</span>, task2, <span class="literal">NULL</span>)) != <span class="number">0</span>)</span><br><span class="line">        PRINT_ERR(<span class="string">&quot;pthread_create error&quot;</span>);</span><br><span class="line"></span><br><span class="line">    pthread_join(tid1, <span class="literal">NULL</span>);</span><br><span class="line">    pthread_join(tid2, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    pthread_cond_destroy(&amp;cond);</span><br><span class="line">    pthread_mutex_destroy(&amp;lock);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="条件变量使用场景"><a href="#条件变量使用场景" class="headerlink" title="条件变量使用场景"></a>条件变量使用场景</h3><p>无名信号量适合在线程数比较少的线程中实现同步过程，而条件变量适合在大量线程实现同步过程。  </p>
<p>例如你要编写一个12306买票的服务器当客户端访问服务器的时候，服务器会创建一个线程服务于这个用户。如果有多个用户同时想买票，此时服务需要在 <strong>瞬间创建</strong> 一堆线程，这个时间比较长，对用户的体验感不好。所以12306服务器是在启动的时候都已经创建好一堆线程。调用 <code>pthread_cond_wait</code> 让这些线程休眠，当有客户端请求买票的时候，只需要唤醒这些休眠的线程即可，由于省去了创建线程的时间，所以这种方式的效率非常的高。</p>
]]></content>
  </entry>
  <entry>
    <title>视频流移植</title>
    <url>/2023/01/25/%E8%A7%86%E9%A2%91%E6%B5%81%E7%A7%BB%E6%A4%8D/</url>
    <content><![CDATA[<p>本文包含确前置准备确认、内核驱动移植、<code>mjpeg-streamer</code> 移植、移植中遇到的错误和可能遇到的错误、以及解决方案、配置网页显示等内容。</p>
<span id="more"></span>

<h1 id="MJPG"><a href="#MJPG" class="headerlink" title="MJPG"></a>MJPG</h1><p><strong>MJPG</strong> 是 <strong>MJPEG</strong> 的缩写,但是 <strong>MJPEG</strong> 还可以表示文件格式扩展名，全名为 **”Motion Joint Photographic Experts Group”**，是一种视频编码格式。<br><strong>Motion JPEG</strong> 技术常用与闭合电路的电视摄像机的模拟视频信号“翻译”成视频流，并存储在硬盘上。</p>
<h1 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h1><ul>
<li>主机：Ubuntu 18.04.4 LTS</li>
<li>目标机：Cortex-A7</li>
<li>交叉工具链：arm-linux-gnueabihf-</li>
<li>摄像头：OV5640</li>
</ul>
<h1 id="查看摄像头信息"><a href="#查看摄像头信息" class="headerlink" title="查看摄像头信息"></a>查看摄像头信息</h1><ol>
<li>支持 UVC （免驱）</li>
<li>YUV 或者 MJPRG 格式输出</li>
</ol>
<h1 id="驱动移植"><a href="#驱动移植" class="headerlink" title="驱动移植"></a>驱动移植</h1><ol>
<li>进入内核配置菜单，<code>make menuconfig</code></li>
<li>选择<br><code>Device Drivers</code> -&gt; <code>Multimedia support</code> -&gt; <code>Video capture adapters</code> -&gt; <code>V4l USB devices</code> &amp; <code>V4L platform devices</code><br><code>Device Drivers</code> -&gt; <code>Multimedia support</code> -&gt; <code>V4L platform devices</code> -&gt; <code>Support for timberdale Video In/LogiWIN</code> &amp; <code>SoC camera support</code> &amp; <code>platform camera support</code><br><code>Device Drivers</code> -&gt; <code>Multimedia support</code> -&gt; <code>Video capture adapters</code> -&gt; <code>V4l USB devices</code> -&gt; <code>USB Video class (UVC)</code> &amp; <code>UVC input events device support</code> &amp; <code>GSPCA based webcams</code><br><code>Device Drivers</code> -&gt; <code>Multimedia support</code> -&gt; <code>Video capture adapters</code> -&gt; <code>V4l USB devices</code> -&gt;  <code>GSPCA based webcams</code>  -&gt; <code>ZC3XX USB Camera Driver</code>   </li>
<li>编译内核，<code>make -j4 uImage</code> 并拷贝到共享目录</li>
</ol>
<h1 id="mjpeg-streamer-移植"><a href="#mjpeg-streamer-移植" class="headerlink" title="mjpeg-streamer 移植"></a>mjpeg-streamer 移植</h1><p>mjpg-stream的移植需要jpeg的库，所以需要先移植jpeg的库</p>
<h2 id="jpeg-库移植"><a href="#jpeg-库移植" class="headerlink" title="jpeg 库移植"></a>jpeg 库移植</h2><ol>
<li>下载 jpeg 库<br><code>http://www.ijg.org/files/jpegsrc.v8b.tar.gz</code> </li>
<li>解压<br><code>tar -xvf jpegsrc.v8b.tar.gz</code></li>
<li>配置源码<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd jpeg-8b</span><br><span class="line">mkdir rootfs/video/jpegarm -p</span><br><span class="line">./configure --prefix=`home/rootfs/video/jpegarm --host=arm-linux-gnueabighf</span><br></pre></td></tr></table></figure></li>
<li>编译安装<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">make</span><br><span class="line">make install</span><br></pre></td></tr></table></figure></li>
<li>拷贝库到网络文件系统中<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo cp -arf /home/rootfs/video/jpegarm/lib/* /home/rootfs/lib</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="mjpg-streamer-移植"><a href="#mjpg-streamer-移植" class="headerlink" title="mjpg-streamer 移植"></a>mjpg-streamer 移植</h2><ol>
<li>下载 mjpg-streamer<br><code>https://sourceforge.net/projects/mjpg-streamer/</code></li>
<li>解压<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">tar -xvf mjpg-streamer-r182.tar.gz</span><br><span class="line">cd mjpg-streamer-182</span><br></pre></td></tr></table></figure></li>
<li>修改源码<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd mjpg-streamer</span><br><span class="line">vim ./plugins/input_uvc/Makefile</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">CFLAGS += -O1 -DLINUX -D_GNU_SOURCE -Wall -shared -fPIC</span> </span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">修改为</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">CFLAGS += -O1 -DLINUX -D_GNU_SOURCE -Wall -shared -fPIC -I /home/ming/rootfs/video/jpegarm/include</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">$(CC) $(CFLAGS) -o <span class="variable">$@</span> input_uvc.c v4l2uvc.lo jpeg_utils.lo dynctrl.lo $(LFLAGS)</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">修改为</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">$(CC) $(CFLAGS) -L /home/ming/rootfs/video/jpegarm/lib  -o <span class="variable">$@</span> input_uvc.c v4l2uvc.lo jpeg_utils.lo dynctrl.lo $(LFLAGS)</span></span><br></pre></td></tr></table></figure></li>
<li>编译<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd mjpg-streamer-182/mjpg-streamer</span><br><span class="line">make CC=arm-linux-gnueabihf-gcc</span><br></pre></td></tr></table></figure></li>
<li>在网络文件系统中创建文件夹并拷贝文件<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mkdir -p /home/rootfs/mjpg-streamer</span><br><span class="line">sudo cp *.so  /home/ming/rootfs/mjpg-streamer -arf</span><br><span class="line">sudo cp mjpg_streamer  /home/ming/rootfs/mjpg-streamer -arf</span><br><span class="line">sudo cp start.sh www/ /home/ming/rootfs/mjpg-streamer/ -arf</span><br></pre></td></tr></table></figure></li>
<li>修改 <code>start.sh</code> 文件<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">./mjpg_streamer -i <span class="string">&quot;./input_uvc.so -y&quot;</span> -o <span class="string">&quot;./output_http.so -w ./www&quot;</span></span> </span><br></pre></td></tr></table></figure></li>
<li><code>http://开发板IP地址:8080/?action=stream</code> 查看视频流</li>
<li><code>http://开发板IP地址:8080/?action=snapshot</code> 查看快照</li>
<li>修改网页源码</li>
</ol>
<h1 id="错误"><a href="#错误" class="headerlink" title="错误"></a>错误</h1><h2 id="1-make-svnversion-Command-not-found"><a href="#1-make-svnversion-Command-not-found" class="headerlink" title="1. make: svnversion: Command not found"></a>1. <code>make: svnversion: Command not found</code></h2><p>电脑中缺少必要的库，需要安装必要的软件集</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo apt-get install subversion  libv4l-dev  libjpeg62-dev  imagemagick</span><br></pre></td></tr></table></figure>
<h2 id="2-mjpg-streamer-c-27-28-fatal-error-linux-videodev-h-No-such-file-or-directory"><a href="#2-mjpg-streamer-c-27-28-fatal-error-linux-videodev-h-No-such-file-or-directory" class="headerlink" title="2. mjpg_streamer.c:27:28: fatal error: linux/videodev.h: No such file or directory"></a>2. <code>mjpg_streamer.c:27:28: fatal error: linux/videodev.h: No such file or directory</code></h2><p>可能是因为内核2.6.38和以后的版本已经移除了对 v4l1 的支持，这个东西可能比较老旧了。新的头文件是 video4linux2.h;相比v4l1很多接口都变化 。<br>可以选择以前低版本内核，或者用新版本的mjpg-streamer-code-182</p>
<h2 id="3-Init-v4L2-failed-exit-fatal-n-init-VideoIn-failed"><a href="#3-Init-v4L2-failed-exit-fatal-n-init-VideoIn-failed" class="headerlink" title="3. Init v4L2 failed !! exit fatal \n init_VideoIn failed"></a>3. <code>Init v4L2 failed !! exit fatal \n init_VideoIn failed</code></h2><p>可能是由于摄像头支持YUV，而不是JPEG格式，需要修改start.sh文件</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">./mjpg_streamer -i &quot;./input_uvc.so -y&quot; -o &quot;./output_http.so -w ./www&quot; </span><br></pre></td></tr></table></figure>
<h2 id="4-获得帮助"><a href="#4-获得帮助" class="headerlink" title="4. 获得帮助"></a>4. 获得帮助</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">./mjpg_streamer -h</span><br></pre></td></tr></table></figure>]]></content>
  </entry>
  <entry>
    <title>进程以及进程间的通信</title>
    <url>/2022/10/10/%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1/</url>
    <content><![CDATA[<p>本文包含进程的介绍和使用，以及进程间的通信方式。</p>
<span id="more"></span>

<h1 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h1><h2 id="进程的概念"><a href="#进程的概念" class="headerlink" title="进程的概念"></a>进程的概念</h2><p>进程是程序的一次执行过程，进程是一个正在执行的任务，<strong>进程是分配资源的最小单位</strong>。每一个进程都会分配自己的0-3G的内存空间，0-3G的内存空间有多份，而3-4G内核空间只有一份。在这0-3G内存空间中堆区、栈区、静态区（缓冲区，文件描述符）。</p>
<p>进程其实是内核创建的，每个进程在内核空间都对应的是一个 <code>task_struct(PCB)</code> 的结构体。正在运行的进程会被放到一个运行队列中，随着时间片轮询依次来执行进程。一个进程的崩溃不会影响另外一个进程的执行，<strong>进程的安全性高</strong>。</p>
<h3 id="进程和程序的区别"><a href="#进程和程序的区别" class="headerlink" title="进程和程序的区别"></a>进程和程序的区别</h3><p><strong>程序</strong>：程序是静态的，没有生命周期的概念，它是有序的指令的集合，在硬盘上存储着</p>
<p><strong>进程</strong>：进程是程序的一次执行过程，它是由生命周期的，随着程序的执行而运行，随着程序的终止而结束，在内存上存储着。可以分配自己的0-3G的内存空间</p>
<h3 id="进程的组成"><a href="#进程的组成" class="headerlink" title="进程的组成"></a>进程的组成</h3><ul>
<li>进程控制块<code>PCB task_struct</code><br>  进程的标识符PID，进程运行的状态，进程所属的用户uid，内存空间…</li>
<li>文本段<br>  存放可执行程序本身</li>
<li>数据段<br>  存放程序运行时候产生的数据，比如int a；a就在数据段存放</li>
</ul>
<h3 id="进程的种类"><a href="#进程的种类" class="headerlink" title="进程的种类"></a>进程的种类</h3><ul>
<li><p><strong>交互进程</strong> ：交互进程是由shell维护的，通过shell和用户进行交互，例如文本编辑器就是一个交互进程。  </p>
</li>
<li><p><strong>批处理进程</strong>：批处理进程的优先级比较低，通常情况下批处理进程都会被放到队列中执行，例如gcc编译程序的过程就是批处理进程。  </p>
</li>
<li><p><strong>守护进程</strong> ：守护进程是一个后台运行的进程，随着系统的启动而启动，随着系统的终止而终止，它会脱离终端执行，例如windows上的各种服务。</p>
</li>
</ul>
<h3 id="PID"><a href="#PID" class="headerlink" title="PID"></a>PID</h3><p>PID <code>process id</code> : 进程号，在linux系统上进程都会被分配一个ID，这个ID就是进程的标号。在linux系统上所有的进程都可以在 <code>/proc</code> 目录下查看。<code>PPID</code> 是进程的父进程号。在一个系统上可以通过如下命令查看能创建的最大进程的个数：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cat</span> /proc/sys/kernel/pid_max</span><br></pre></td></tr></table></figure>
<h3 id="特殊PID的进程"><a href="#特殊PID的进程" class="headerlink" title="特殊PID的进程"></a>特殊PID的进程</h3><p><strong>0号进程 <code>idle</code></strong> : 在linux系统启动的时候最先运行的进程就是0号进程，0号进程又叫空闲进程。如果系统上没有其他进程执行那么0号进程就执行。0号进程是1号进程和2号进程的父进程</p>
<p><strong>1号进程 <code>init</code></strong> : init进程是由0号进程创建得到的，它的主要工作是系统的初始化。当初始化工作执行完之后，它主要负责回收孤儿进程的资源。</p>
<p><strong>2号进程 <code>kthreadd</code></strong> : kthreadd是有0号进程创建出来的，它主要负责调度工作（调度器进程）</p>
<h3 id="进程相关命令"><a href="#进程相关命令" class="headerlink" title="进程相关命令"></a>进程相关命令</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ps -ef <span class="comment"># 查看进程的父子关系</span></span><br><span class="line"><span class="comment"># PID:进程号</span></span><br><span class="line"><span class="comment"># PPID:父进程号</span></span><br><span class="line"><span class="comment"># TTY:如果是问号，说明没有终端与之对应</span></span><br><span class="line"><span class="comment"># CMD:进程名</span></span><br><span class="line"></span><br><span class="line">ps -ajx   <span class="comment"># 一般使用这条命令查看，查看到的进程的信息更完全</span></span><br><span class="line"><span class="comment"># PID:进程号</span></span><br><span class="line"><span class="comment"># PPID:父进程号</span></span><br><span class="line"><span class="comment"># PGID:进程组ID</span></span><br><span class="line"><span class="comment"># SID:会话ID</span></span><br><span class="line"><span class="comment"># 在linux系统上新开一个终端就会默认创建一个会话，一个会话包含多个进程组,其中进程组有分为前台进程组和后台进程组，前台进程组只有一个，后台进程组有多个。一个进程组内包含很多个进程，进程具备父子关系。</span></span><br><span class="line"><span class="comment"># TTY:如果是问号，说明没有终端与之对应</span></span><br><span class="line"><span class="comment"># TPGID:如果是-1就是守护进程</span></span><br><span class="line"></span><br><span class="line">sudo apt-get install htop</span><br><span class="line">top</span><br><span class="line">htop</span><br><span class="line"><span class="comment"># htop动态查看进程信息比top查看的更可视化一些</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">kill</span> -l <span class="comment"># 给进程发信号的命令</span></span><br><span class="line"><span class="built_in">kill</span>  -信号号  PID   <span class="comment"># 给PID进程发送信号</span></span><br><span class="line"><span class="comment"># SIGINT:打断正在执行的程序（ctrl+c）</span></span><br><span class="line"><span class="comment"># SIGKILL:杀死进程</span></span><br><span class="line"><span class="comment"># SIGSTOP:停止</span></span><br><span class="line"><span class="comment"># SIGCONT:继续</span></span><br><span class="line">    </span><br><span class="line">pidof FILE_NAME <span class="comment"># 查看进程号 pidof a.out  </span></span><br><span class="line">killall FILE_NAME <span class="comment"># 杀死有同名的进程 killall a.out</span></span><br><span class="line">        </span><br><span class="line"><span class="built_in">cat</span> /proc/sys/kernel/pid_max <span class="comment"># 查看最大进程号的命令</span></span><br></pre></td></tr></table></figure>

<h3 id="进程的状态"><a href="#进程的状态" class="headerlink" title="进程的状态"></a>进程的状态</h3><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="bullet">1.</span> 进程的状态</span><br><span class="line"><span class="bullet">    *</span> D    不可中断的等待态（sleep，不可被信号打断）</span><br><span class="line"><span class="bullet">    *</span> R    运行状态</span><br><span class="line"><span class="bullet">    *</span> S    可中断的等待态（sleep,可被信号打断）</span><br><span class="line"><span class="bullet">    *</span> T    停止状态</span><br><span class="line"><span class="bullet">    *</span> X    死亡状态</span><br><span class="line"><span class="bullet">    *</span> Z    僵尸态</span><br><span class="line"><span class="bullet">    *</span> I    空闲态</span><br><span class="line"></span><br><span class="line"><span class="bullet">2.</span> 进程的附加态</span><br><span class="line"><span class="bullet">    *</span> &lt;    高优先级进程</span><br><span class="line"><span class="bullet">    *</span> N    低优先级进程</span><br><span class="line"><span class="bullet">    *</span> L    锁在内存上</span><br><span class="line"><span class="bullet">    *</span> s    会话组组长</span><br><span class="line"><span class="bullet">    *</span> l    包含多线程</span><br><span class="line"><span class="bullet">    *</span> +    前台进程</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>孤儿进程</strong> ：一个进程的父进程死亡，此时当前的进程就是孤儿进程，孤儿进程被init收养</p>
<p><strong>僵尸态进程</strong> ：如果一个进程结束，父进程没有为它收尸，此时当前的进程就是僵尸进程。</p>
</blockquote>
<h3 id="进程状态切换实例"><a href="#进程状态切换实例" class="headerlink" title="进程状态切换实例"></a>进程状态切换实例</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;head.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc,<span class="type">const</span> <span class="type">char</span> * argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">./a.out <span class="comment"># 运行上述程序程序状态（前台休眠）</span></span><br><span class="line">ps -ajx | grep a.out <span class="comment"># 查看进程状态</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># ctrl + z  # 将进程变为停止态</span></span><br><span class="line">ps -ajx | grep a.out <span class="comment"># 查看进程状态</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">jobs</span> -l <span class="comment"># 查看状态</span></span><br><span class="line"><span class="built_in">bg</span> 1 <span class="comment"># 将停止态的进程变为后台休眠态</span></span><br><span class="line">ps -ajx | grep a.out <span class="comment"># 查看进程状态</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">fg</span> 1 <span class="comment"># 将后台休眠态的进程变为前台休眠态</span></span><br><span class="line">ps -ajx | grep a.out <span class="comment"># 查看进程状态</span></span><br></pre></td></tr></table></figure>

<h2 id="进程的创建及特点"><a href="#进程的创建及特点" class="headerlink" title="进程的创建及特点"></a>进程的创建及特点</h2><h3 id="如何创建进行"><a href="#如何创建进行" class="headerlink" title="如何创建进行"></a>如何创建进行</h3><p>进程的创建是拷贝父进程得到的，通过拷贝过程更容易得到子进程，并且能够标识进程的父子状态。</p>
<h3 id="创建进程的API"><a href="#创建进程的API" class="headerlink" title="创建进程的API"></a>创建进程的API</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">pid_t</span> <span class="title function_">fork</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="comment">// 功能：创建一个子进程</span></span><br><span class="line"><span class="comment">// 参数：</span></span><br><span class="line"><span class="comment">//     @无</span></span><br><span class="line"><span class="comment">// 返回值：成功父进程收到子进程的PID，子进程收到0</span></span><br><span class="line"><span class="comment">//     	  失败父进程收到-1，并置位错误码</span></span><br></pre></td></tr></table></figure>

<h3 id="创建进程的实例"><a href="#创建进程的实例" class="headerlink" title="创建进程的实例"></a>创建进程的实例</h3><p>创建一个子进程，不关注返回值</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;head.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span>* argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    fork();    <span class="comment">// 创建一个子进程</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>); <span class="comment">// 父子进程都在执行while(1);</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="创建进程的实例-1"><a href="#创建进程的实例-1" class="headerlink" title="创建进程的实例"></a>创建进程的实例</h3><p>创建多个子进程，不关注返回值</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;head.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span>* argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">        fork(); <span class="comment">// 创建一个子进程</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>  按照上述的写法：<code>fork n</code> 次就产生了 <code>2^n</code> 个进程</p>
</blockquote>
<p>可以分次总体的理解上述程序的执行过程</p>
<p><img src="/../image/fork1.png" alt="fork 1"></p>
<p>也可以按照父子关系理解上述程序的执行过程</p>
<p><img src="/../image/fork2.png" alt="fork 2"></p>
<h3 id="fork-和-缓冲区-结合问题"><a href="#fork-和-缓冲区-结合问题" class="headerlink" title="fork 和 缓冲区 结合问题"></a><code>fork</code> 和 <strong>缓冲区</strong> 结合问题</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;head.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span>* argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; i++) &#123;</span><br><span class="line">        fork(); </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;-&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述程序会打印8个 <code>-</code>。</p>
<p>原因是上述程序printf没有刷新缓冲区，所以在fork进程的时候，会将父进程缓冲区的内容也fork过来，所以最终打印了8个’-‘</p>
<h3 id="关注-fork-返回值"><a href="#关注-fork-返回值" class="headerlink" title="关注 fork 返回值"></a>关注 <code>fork</code> 返回值</h3><p><code>fork</code> 的返回值是区分父子进程的关键</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;head.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc,<span class="type">const</span> <span class="type">char</span> * argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">pid_t</span> pid;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//关注返回值可以让父子进程执行不同的代码区</span></span><br><span class="line">    pid = fork();</span><br><span class="line">    <span class="keyword">if</span>(pid == <span class="number">-1</span>)&#123;</span><br><span class="line">        PRINT_ERR(<span class="string">&quot;fork error&quot;</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(pid == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="comment">//子进程代码区</span></span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="comment">//父进程代码区</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="父子进程执行先后顺序"><a href="#父子进程执行先后顺序" class="headerlink" title="父子进程执行先后顺序"></a>父子进程执行先后顺序</h3><p>父子进程执行没有先后顺序，时间片轮询，上下文切换。</p>
<h3 id="父子进程内存空间问题"><a href="#父子进程内存空间问题" class="headerlink" title="父子进程内存空间问题"></a>父子进程内存空间问题</h3><p>在fork前父进程中所有的变量多被拷贝到了子进程中，在子进程中打印的变量的虚拟地址和父进程一样，但是两者在物理地址上一定是不同的，所以在子进程内修改变量的值，父进程中变量不会改变。父子进程内存空间相互独立。</p>
<p><strong>写时拷贝</strong> <code>cow（copy on write）</code><br>在使用fork产生子进程的时候，此时父子进程共用同一块物理内存，但是在子进程或者父进程中尝试修改a变量的时候，此时就会分配一块新的物理内存，此时父子进程a变量虚拟内存相同，但是对应的物理内存不同。</p>
<h3 id="多进程练习"><a href="#多进程练习" class="headerlink" title="多进程练习"></a>多进程练习</h3><p>使用两个进程拷贝同一个文件，父进程拷贝文件的前一半，子进程拷贝文件的后一半。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">./a.out srcfile destfile</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;head.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">get_file_len</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* file)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> fd, len;</span><br><span class="line">    <span class="keyword">if</span> ((fd = open(file, O_RDONLY)) == <span class="number">-1</span>)</span><br><span class="line">        PRINT_ERR(<span class="string">&quot;open error&quot;</span>);</span><br><span class="line">    len = lseek(fd, <span class="number">0</span>, SEEK_END);</span><br><span class="line">    close(fd);</span><br><span class="line">    <span class="keyword">return</span> len;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">init_src_file</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* file)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> fd;</span><br><span class="line">    <span class="keyword">if</span> ((fd = open(file, O_WRONLY | O_CREAT | O_TRUNC, <span class="number">0666</span>)) == <span class="number">-1</span>)</span><br><span class="line">        PRINT_ERR(<span class="string">&quot;open error&quot;</span>);</span><br><span class="line"></span><br><span class="line">    close(fd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">copy_file</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* src, <span class="type">const</span> <span class="type">char</span>* dest, <span class="type">int</span> start, <span class="type">int</span> len)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> s[<span class="number">20</span>];</span><br><span class="line">    <span class="type">int</span> fd1, fd2;</span><br><span class="line">    <span class="type">int</span> ret, count = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 1.以只读方式打开源文件，以只写方式打开目标文件</span></span><br><span class="line">    <span class="keyword">if</span> ((fd1 = open(src, O_RDONLY)) == <span class="number">-1</span>)</span><br><span class="line">        PRINT_ERR(<span class="string">&quot;open src error&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> ((fd2 = open(dest, O_WRONLY)) == <span class="number">-1</span>)</span><br><span class="line">        PRINT_ERR(<span class="string">&quot;open dest error&quot;</span>);</span><br><span class="line">    <span class="comment">// 2.定位源和目标文件的光标</span></span><br><span class="line">    lseek(fd1, start, SEEK_SET);</span><br><span class="line">    lseek(fd2, start, SEEK_SET);</span><br><span class="line">    <span class="comment">// 3.循环拷贝</span></span><br><span class="line">    <span class="comment">// while (1) &#123;</span></span><br><span class="line">    <span class="comment">//     ret = read(fd1, s, sizeof(s)); // 从源文件中读</span></span><br><span class="line">    <span class="comment">//     count += ret; // 将每次读的数据加到count中</span></span><br><span class="line">    <span class="comment">//     if (count &gt;= len) &#123;</span></span><br><span class="line">    <span class="comment">//         write(fd2, s, (ret - (count - len)));</span></span><br><span class="line">    <span class="comment">//         break;</span></span><br><span class="line">    <span class="comment">//     &#125;</span></span><br><span class="line">    <span class="comment">//     write(fd2, s, ret);</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line">    <span class="keyword">while</span> (count &lt; len) &#123;</span><br><span class="line">        ret = read(fd1, s, <span class="keyword">sizeof</span>(s)); <span class="comment">// 从源文件中读</span></span><br><span class="line">        count += ret; <span class="comment">// 将每次读的数据加到count中</span></span><br><span class="line">        write(fd2, s, ret);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 4.关闭文件</span></span><br><span class="line">    close(fd1);</span><br><span class="line">    close(fd2);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span>* argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> len;</span><br><span class="line">    <span class="type">pid_t</span> pid;</span><br><span class="line">    <span class="comment">// 1.检查参数个数</span></span><br><span class="line">    <span class="keyword">if</span> (argc != <span class="number">3</span>) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;input error,try again\n&quot;</span>);</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;usage:./a.out srcfile destfile\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 2.获取源文件大小</span></span><br><span class="line">    len = get_file_len(argv[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3.创建出目标文件，并清空</span></span><br><span class="line">    init_src_file(argv[<span class="number">2</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4.fork进程，拷贝文件</span></span><br><span class="line">    <span class="keyword">if</span> ((pid = fork()) == <span class="number">-1</span>) &#123;</span><br><span class="line">        PRINT_ERR(<span class="string">&quot;fork error&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (pid == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 子进程</span></span><br><span class="line">        copy_file(argv[<span class="number">1</span>], argv[<span class="number">2</span>], len / <span class="number">2</span>, (len - len / <span class="number">2</span>));</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 父进程</span></span><br><span class="line">        copy_file(argv[<span class="number">1</span>], argv[<span class="number">2</span>], <span class="number">0</span>, len / <span class="number">2</span>);</span><br><span class="line">        wait(<span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>父子进程光标问题</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;head.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span>* argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">pid_t</span> pid;</span><br><span class="line">    <span class="type">int</span> fd;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果文件是在fork前打开的，此时父子进程共用同一个光标，如果在父进程修改光标，子进程会受到影响。</span></span><br><span class="line">    <span class="comment">// 如果不想让两个进程共用光标，可以在两个进程内分别打开。</span></span><br><span class="line">    <span class="keyword">if</span>((fd = open(<span class="string">&quot;./hello.txt&quot;</span>,O_RDWR))==<span class="number">-1</span>)</span><br><span class="line">        PRINT_ERR(<span class="string">&quot;open error&quot;</span>);</span><br><span class="line"></span><br><span class="line">    pid = fork();</span><br><span class="line">    <span class="keyword">if</span> (pid == <span class="number">-1</span>) &#123;</span><br><span class="line">        PRINT_ERR(<span class="string">&quot;fork error&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (pid == <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="comment">// 子进程</span></span><br><span class="line">      lseek(fd,<span class="number">5</span>,SEEK_SET);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">//父进程</span></span><br><span class="line">      sleep(<span class="number">1</span>);</span><br><span class="line">      <span class="type">char</span> ch;</span><br><span class="line">      read(fd,&amp;ch,<span class="number">1</span>);</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;ch = %c\n&quot;</span>,ch);</span><br><span class="line">    &#125;</span><br><span class="line">    close(fd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="进程相关的API接口"><a href="#进程相关的API接口" class="headerlink" title="进程相关的API接口"></a>进程相关的API接口</h2><h3 id="getpid-getppid-函数"><a href="#getpid-getppid-函数" class="headerlink" title="getpid getppid 函数"></a><code>getpid</code> <code>getppid</code> 函数</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">pid_t</span> <span class="title function_">getpid</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="comment">// 功能：获取当前进程进程号</span></span><br><span class="line"></span><br><span class="line"><span class="type">pid_t</span> <span class="title function_">getppid</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="comment">// 功能：获取父进程进程号</span></span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;head.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span>* argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">pid_t</span> pid;</span><br><span class="line">    <span class="comment">// 关注返回值可以让父子进程执行不同的代码区</span></span><br><span class="line">    pid = fork();</span><br><span class="line">    <span class="keyword">if</span> (pid == <span class="number">-1</span>) &#123;</span><br><span class="line">        PRINT_ERR(<span class="string">&quot;fork error&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (pid == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 子进程代码区</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;child:pid = %d,ppid = %d\n&quot;</span>,getpid(),getppid());</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 父进程代码区</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;parent:pid = %d,ppid = %d,cpid = %d\n&quot;</span>,getpid(),getppid(),pid);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="exit-exit-函数"><a href="#exit-exit-函数" class="headerlink" title="exit _exit 函数"></a><code>exit</code> <code>_exit</code> 函数</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">exit</span><span class="params">(<span class="type">int</span> status)</span>;</span><br><span class="line"><span class="comment">// 功能：结束进程，它是库函数，当使用exit结束进程时会刷新缓冲区</span></span><br><span class="line"><span class="comment">// 参数：</span></span><br><span class="line"><span class="comment">//     @status:进程退出的状态值 [0-255]</span></span><br><span class="line"><span class="comment">//         EXIT_SUCCESS (0)</span></span><br><span class="line"><span class="comment">//     	EXIT_FAILURE (1)</span></span><br><span class="line"><span class="comment">// 返回值：无</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> _exit(<span class="type">int</span> status);</span><br><span class="line"><span class="comment">// 功能：结束进程，它是系统调用，当使用_exit结束进程时不会刷新缓冲区</span></span><br><span class="line"><span class="comment">// 参数：</span></span><br><span class="line"><span class="comment">//     @status:进程退出的状态值 [0-255]</span></span><br><span class="line"><span class="comment">//         EXIT_SUCCESS (0)</span></span><br><span class="line"><span class="comment">//     	EXIT_FAILURE (1)</span></span><br><span class="line"><span class="comment">// 返回值：无</span></span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;head.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">func</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;111111111\n&quot;</span>); <span class="comment">//打印</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;2222222222&quot;</span>);  <span class="comment">//打印</span></span><br><span class="line">    <span class="built_in">exit</span>(EXIT_SUCCESS);    <span class="comment">//进程退出，子进程变成了僵尸进程</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;3333333333\n&quot;</span>);<span class="comment">//不会执行</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span>* argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">pid_t</span> pid;</span><br><span class="line">    <span class="comment">// 关注返回值可以让父子进程执行不同的代码区</span></span><br><span class="line">    pid = fork();</span><br><span class="line">    <span class="keyword">if</span> (pid == <span class="number">-1</span>) &#123;</span><br><span class="line">        PRINT_ERR(<span class="string">&quot;fork error&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (pid == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 子进程代码区</span></span><br><span class="line">        func();</span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>); <span class="comment">//不会执行</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 父进程代码区</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;head.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">func</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;111111111\n&quot;</span>); <span class="comment">//打印</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;2222222222&quot;</span>);  <span class="comment">//执行了，但是不会打印到终端，因为没刷新缓冲区</span></span><br><span class="line">    _exit(EXIT_SUCCESS);   <span class="comment">//退出进程，进程变成僵尸进程</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;3333333333\n&quot;</span>);<span class="comment">//没有执行</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span>* argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">pid_t</span> pid;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 关注返回值可以让父子进程执行不同的代码区</span></span><br><span class="line">    pid = fork();</span><br><span class="line">    <span class="keyword">if</span> (pid == <span class="number">-1</span>) &#123;</span><br><span class="line">        PRINT_ERR(<span class="string">&quot;fork error&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (pid == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 子进程代码区</span></span><br><span class="line">        func();</span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>); <span class="comment">//没有执行</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 父进程代码区</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="wait-waitpid-函数"><a href="#wait-waitpid-函数" class="headerlink" title="wait waitpid 函数"></a><code>wait</code> <code>waitpid</code> 函数</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">pid_t</span> <span class="title function_">wait</span><span class="params">(<span class="type">int</span> *wstatus)</span>;</span><br><span class="line"><span class="comment">// 功能：在父进程中调用wait回收子进程的资源（阻塞等待子进程结束）</span></span><br><span class="line"><span class="comment">// 参数：</span></span><br><span class="line"><span class="comment">//     @wstatus:接收到子进程_exit/exit退出的状态值</span></span><br><span class="line"><span class="comment">// 返回值：成功返回回收掉资源的进程号，失败返回-1，置位错误码</span></span><br><span class="line"></span><br><span class="line">wait(<span class="literal">NULL</span>); <span class="comment">//回收子进程的资源，但不关注子进程退出状态</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> wstatus;</span><br><span class="line">wait(&amp;wstatus);</span><br><span class="line"><span class="comment">// WIFEXITED(wstatus):      如果进程遇到exit/_exit/return正常退出，这个宏返回真</span></span><br><span class="line"><span class="comment">// WEXITSTATUS(wstatus)：   获取wstatus中bit8-bit15这8个bit，代表子进程退出的状态</span></span><br><span class="line"><span class="comment">// WIFSIGNALED(wstatus)：   如果是信号导致进程退出，这个宏返回真</span></span><br><span class="line"><span class="comment">// WTERMSIG(wstatus)：      获取信号号，信号号对应的是wstatus中bit0-bit6这7个bit位</span></span><br><span class="line">    </span><br><span class="line"><span class="type">pid_t</span> <span class="title function_">waitpid</span><span class="params">(<span class="type">pid_t</span> pid, <span class="type">int</span> *wstatus, <span class="type">int</span> options)</span>;</span><br><span class="line"><span class="comment">// 功能：指定回收pid号进程的资源</span></span><br><span class="line"><span class="comment">// 参数：</span></span><br><span class="line"><span class="comment">//     @pid:进程号</span></span><br><span class="line"><span class="comment">//        &lt; -1   回收pid绝对值同组的任意的子进程的资源</span></span><br><span class="line"><span class="comment">//        -1     回收任意子进程的资源</span></span><br><span class="line"><span class="comment">//        0      回收和调用进程同组的子进程的资源</span></span><br><span class="line"><span class="comment">//        &gt; 0    表示回收pid对应的子进程的资源</span></span><br><span class="line"><span class="comment">// 	@wstatus:收到调用的子进程退出的状态</span></span><br><span class="line"><span class="comment">// 	@options: </span></span><br><span class="line"><span class="comment">// 			0        :阻塞回收</span></span><br><span class="line"><span class="comment">// 			WNOHANG  :非阻塞回收</span></span><br><span class="line"><span class="comment">// 返回值：成功返回回收掉的子进程的pid</span></span><br><span class="line"><span class="comment">//        	如果是非阻塞，没有回收掉子进程返回0</span></span><br><span class="line"><span class="comment">//         如果失败返回-1置位错误码</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// wait(NULL)     === 等价于 == waitpid(-1,NULL,0)</span></span><br><span class="line"><span class="comment">// wait(&amp;wstatus) === 等价于 == waitpid(-1,&amp;wstatus,0)</span></span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;head.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">func</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;111111111\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;2222222222&quot;</span>);</span><br><span class="line">    <span class="comment">// while(1);</span></span><br><span class="line">    _exit(<span class="number">34</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;3333333333\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span>* argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">pid_t</span> pid;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 关注返回值可以让父子进程执行不同的代码区</span></span><br><span class="line">    pid = fork();</span><br><span class="line">    <span class="keyword">if</span> (pid == <span class="number">-1</span>) &#123;</span><br><span class="line">        PRINT_ERR(<span class="string">&quot;fork error&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (pid == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 子进程代码区</span></span><br><span class="line">        func();</span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 父进程代码区</span></span><br><span class="line">        <span class="type">int</span> wstatus;</span><br><span class="line">        <span class="type">pid_t</span> pid1;</span><br><span class="line">        <span class="keyword">if</span>((pid1 = wait(&amp;wstatus))==<span class="number">-1</span>)</span><br><span class="line">            PRINT_ERR(<span class="string">&quot;wait error&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;pid = %d,pid1 = %d\n&quot;</span>,pid,pid1);</span><br><span class="line">        <span class="keyword">if</span>(WIFEXITED(wstatus))&#123; <span class="comment">//如果为真是正常退出的 </span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;status = %d\n&quot;</span>,WEXITSTATUS(wstatus));<span class="comment">//获取wstatus中bit8-bit15</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(WIFSIGNALED(wstatus))&#123;<span class="comment">//信号导致子进程退出</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;signo = %d\n&quot;</span>, WTERMSIG(wstatus)); <span class="comment">//获取wstatus中bit0-bit6</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>waitpid函数实例</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;head.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">func</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;111111111\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;2222222222&quot;</span>);</span><br><span class="line">    sleep(<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;我是第一个子进程\n&quot;</span>);</span><br><span class="line">    <span class="comment">// while (1);</span></span><br><span class="line">    _exit(<span class="number">34</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;3333333333\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span>* argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">pid_t</span> pid;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 关注返回值可以让父子进程执行不同的代码区</span></span><br><span class="line">    pid = fork();</span><br><span class="line">    <span class="keyword">if</span> (pid == <span class="number">-1</span>) &#123;</span><br><span class="line">        PRINT_ERR(<span class="string">&quot;fork error&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (pid == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 子进程代码区</span></span><br><span class="line">        func();</span><br><span class="line">        <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">            ;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="type">pid_t</span> pid1;</span><br><span class="line">        <span class="keyword">if</span> ((pid1 = fork()) == <span class="number">-1</span>) &#123;</span><br><span class="line">            PRINT_ERR(<span class="string">&quot;fork error&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (pid1 == <span class="number">0</span>) &#123;</span><br><span class="line">            sleep(<span class="number">1</span>);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;我是第二个子进程\n&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 父进程代码区</span></span><br><span class="line">        <span class="type">int</span> wstatus;</span><br><span class="line">        <span class="type">pid_t</span> pid2;</span><br><span class="line">        <span class="keyword">if</span> ((pid2 = waitpid(<span class="number">-1</span>, &amp;wstatus, WNOHANG)) == <span class="number">-1</span>)</span><br><span class="line">            PRINT_ERR(<span class="string">&quot;wait error&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;pid = %d,pid2 = %d\n&quot;</span>, pid, pid2);</span><br><span class="line">        <span class="keyword">if</span> (WIFEXITED(wstatus)) &#123; <span class="comment">// 如果为真是正常退出的 ,bit8-bit15</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;status = %d\n&quot;</span>, WEXITSTATUS(wstatus));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (WIFSIGNALED(wstatus)) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;signo = %d\n&quot;</span>, WTERMSIG(wstatus)); <span class="comment">// bit0-bit6</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="进程间的通信"><a href="#进程间的通信" class="headerlink" title="进程间的通信"></a>进程间的通信</h1><h2 id="进程间通信方式简介"><a href="#进程间通信方式简介" class="headerlink" title="进程间通信方式简介"></a>进程间通信方式简介</h2><p>在linux系统上常用的进程间通信方式有如下7种：</p>
<ul>
<li>传统进程间通信<ul>
<li>无名管道</li>
<li>有名管道</li>
<li>信号</li>
</ul>
</li>
<li>System V IPC进程间通信<ul>
<li>消息队列</li>
<li>共享内存</li>
<li>信号量（信号灯集）</li>
</ul>
</li>
<li>BSD(伯克利分校)基于网络的进程间通信<ul>
<li><code>socket</code> 实现进程间通信</li>
</ul>
</li>
</ul>
<h2 id="无名管道"><a href="#无名管道" class="headerlink" title="无名管道"></a>无名管道</h2><h3 id="无名管道通信原理"><a href="#无名管道通信原理" class="headerlink" title="无名管道通信原理"></a>无名管道通信原理</h3><p>如果A和B进程想要通过无名管道通信，那就必须在内核空间创建一个无名管道 <strong>（64K）</strong>, A和B进程必须是亲缘关系的进程，A进程向管道的一端写数据，B进程可以从管道的另外一端读数据。在A进程和B进程进行数据传输的时候是不允许使用 <code>lseek</code> 函数的。无名管道是 <strong>半双工</strong> 的通信方式。<br>如果A进程一直向管道中写数据写满 <code>64K</code> 的时候A进程阻塞，直到B进程读一部分数据之后A才能继续写。<br>如果B进程在读数据的时候，无名管道是空的，B进程阻塞。</p>
<h3 id="无名管道的API"><a href="#无名管道的API" class="headerlink" title="无名管道的API"></a>无名管道的API</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">pipe</span><span class="params">(<span class="type">int</span> pipefd[<span class="number">2</span>])</span>; </span><br><span class="line"><span class="comment">// 功能：创建一个无名管道</span></span><br><span class="line"><span class="comment">// 参数：</span></span><br><span class="line"><span class="comment">//     @pipefd:返回管道的两端</span></span><br><span class="line"><span class="comment">//         	pipefd[1]:写端</span></span><br><span class="line"><span class="comment">//         	pipefd[0]:读端</span></span><br><span class="line"><span class="comment">// 返回值：成功返回0，失败返回-1置位错误码</span></span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;head.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span>* argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">pid_t</span> pid;</span><br><span class="line">    <span class="type">int</span> pipefd[<span class="number">2</span>];</span><br><span class="line">    <span class="type">char</span> s[<span class="number">128</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    <span class="comment">// 1.创建无名管道</span></span><br><span class="line">    <span class="keyword">if</span> (pipe(pipefd))</span><br><span class="line">        PRINT_ERR(<span class="string">&quot;pipe error&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2.创建父子进程</span></span><br><span class="line">    <span class="keyword">if</span> ((pid = fork()) == <span class="number">-1</span>) &#123;</span><br><span class="line">        PRINT_ERR(<span class="string">&quot;fork error&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (pid == <span class="number">0</span>) &#123;</span><br><span class="line">        close(pipefd[<span class="number">1</span>]); <span class="comment">// 关闭子进程的写端</span></span><br><span class="line">        <span class="comment">// 子进程</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="comment">// 清空s</span></span><br><span class="line">            <span class="built_in">memset</span>(s,<span class="number">0</span>,<span class="keyword">sizeof</span>(s));</span><br><span class="line">            <span class="comment">// 从管道向s中读数据</span></span><br><span class="line">            read(pipefd[<span class="number">0</span>], s, <span class="keyword">sizeof</span>(s));</span><br><span class="line">            <span class="comment">// 如果读到的是quit就退出</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">strcmp</span>(s, <span class="string">&quot;quit&quot;</span>) == <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="comment">// 将读取到的数据打印到终端上</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, s);</span><br><span class="line">        &#125;</span><br><span class="line">        close(pipefd[<span class="number">0</span>]);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_SUCCESS);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        close(pipefd[<span class="number">0</span>]); <span class="comment">// 关闭父进程的读端</span></span><br><span class="line">        <span class="comment">// 父进程</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="comment">// 从终端向s数组读取字符串</span></span><br><span class="line">            fgets(s, <span class="keyword">sizeof</span>(s), <span class="built_in">stdin</span>);</span><br><span class="line">            <span class="comment">// 清除换行符</span></span><br><span class="line">            <span class="keyword">if</span> (s[<span class="built_in">strlen</span>(s) - <span class="number">1</span>] == <span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">                s[<span class="built_in">strlen</span>(s) - <span class="number">1</span>] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">            <span class="comment">// 向管道中写数据</span></span><br><span class="line">            write(pipefd[<span class="number">1</span>], s, <span class="built_in">strlen</span>(s));</span><br><span class="line">            <span class="comment">// 如果输入的是quit让进程退出</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">strcmp</span>(s, <span class="string">&quot;quit&quot;</span>) == <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        close(pipefd[<span class="number">1</span>]);</span><br><span class="line">        <span class="comment">//等待回收子进程的资源</span></span><br><span class="line">        wait(<span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="无名管道通信特点"><a href="#无名管道通信特点" class="headerlink" title="无名管道通信特点"></a>无名管道通信特点</h3><p><strong>读端存在写管道</strong>：有多少写多少，直到写满（64K）为止，写阻塞</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;head.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span>* argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> pipefd[<span class="number">2</span>];</span><br><span class="line">    <span class="type">char</span> s[<span class="number">128</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1.创建无名管道</span></span><br><span class="line">    <span class="keyword">if</span> (pipe(pipefd))</span><br><span class="line">        PRINT_ERR(<span class="string">&quot;pipe error&quot;</span>);</span><br><span class="line">    <span class="comment">// 2.读端存在，但是没有读数据，写管道</span></span><br><span class="line">    <span class="comment">// 管道的大小是64K(65536),如果写65536个字节，写没有阻塞，printf(&quot;1111111...&quot;)会打印</span></span><br><span class="line">    <span class="comment">// 如果将循环的次数改为65537的时候，最后一次写，写阻塞，所以printf(&quot;11111...&quot;)不会打印</span></span><br><span class="line">    <span class="comment">// 说明写满了</span></span><br><span class="line">    <span class="type">char</span> ch=<span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">65537</span>;i++)&#123;</span><br><span class="line">        write(pipefd[<span class="number">1</span>],&amp;ch,<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;11111111111111111111111111\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>读端不存在写管道</strong>：管道破裂，进程收到SIGPIPE信号，进程退出</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;head.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span>* argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> pipefd[<span class="number">2</span>];</span><br><span class="line">    <span class="type">char</span> s[<span class="number">128</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1.创建无名管道</span></span><br><span class="line">    <span class="keyword">if</span> (pipe(pipefd))</span><br><span class="line">        PRINT_ERR(<span class="string">&quot;pipe error&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    close(pipefd[<span class="number">0</span>]); <span class="comment">//关闭读端</span></span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> ch=<span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">    <span class="comment">//关闭读端，写管道，管道破裂，操作系统给当前进程发送SIGPIPE，</span></span><br><span class="line">    <span class="comment">// 将当前进程杀死</span></span><br><span class="line">    write(pipefd[<span class="number">1</span>],&amp;ch,<span class="number">1</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>写端存在读管道</strong>：管道中有多少字节的数据就能读多少数据，如果没有数据的时候，读阻塞</p>
<p><strong>写端不存在端管道</strong>：管道中有多少字节的数据就能读多少数据，如果没有数据的时候，读立即返回</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;head.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span>* argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> pipefd[<span class="number">2</span>];</span><br><span class="line">    <span class="type">char</span> s[<span class="number">128</span>] = <span class="string">&quot;i am test pipe func...\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1.创建无名管道</span></span><br><span class="line">    <span class="keyword">if</span> (pipe(pipefd))</span><br><span class="line">        PRINT_ERR(<span class="string">&quot;pipe error&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    write(pipefd[<span class="number">1</span>],s,<span class="built_in">strlen</span>(s));</span><br><span class="line"></span><br><span class="line">    close(pipefd[<span class="number">1</span>]); <span class="comment">//关闭写端</span></span><br><span class="line">    </span><br><span class="line">    <span class="type">char</span> ch;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        read(pipefd[<span class="number">0</span>],&amp;ch,<span class="number">1</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;ch = %c\n&quot;</span>,ch);</span><br><span class="line">        usleep(<span class="number">100000</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>总结</strong>: </p>
<ul>
<li><strong>读端存在写管道</strong>：有多少写多少，直到写满（64K）为止，写阻塞</li>
<li><strong>读端不存在写管道</strong>：管道破裂，进程收到SIGPIPE信号，进程退出</li>
<li><strong>写端存在读管道</strong>：管道中有多少字节的数据就能读多少数据，如果没有数据的时候，读阻塞</li>
<li><strong>写端不存在读管道</strong>：管道中有多少字节的数据就能读多少数据，如果没有数据的时候，读立即返回</li>
</ul>
<h2 id="有名管道"><a href="#有名管道" class="headerlink" title="有名管道"></a>有名管道</h2><h3 id="有名管道通信原理"><a href="#有名管道通信原理" class="headerlink" title="有名管道通信原理"></a>有名管道通信原理</h3><p>有名管道可以实现任意进程间的通信，有名管道的大小也是 <code>64K</code>，有名管道也是不支持 <code>lseek</code>,有名管道也是 <strong>半双工</strong> 的通信方式。有名管道创建之后会在 <strong>用户空间产生一个管道文件</strong>，这个管道文件是在内存上存储的。<br>如果A和B两个进程想要通过有名管道通信，就打开管道文件，向管道中写向管道中读就可</p>
<h3 id="有名管道的API"><a href="#有名管道的API" class="headerlink" title="有名管道的API"></a>有名管道的API</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">mkfifo</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *pathname, <span class="type">mode_t</span> mode)</span>;</span><br><span class="line"><span class="comment">// 功能：创建有名管道</span></span><br><span class="line"><span class="comment">// 参数：</span></span><br><span class="line"><span class="comment">//     @pathname:管道文件的路径及名字</span></span><br><span class="line"><span class="comment">// 	@mode:管道文件的操作权限(mode &amp; ~umask)</span></span><br><span class="line"><span class="comment">// 返回值：成功返回0，失败返回-1置位错误码</span></span><br></pre></td></tr></table></figure>
<p>01mkfifo.c</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;head.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FIFO_NAME <span class="string">&quot;./myfifo&quot;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc,<span class="type">const</span> <span class="type">char</span> * argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 1.创建管道</span></span><br><span class="line">    <span class="keyword">if</span>(mkfifo(FIFO_NAME,<span class="number">0666</span>))</span><br><span class="line">        PRINT_ERR(<span class="string">&quot;mkfifo error&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2.等待用户使用</span></span><br><span class="line">    getchar();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3.销毁管道</span></span><br><span class="line">    <span class="type">char</span> s[<span class="number">50</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="built_in">snprintf</span>(s,<span class="keyword">sizeof</span>(s),<span class="string">&quot;rm -rf %s&quot;</span>,FIFO_NAME);</span><br><span class="line">    system(s);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>02write.c</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;head.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FIFO_NAME <span class="string">&quot;./myfifo&quot;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span>* argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> fd;</span><br><span class="line">    <span class="type">char</span> s[<span class="number">128</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    <span class="keyword">if</span> ((fd = open(FIFO_NAME, O_WRONLY)) == <span class="number">-1</span>)</span><br><span class="line">        PRINT_ERR(<span class="string">&quot;open error&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;input &gt; &quot;</span>);</span><br><span class="line">        <span class="comment">// 从终端向s数组读取字符串</span></span><br><span class="line">        fgets(s, <span class="keyword">sizeof</span>(s), <span class="built_in">stdin</span>);</span><br><span class="line">        <span class="comment">// 清除换行符</span></span><br><span class="line">        <span class="keyword">if</span> (s[<span class="built_in">strlen</span>(s) - <span class="number">1</span>] == <span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">            s[<span class="built_in">strlen</span>(s) - <span class="number">1</span>] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">        <span class="comment">// 向管道中写数据</span></span><br><span class="line">        write(fd, s, <span class="built_in">strlen</span>(s));</span><br><span class="line">        <span class="comment">// 如果输入的是quit让进程退出</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">strcmp</span>(s, <span class="string">&quot;quit&quot;</span>) == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    close(fd);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>03read.c</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;head.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FIFO_NAME <span class="string">&quot;./myfifo&quot;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span>* argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> fd;</span><br><span class="line">    <span class="type">char</span> s[<span class="number">128</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    <span class="keyword">if</span> ((fd = open(FIFO_NAME, O_RDONLY)) == <span class="number">-1</span>)</span><br><span class="line">        PRINT_ERR(<span class="string">&quot;open error&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="built_in">memset</span>(s, <span class="number">0</span>, <span class="keyword">sizeof</span>(s));</span><br><span class="line">        read(fd, s, <span class="keyword">sizeof</span>(s));</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;s = %s\n&quot;</span>, s);</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">strcmp</span>(s, <span class="string">&quot;quit&quot;</span>) == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    close(fd);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="有名管道的练习"><a href="#有名管道的练习" class="headerlink" title="有名管道的练习"></a>有名管道的练习</h3><p>使用有名管道传输文件，<br>A进程读文件，将文件中的内容写入到管道中<br>B进程读取管道，将管道中的数据写入到新文件中。</p>
<p>01mkfifo.c</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;head.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FIFO_NAME <span class="string">&quot;./myfifo&quot;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc,<span class="type">const</span> <span class="type">char</span> * argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 1.创建管道</span></span><br><span class="line">    <span class="keyword">if</span>(mkfifo(FIFO_NAME,<span class="number">0666</span>))</span><br><span class="line">        PRINT_ERR(<span class="string">&quot;mkfifo error&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2.等待用户使用</span></span><br><span class="line">    getchar();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3.销毁管道</span></span><br><span class="line">    <span class="type">char</span> s[<span class="number">50</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="built_in">snprintf</span>(s,<span class="keyword">sizeof</span>(s),<span class="string">&quot;rm -rf %s&quot;</span>,FIFO_NAME);</span><br><span class="line">    system(s);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>02write.c</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;head.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FIFO_NAME <span class="string">&quot;./myfifo&quot;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span>* argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> fd1, fd2, ret;</span><br><span class="line">    <span class="type">char</span> s[<span class="number">128</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    <span class="comment">// 校验参数</span></span><br><span class="line">    <span class="keyword">if</span> (argc != <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;input error,try again\n&quot;</span>);</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;usgage: ./a.out srcfile\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 打开源文件</span></span><br><span class="line">    <span class="keyword">if</span> ((fd1 = open(argv[<span class="number">1</span>], O_RDONLY)) == <span class="number">-1</span>)</span><br><span class="line">        PRINT_ERR(<span class="string">&quot;open error&quot;</span>);</span><br><span class="line">    <span class="comment">// 打开管道文件</span></span><br><span class="line">    <span class="keyword">if</span> ((fd2 = open(FIFO_NAME, O_WRONLY)) == <span class="number">-1</span>)</span><br><span class="line">        PRINT_ERR(<span class="string">&quot;open error&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 循环读写（从源文件读，向管道写）</span></span><br><span class="line">    <span class="keyword">while</span> ((ret = read(fd1, s, <span class="keyword">sizeof</span>(s))) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        write(fd2,s,ret);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    close(fd1);</span><br><span class="line">    close(fd2);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>03read.c</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;head.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FIFO_NAME <span class="string">&quot;./myfifo&quot;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span>* argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> fd1, fd2, ret;</span><br><span class="line">    <span class="type">char</span> s[<span class="number">128</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    <span class="comment">// 校验参数</span></span><br><span class="line">    <span class="keyword">if</span> (argc != <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;input error,try again\n&quot;</span>);</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;usgage: ./a.out destfile\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 打开目标文件</span></span><br><span class="line">    <span class="keyword">if</span> ((fd1 = open(argv[<span class="number">1</span>], O_WRONLY|O_CREAT|O_TRUNC,<span class="number">0666</span>)) == <span class="number">-1</span>)</span><br><span class="line">        PRINT_ERR(<span class="string">&quot;open error&quot;</span>);</span><br><span class="line">    <span class="comment">// 打开管道文件</span></span><br><span class="line">    <span class="keyword">if</span> ((fd2 = open(FIFO_NAME, O_RDONLY)) == <span class="number">-1</span>)</span><br><span class="line">        PRINT_ERR(<span class="string">&quot;open error&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 循环读写（从源文件读，向管道写）</span></span><br><span class="line">    <span class="keyword">while</span> ((ret = read(fd2, s, <span class="keyword">sizeof</span>(s))) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        write(fd1,s,ret);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    close(fd1);</span><br><span class="line">    close(fd2);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="有名管道读写的特点"><a href="#有名管道读写的特点" class="headerlink" title="有名管道读写的特点"></a>有名管道读写的特点</h3><ul>
<li><p><strong>读端存在写管道</strong>：<em>有多少写多少，直到写满为止（64K），写阻塞</em></p>
</li>
<li><p><strong>读端没有打开过，写管道</strong>：<em>写端在open位置阻塞</em></p>
</li>
<li><p><strong>读端先打开后关闭，写管道</strong>：<em>管道破裂，收到SIGPIPE信号，进程结束</em></p>
</li>
<li><p><strong>写端存在读管道</strong>：<em>有多少读多少，没数据读的时候读阻塞</em></p>
</li>
<li><p><strong>写端没有打开过，读管道</strong>：<em>读端在open的位置阻塞</em></p>
</li>
<li><p><strong>写端先打开后关闭，读管道</strong>：<em>有多少读多少，没数据的时候读立即返回（读返回值是0）</em></p>
</li>
</ul>
<h2 id="信号"><a href="#信号" class="headerlink" title="信号"></a>信号</h2><h3 id="信号简介"><a href="#信号简介" class="headerlink" title="信号简介"></a>信号简介</h3><p>用户可以通过 <code>kill</code> 命令给进程发信号，操作系统也可以给进程发送信号。进程对信号的响应方式有三种：<strong>忽略，默认，捕捉</strong></p>
<h3 id="发信号的命令"><a href="#发信号的命令" class="headerlink" title="发信号的命令"></a>发信号的命令</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">kill</span> -信号号  PID</span><br></pre></td></tr></table></figure>

<h3 id="信号的查看方式"><a href="#信号的查看方式" class="headerlink" title="信号的查看方式"></a>信号的查看方式</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">kill</span> -l</span><br></pre></td></tr></table></figure>
<h3 id="常用的信号"><a href="#常用的信号" class="headerlink" title="常用的信号"></a>常用的信号</h3><table>
<thead>
<tr>
<th align="center">信号名</th>
<th align="center">默认操作</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>SIGHUP</code></td>
<td align="center"><code>终止</code></td>
<td align="left">该信号在用户终端关闭时产生，通常是发给和该终端关联的会话内的所有进程</td>
</tr>
<tr>
<td align="center"><code>SIGINT</code></td>
<td align="center"><code>终止</code></td>
<td align="left">该信号在用户键入 INTR 字符 <code>ctrl + c</code> 时产生，内核发送此信号发送到当前终端的所有前台进程</td>
</tr>
<tr>
<td align="center"><code>SIGQUIT</code></td>
<td align="center"><code>终止</code></td>
<td align="left">该信号和 <code>SIGINT</code> 类似，但由 UIT 字符 <code>Ctrl + \</code></td>
</tr>
<tr>
<td align="center"><code>SIGILL</code></td>
<td align="center"><code>终止</code></td>
<td align="left">该信号在一个进程企图执行一条非法指令时产生</td>
</tr>
<tr>
<td align="center"><code>SIGSEV</code></td>
<td align="center"><code>终止</code></td>
<td align="left">该信号在非法访问内存时产生，如野指针、缓冲区溢出</td>
</tr>
<tr>
<td align="center"><code>SIGPIPR</code></td>
<td align="center"><code>终止</code></td>
<td align="left">当进程往一个没有读端的管道中写入时产生，代表 <strong>管道破裂</strong></td>
</tr>
<tr>
<td align="center"><code>SIGKILL</code></td>
<td align="center"><code>终止</code></td>
<td align="left">该信号用于立即结束程序的运行，不能被捕捉或忽略</td>
</tr>
<tr>
<td align="center"><code>SIGSTOP</code></td>
<td align="center"><code>暂停进程</code></td>
<td align="left">该信号用于立即暂停程序的运行，不能被捕捉或忽略</td>
</tr>
<tr>
<td align="center"><code>SIGTSTP</code></td>
<td align="center"><code>暂停进程</code></td>
<td align="left">该信号用于暂停进程，在用户键入 SUSP 字符 <code>Ctrl + z</code> 时产生</td>
</tr>
<tr>
<td align="center"><code>SIGCONT</code></td>
<td align="center"><code>继续运行</code></td>
<td align="left">该信号用于继续运行进程</td>
</tr>
<tr>
<td align="center"><code>SIGALRM</code></td>
<td align="center"><code>终止</code></td>
<td align="left">该信号在调用 <code>alarm</code> 函数设置的定时器超时时产生</td>
</tr>
<tr>
<td align="center"><code>SIGUSR1/2</code></td>
<td align="center"><code>终止</code></td>
<td align="left">该信号由用户使用</td>
</tr>
</tbody></table>
<p><strong><code>SIGCHLD</code> : 当子进程退出的时候，父进程会收到这个信号</strong></p>
<blockquote>
<p>  注：在所有的信号中，只有SIGKILL&#x2F;SIGSTOP两个信号不能被捕捉，也不能被忽略。只能执行默认的动作。</p>
</blockquote>
<h3 id="signal-函数"><a href="#signal-函数" class="headerlink" title="signal 函数"></a><code>signal</code> 函数</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="title function_">void</span> <span class="params">(*<span class="type">sighandler_t</span>)</span><span class="params">(<span class="type">int</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">sighandler_t</span> <span class="title function_">signal</span><span class="params">(<span class="type">int</span> signum, <span class="type">sighandler_t</span> handler)</span>;</span><br><span class="line"><span class="comment">// 功能：给进程对信号指定处理方式</span></span><br><span class="line"><span class="comment">// 参数：</span></span><br><span class="line"><span class="comment">//     @signum:信号号</span></span><br><span class="line"><span class="comment">// 	@handler:处理方式</span></span><br><span class="line"><span class="comment">//         SIG_IGN：忽略</span></span><br><span class="line"><span class="comment">//         SIG_DFL：默认</span></span><br><span class="line"><span class="comment">//         handle:捕捉</span></span><br><span class="line"><span class="comment">//         void handle(int signo)</span></span><br><span class="line"><span class="comment">//         &#123;</span></span><br><span class="line"><span class="comment">//             </span></span><br><span class="line"><span class="comment">//         &#125;</span></span><br><span class="line"><span class="comment">// 返回值：成功返回handler,失败返回SIG_ERR，置位错误码</span></span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;head.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">signal_handle</span><span class="params">(<span class="type">int</span> signo)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(signo == SIGINT)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;我收到了一个ctrl+c信号\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span>* argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 1.对SIGINT忽略</span></span><br><span class="line">    <span class="comment">// if(SIG_ERR == signal(SIGINT,SIG_IGN))</span></span><br><span class="line">    <span class="comment">//     PRINT_ERR(&quot;signal error&quot;);</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2.对SIGINT默认</span></span><br><span class="line">    <span class="comment">// if(SIG_ERR == signal(SIGINT,SIG_DFL))</span></span><br><span class="line">    <span class="comment">//     PRINT_ERR(&quot;signal error&quot;);</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3.对SIGINT捕捉</span></span><br><span class="line">    <span class="keyword">if</span> (SIG_ERR == signal(SIGINT, signal_handle))</span><br><span class="line">        PRINT_ERR(<span class="string">&quot;signal error&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h3><p>使用signal捕捉管道破裂信号</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;head.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">handle</span><span class="params">(<span class="type">int</span> signo)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">switch</span> (signo) &#123;</span><br><span class="line">    <span class="keyword">case</span> SIGPIPE:</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;我捕捉到了一个管道破裂信号\n&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> SIGINT:</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;我捕捉到了一个ctrl+c信号\n&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span>* argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> pipefd[<span class="number">2</span>];</span><br><span class="line">    <span class="type">char</span> s[<span class="number">128</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((SIG_ERR == signal(SIGINT, handle)))</span><br><span class="line">        PRINT_ERR(<span class="string">&quot;signal error&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((SIG_ERR == signal(SIGPIPE, handle)))</span><br><span class="line">        PRINT_ERR(<span class="string">&quot;signal error&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (pipe(pipefd))</span><br><span class="line">        PRINT_ERR(<span class="string">&quot;pipe error&quot;</span>);</span><br><span class="line"></span><br><span class="line">    close(pipefd[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> ch = <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        write(pipefd[<span class="number">1</span>], &amp;ch, <span class="number">1</span>);</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>尝试使用非阻塞方式回收子进程资源, 记得要 <strong>回收掉子进程资源</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;head.h&gt;</span></span></span><br><span class="line"><span class="type">char</span> cmd[<span class="number">128</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="type">void</span> <span class="title function_">handle</span><span class="params">(<span class="type">int</span> signo)</span></span><br><span class="line">&#123;</span><br><span class="line">    waitpid(<span class="number">-1</span>,<span class="literal">NULL</span>,WNOHANG);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;我是父进程，我以非阻塞方式回收掉了子进程的资源\n&quot;</span>);</span><br><span class="line">    <span class="built_in">snprintf</span>(cmd,<span class="keyword">sizeof</span>(cmd),<span class="string">&quot;kill -%d %d&quot;</span>,SIGUSR1,getpid());</span><br><span class="line">    system(cmd);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span>* argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">pid_t</span> pid;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((pid = fork()) == <span class="number">-1</span>) &#123;</span><br><span class="line">        PRINT_ERR(<span class="string">&quot;fork error&quot;</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(pid == <span class="number">0</span>)&#123;</span><br><span class="line">        sleep(<span class="number">7</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;我是子进程，我执行了7s，我现在要退出...\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_SUCCESS);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(SIG_ERR == signal(SIGCHLD,handle))</span><br><span class="line">            PRINT_ERR(<span class="string">&quot;signal error&quot;</span>);</span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="发信号相关函数"><a href="#发信号相关函数" class="headerlink" title="发信号相关函数"></a>发信号相关函数</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">raise</span><span class="params">(<span class="type">int</span> sig)</span>;</span><br><span class="line"><span class="comment">// 功能：给自己发信号</span></span><br><span class="line"><span class="comment">// 参数：</span></span><br><span class="line"><span class="comment">//     @sig:信号号</span></span><br><span class="line"><span class="comment">// 返回值：成功返回0，失败返回非0</span></span><br><span class="line">        </span><br><span class="line"><span class="type">int</span> <span class="title function_">kill</span><span class="params">(<span class="type">pid_t</span> pid, <span class="type">int</span> sig)</span>;</span><br><span class="line"><span class="comment">// 功能：给指定pid的进程发送信号</span></span><br><span class="line"><span class="comment">// 参数：</span></span><br><span class="line"><span class="comment">//     @pid:进程号</span></span><br><span class="line"><span class="comment">//         pid &gt; 0 :给pid号的进程发信号</span></span><br><span class="line"><span class="comment">// 		pid = 0 :给同组的进程发送信号</span></span><br><span class="line"><span class="comment">// 		pid = -1:给所有有权限的进程发送信号</span></span><br><span class="line"><span class="comment">// 		pid &lt;-1:首先会对pid取绝对值，给和这个绝对值相同的组的进程发送信号</span></span><br><span class="line"><span class="comment">//     @信号号</span></span><br><span class="line"><span class="comment">// 返回值：成功返回0，失败返回-1置位错误码</span></span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> <span class="title function_">alarm</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> seconds)</span>;</span><br><span class="line"><span class="comment">// 功能：当seconds倒计时为0的时候发送SIGALRM信号</span></span><br><span class="line"><span class="comment">// 参数：</span></span><br><span class="line"><span class="comment">//     @seconds:秒钟数，如果填写为0，取消挂起的信号</span></span><br><span class="line"><span class="comment">// 返回值：如果alarm是第一次调用，返回0.</span></span><br><span class="line"><span class="comment">//         如果alarm不是第一次调用，返回上一次调用的剩余秒钟数</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//  alarm(5);  //返回值是0</span></span><br><span class="line"><span class="comment">//  sleep(2);  //延时2s</span></span><br><span class="line"><span class="comment">// 	alarm(5);  //返回值是3</span></span><br></pre></td></tr></table></figure>
<p><code>raise</code> &#x2F; <code>kill</code></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;head.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">handle</span><span class="params">(<span class="type">int</span> signo)</span></span><br><span class="line">&#123;</span><br><span class="line">    waitpid(<span class="number">-1</span>,<span class="literal">NULL</span>,WNOHANG);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;我是父进程，我以非阻塞方式回收掉了子进程的资源\n&quot;</span>);</span><br><span class="line">    <span class="comment">//raise(SIGUSR1);</span></span><br><span class="line">    kill(getpid(),SIGUSR1);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span>* argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">pid_t</span> pid;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((pid = fork()) == <span class="number">-1</span>) &#123;</span><br><span class="line">        PRINT_ERR(<span class="string">&quot;fork error&quot;</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(pid == <span class="number">0</span>)&#123;</span><br><span class="line">        sleep(<span class="number">7</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;我是子进程，我执行了7s，我现在要退出...\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_SUCCESS);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(SIG_ERR == signal(SIGCHLD,handle))</span><br><span class="line">            PRINT_ERR(<span class="string">&quot;signal error&quot;</span>);</span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>alarm</code></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;head.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">handle</span><span class="params">(<span class="type">int</span> signo)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;我收到了闹钟信号\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc,<span class="type">const</span> <span class="type">char</span> * argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(SIG_ERR == signal(SIGALRM,handle))</span><br><span class="line">        PRINT_ERR(<span class="string">&quot;signal error&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;第一次 = %d\n&quot;</span>,alarm(<span class="number">5</span>));</span><br><span class="line">    sleep(<span class="number">2</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;第二次 = %d\n&quot;</span>,alarm(<span class="number">5</span>));  <span class="comment">//SIGALRM</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>alarm</code> 2</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;head.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">handle</span><span class="params">(<span class="type">int</span> signo)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;系统自动出牌了\n&quot;</span>);</span><br><span class="line">    alarm(<span class="number">4</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc,<span class="type">const</span> <span class="type">char</span> * argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(SIG_ERR == signal(SIGALRM,handle))</span><br><span class="line">        PRINT_ERR(<span class="string">&quot;signal error&quot;</span>);</span><br><span class="line"></span><br><span class="line">    alarm(<span class="number">4</span>); </span><br><span class="line">    <span class="type">char</span> ch;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        ch = getchar();</span><br><span class="line">        getchar(); <span class="comment">//吃&#x27;\n&#x27;</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;用户出牌 = %c\n&quot;</span>,ch);</span><br><span class="line">        alarm(<span class="number">4</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="IPC进程间通信相关命令"><a href="#IPC进程间通信相关命令" class="headerlink" title="IPC进程间通信相关命令"></a>IPC进程间通信相关命令</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ipcs -q     <span class="comment">#查看消息队列</span></span><br><span class="line">ipcs -m     <span class="comment">#查看共享内存</span></span><br><span class="line">ipcs -s     <span class="comment">#查看信号灯集</span></span><br><span class="line">ipcrm -q msqid     <span class="comment">#删除消息队列</span></span><br><span class="line">ipcrm -m shmid     <span class="comment">#删除共享内存</span></span><br><span class="line">ipcrm -s semid     <span class="comment">#删除信号灯集</span></span><br></pre></td></tr></table></figure>

<h2 id="IPC进程间通信键值获取及组成"><a href="#IPC进程间通信键值获取及组成" class="headerlink" title="IPC进程间通信键值获取及组成"></a>IPC进程间通信键值获取及组成</h2><p>在使用IPC进程间通信的时候，首先需要获取一个key，只有当两个进程拿到相同的键的之后才能找到同一个IPC。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/ipc.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">key_t</span> <span class="title function_">ftok</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *pathname, <span class="type">int</span> proj_id)</span>;</span><br><span class="line"><span class="comment">// 功能：获取一个键值（键不是唯一的）</span></span><br><span class="line"><span class="comment">// 参数：</span></span><br><span class="line"><span class="comment">//     @pathname:路径及名字</span></span><br><span class="line"><span class="comment">// 	@proj_id:只有低8bit有效</span></span><br><span class="line"><span class="comment">// 返回值：成功返回键值，失败返回-1置位错误码</span></span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;head.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span>* argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">key_t</span> key;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">stat</span> <span class="title">st</span>;</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> ((key = ftok(<span class="string">&quot;/home/linux&quot;</span>, <span class="string">&#x27;t&#x27;</span>)) == <span class="number">-1</span>)</span><br><span class="line">        PRINT_ERR(<span class="string">&quot;ftok error&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;key = %#x\n&quot;</span>, key);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (stat(<span class="string">&quot;/home/linux&quot;</span>, &amp;st))</span><br><span class="line">        PRINT_ERR(<span class="string">&quot;stat error&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;inode = %#lx,devno = %#lx,proj_id = %#x\n&quot;</span>,st.st_ino,st.st_dev,<span class="string">&#x27;t&#x27;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="消息队列"><a href="#消息队列" class="headerlink" title="消息队列"></a>消息队列</h2><h3 id="消息队列通信原理"><a href="#消息队列通信原理" class="headerlink" title="消息队列通信原理"></a>消息队列通信原理</h3><p>如果想要使用消息队列实现进程间通信，就必须在内核空间创建出来消息队列，消息队列默认大小是 <code>16384（16K）</code>,当创建好消息队列之后A进程可以向消息队列中发消息，消息的格式是 <code>类型 + 正文</code>。当消息队列满的时候A进程如果还想往消息队列中发消息A进程休眠。B进程可以通过消息的类型从消息队列中取消息，取出的消息从队列中移除。<br>如果B进程想要获取的消息类型在队列中不存在B进程休眠等。</p>
<p>A进程向消息队列中发消息的时候可以采用：阻塞，非阻塞方式<br>B进程从消息队列中收消息的时候可以采用：阻塞，非阻塞方式</p>
<h3 id="msgget-msgsnd-msgrcv-msgctl"><a href="#msgget-msgsnd-msgrcv-msgctl" class="headerlink" title="msgget msgsnd msgrcv msgctl"></a><code>msgget</code> <code>msgsnd</code> <code>msgrcv</code> <code>msgctl</code></h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/ipc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/msg.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">msgget</span><span class="params">(<span class="type">key_t</span> key, <span class="type">int</span> msgflg)</span>;</span><br><span class="line"><span class="comment">// 功能：创建消息队列</span></span><br><span class="line"><span class="comment">// 参数：</span></span><br><span class="line"><span class="comment">//     @key：键值</span></span><br><span class="line"><span class="comment">//         key:通过ftok获取</span></span><br><span class="line"><span class="comment">//         IPC_PRIVATE：只能用于亲缘间进程的通信</span></span><br><span class="line"><span class="comment">//     @msgflag：消息队列的标志位</span></span><br><span class="line"><span class="comment">//         IPC_CREAT|0666  或   IPC_CREAT|IPC_EXCL|0666</span></span><br><span class="line"><span class="comment">// 返回值：成功返回消息队列号，失败返回-1置位错误码</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">msgsnd</span><span class="params">(<span class="type">int</span> msqid, <span class="type">const</span> <span class="type">void</span> *msgp, <span class="type">size_t</span> msgsz, <span class="type">int</span> msgflg)</span>;</span><br><span class="line"><span class="comment">// 功能：向消息队列中发消息</span></span><br><span class="line"><span class="comment">// 参数：</span></span><br><span class="line"><span class="comment">//     @msqid:消息队列号</span></span><br><span class="line"><span class="comment">//     @msgp:消息的首地址</span></span><br><span class="line"><span class="comment">//           struct msgbuf &#123;</span></span><br><span class="line"><span class="comment">//                long mtype;     //消息的类型，必须大于0</span></span><br><span class="line"><span class="comment">//                char mtext[255];  //消息的正文</span></span><br><span class="line"><span class="comment">//            &#125;;</span></span><br><span class="line"><span class="comment">// 	@msgsz:消息正文的大小</span></span><br><span class="line"><span class="comment">// 	@msgflg:消息的标志</span></span><br><span class="line"><span class="comment">//         0：阻塞发送</span></span><br><span class="line"><span class="comment">//         IPC_NOWAIT：非阻塞发送</span></span><br><span class="line"><span class="comment">// 返回值：成功返回0，失败返回-1置位错误码</span></span><br><span class="line"></span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">msgrcv</span><span class="params">(<span class="type">int</span> msqid, <span class="type">void</span> *msgp, <span class="type">size_t</span> msgsz, <span class="type">long</span> msgtyp,<span class="type">int</span> msgflg)</span>;</span><br><span class="line"><span class="comment">// 功能：从消息队列获取消息</span></span><br><span class="line"><span class="comment">// 参数：</span></span><br><span class="line"><span class="comment">//     @msqid：消息队列号</span></span><br><span class="line"><span class="comment">//     @msgp：消息的首地址</span></span><br><span class="line"><span class="comment">//     @msgsz：消息正文的大小</span></span><br><span class="line"><span class="comment">//     @msgtyp：消息的类型</span></span><br><span class="line"><span class="comment">//         	如果=0，接收消息队列中的第一个消息</span></span><br><span class="line"><span class="comment">//         	如果&gt;0 ,接收msgtyp指定的消息类型</span></span><br><span class="line"><span class="comment">//         	如果&lt;0，那么将读取队列中第一个最小类型小于或等于msgtyp绝对值的消息。</span></span><br><span class="line"><span class="comment">//             2-3-100-500-30-2000</span></span><br><span class="line"><span class="comment">//                 -100===&gt;100</span></span><br><span class="line"><span class="comment">//             2-3-100-30</span></span><br><span class="line"><span class="comment">//     @msgflg：消息的标志</span></span><br><span class="line"><span class="comment">//         0：阻塞接收</span></span><br><span class="line"><span class="comment">//         IPC_NOWAIT：非阻塞接收</span></span><br><span class="line"><span class="comment">// 返回值：失败返回-1置位错误码。成功返回接收接收的字节的个数</span></span><br></pre></td></tr></table></figure>
<p>01snd.c</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;head.h&gt;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="type">long</span> mtype;</span><br><span class="line">    <span class="type">char</span> name[<span class="number">19</span>];</span><br><span class="line">    <span class="type">char</span> sex;</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">&#125; <span class="type">msg_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MSGSIZE  (sizeof(msg_t)-sizeof(long))</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span>* argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">key_t</span> key;</span><br><span class="line">    <span class="type">int</span> msgqid;</span><br><span class="line">    <span class="comment">// 1.获取键值</span></span><br><span class="line">    <span class="keyword">if</span> ((key = ftok(<span class="string">&quot;/home/linux/&quot;</span>, <span class="string">&#x27;p&#x27;</span>)) == <span class="number">-1</span>)</span><br><span class="line">        PRINT_ERR(<span class="string">&quot;ftok error&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2.创建消息队列</span></span><br><span class="line">    <span class="keyword">if</span> ((msgqid = msgget(key, IPC_CREAT | <span class="number">0666</span>)) == <span class="number">-1</span>)</span><br><span class="line">        PRINT_ERR(<span class="string">&quot;msgget error&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3.向消息队列中发消息</span></span><br><span class="line">    <span class="type">int</span> ret;</span><br><span class="line">    <span class="type">msg_t</span> msg;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">    retry:</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;input (type name sex age) &gt; &quot;</span>);</span><br><span class="line">        ret = <span class="built_in">scanf</span>(<span class="string">&quot;%ld %s %c %d&quot;</span>, &amp;msg.mtype, msg.name, &amp;msg.sex, &amp;msg.age);</span><br><span class="line">        <span class="keyword">if</span> (ret != <span class="number">4</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;input error,try again\n&quot;</span>);</span><br><span class="line">            <span class="keyword">while</span> (getchar() != <span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line">            <span class="keyword">goto</span> retry;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(msgsnd(msgqid, &amp;msg,MSGSIZE, <span class="number">0</span>))</span><br><span class="line">            PRINT_ERR(<span class="string">&quot;msgsnd error&quot;</span>);</span><br><span class="line">            </span><br><span class="line">        <span class="keyword">if</span>(msg.mtype == <span class="number">1000</span>) <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>02rcv.c</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;head.h&gt;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="type">long</span> mtype;</span><br><span class="line">    <span class="type">char</span> name[<span class="number">19</span>];</span><br><span class="line">    <span class="type">char</span> sex;</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">&#125; <span class="type">msg_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MSGSIZE  (sizeof(msg_t)-sizeof(long))</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span>* argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">key_t</span> key;</span><br><span class="line">    <span class="type">int</span> msgqid;</span><br><span class="line">    <span class="comment">// 1.获取键值</span></span><br><span class="line">    <span class="keyword">if</span> ((key = ftok(<span class="string">&quot;/home/linux/&quot;</span>, <span class="string">&#x27;p&#x27;</span>)) == <span class="number">-1</span>)</span><br><span class="line">        PRINT_ERR(<span class="string">&quot;ftok error&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2.创建消息队列</span></span><br><span class="line">    <span class="keyword">if</span>((msgqid = msgget(key,IPC_CREAT|<span class="number">0666</span>))==<span class="number">-1</span>)</span><br><span class="line">        PRINT_ERR(<span class="string">&quot;msgget error&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 3.接收消息</span></span><br><span class="line">    <span class="type">long</span> type;</span><br><span class="line">    <span class="type">msg_t</span> msg;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;input (type) &gt; &quot;</span>);</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%ld&quot;</span>,&amp;type);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(msgrcv(msgqid,&amp;msg,MSGSIZE,type,<span class="number">0</span>)==<span class="number">-1</span>)</span><br><span class="line">            PRINT_ERR(<span class="string">&quot;msgrcv error&quot;</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;type=%ld,name=%s,sex=%c,age=%d\n&quot;</span>,msg.mtype,msg.name,msg.sex,msg.age);</span><br><span class="line">        <span class="keyword">if</span>(msg.mtype == <span class="number">1000</span>) <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(msgctl(msgqid,IPC_RMID,<span class="literal">NULL</span>)) <span class="comment">//删除消息队列</span></span><br><span class="line">        PRINT_ERR(<span class="string">&quot;msgctl error&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="msgctl-函数详解"><a href="#msgctl-函数详解" class="headerlink" title="msgctl 函数详解"></a><code>msgctl</code> 函数详解</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">msgctl</span><span class="params">(<span class="type">int</span> msqid, <span class="type">int</span> cmd, <span class="keyword">struct</span> msqid_ds *buf)</span>;</span><br><span class="line"><span class="comment">// 功能：消息队列的控制</span></span><br><span class="line"><span class="comment">// 参数：</span></span><br><span class="line"><span class="comment">//     @msqid：消息队列号</span></span><br><span class="line"><span class="comment">//     @cmd：命令码</span></span><br><span class="line"><span class="comment">//          IPC_STAT：获取消息队列的属性(ipcs -q msqid)</span></span><br><span class="line"><span class="comment">//          IPC_SET：设置消息队列的属性(如设置消息队列大小)</span></span><br><span class="line"><span class="comment">//          IPC_RMID:立即删除消息队列，唤醒所有等待的读取器和写入（ipcrm -q msqid）</span></span><br><span class="line"><span class="comment">//             器进程(返回一个错误并将errno设置为EIDRM)。调用进程</span></span><br><span class="line"><span class="comment">//             必须具有适当的特权，或者它的有效用户ID必须是消息队</span></span><br><span class="line"><span class="comment">//             列的创建者或所有者的ID。在这种情况下，msgctl()的/*第</span></span><br><span class="line"><span class="comment">//             三个参数将被忽略*/。</span></span><br><span class="line"><span class="comment">//     @buf：msqid_ds消息队列属性结构体</span></span><br><span class="line"><span class="comment">// 返回值：成功返回0，失败返回-1，置位错误码</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// eg1:使用msgctl删除消息队列</span></span><br><span class="line">msgctl(msqid,IPC_RMID,<span class="literal">NULL</span>);</span><br><span class="line"><span class="comment">// eg2:获取消息队列属性</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">msqid_ds</span> <span class="title">msqds</span>;</span> </span><br><span class="line">msgctl(msqid, IPC_STAT, &amp;msqds); <span class="comment">//获取到的属性在msqds结构体中存放</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//以下是对msqid_ds结构体的详解</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">msqid_ds</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ipc_perm</span> <span class="title">msg_perm</span>;</span>	<span class="comment">//权限结构体</span></span><br><span class="line">    <span class="type">__time_t</span> msg_stime;		<span class="comment">//最后一次发送消息的时间</span></span><br><span class="line">    <span class="type">__time_t</span> msg_rtime;		<span class="comment">//最后一次接收消息的时间</span></span><br><span class="line">    <span class="type">__syscall_ulong_t</span> __msg_cbytes; <span class="comment">//当前消息队列中字节数</span></span><br><span class="line">    <span class="type">msgqnum_t</span> msg_qnum;		<span class="comment">//当前消息队列中消息的个数</span></span><br><span class="line">    <span class="type">msglen_t</span> msg_qbytes;	<span class="comment">//消息队列中能够容纳的字节数（16384）</span></span><br><span class="line">    <span class="type">__pid_t</span> msg_lspid;		<span class="comment">//最后一次发送消息的进程号</span></span><br><span class="line">    <span class="type">__pid_t</span> msg_lrpid;		<span class="comment">//最后一次接收消息的进程号</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ipc_perm</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">__key_t</span> __key;			<span class="comment">//键值</span></span><br><span class="line">    <span class="type">__uid_t</span> uid;			<span class="comment">//消息队列所属的uid</span></span><br><span class="line">    <span class="type">__gid_t</span> gid;			<span class="comment">//消息队列所属的gid</span></span><br><span class="line">    <span class="type">__uid_t</span> cuid;			<span class="comment">//创建消息队列的uid</span></span><br><span class="line">    <span class="type">__gid_t</span> cgid;			<span class="comment">//创建消息队列的gid</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">short</span> <span class="type">int</span> mode;	<span class="comment">//消息队列的读写权限</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;head.h&gt;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="type">long</span> mtype;</span><br><span class="line">    <span class="type">char</span> name[<span class="number">19</span>];</span><br><span class="line">    <span class="type">char</span> sex;</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">&#125; <span class="type">msg_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MSGSIZE (sizeof(msg_t) - sizeof(long))</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span>* argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">key_t</span> key;</span><br><span class="line">    <span class="type">int</span> msgqid;</span><br><span class="line">    <span class="comment">// 1.获取键值</span></span><br><span class="line">    <span class="keyword">if</span> ((key = ftok(<span class="string">&quot;/home/linux/&quot;</span>, <span class="string">&#x27;p&#x27;</span>)) == <span class="number">-1</span>)</span><br><span class="line">        PRINT_ERR(<span class="string">&quot;ftok error&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2.创建消息队列</span></span><br><span class="line">    <span class="keyword">if</span> ((msgqid = msgget(key, IPC_CREAT | <span class="number">0666</span>)) == <span class="number">-1</span>)</span><br><span class="line">        PRINT_ERR(<span class="string">&quot;msgget error&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3.向消息队列中发消息</span></span><br><span class="line">    <span class="type">int</span> ret;</span><br><span class="line">    <span class="type">msg_t</span> msg;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">    retry:</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;input (type name sex age) &gt; &quot;</span>);</span><br><span class="line">        ret = <span class="built_in">scanf</span>(<span class="string">&quot;%ld %s %c %d&quot;</span>, &amp;msg.mtype, msg.name, &amp;msg.sex, &amp;msg.age);</span><br><span class="line">        <span class="keyword">if</span> (ret != <span class="number">4</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;input error,try again\n&quot;</span>);</span><br><span class="line">            <span class="keyword">while</span> (getchar() != <span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">                ;</span><br><span class="line">            <span class="keyword">goto</span> retry;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (msgsnd(msgqid, &amp;msg, MSGSIZE, <span class="number">0</span>))</span><br><span class="line">            PRINT_ERR(<span class="string">&quot;msgsnd error&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (msg.mtype == <span class="number">1000</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4.获取消息队列属性</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">msqid_ds</span> <span class="title">msqds</span>;</span></span><br><span class="line">    <span class="keyword">if</span> (msgctl(msgqid, IPC_STAT, &amp;msqds))</span><br><span class="line">        PRINT_ERR(<span class="string">&quot;msgctl error&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;key=%#x,uid=%d,gid=%d,mode=%#o,nq=%ld,nb=%ld,mb=%ld\n&quot;</span>,</span><br><span class="line">        msqds.msg_perm.__key, msqds.msg_perm.uid, msqds.msg_perm.gid,</span><br><span class="line">        msqds.msg_perm.mode, msqds.msg_qnum, msqds.__msg_cbytes, msqds.msg_qbytes);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 5.设置消息队列属性</span></span><br><span class="line">    msqds.msg_qbytes = <span class="number">32768</span>;</span><br><span class="line">    <span class="keyword">if</span> (msgctl(msgqid, IPC_SET, &amp;msqds))</span><br><span class="line">        PRINT_ERR(<span class="string">&quot;msgctl error&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 6.再次获取消息队列属性</span></span><br><span class="line">    <span class="built_in">memset</span>(&amp;msqds, <span class="number">0</span>, <span class="keyword">sizeof</span>(msqds));</span><br><span class="line">    <span class="keyword">if</span> (msgctl(msgqid, IPC_STAT, &amp;msqds))</span><br><span class="line">        PRINT_ERR(<span class="string">&quot;msgctl error&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;key=%#x,uid=%d,gid=%d,mode=%#o,nq=%ld,nb=%ld,mb=%ld\n&quot;</span>,</span><br><span class="line">        msqds.msg_perm.__key, msqds.msg_perm.uid, msqds.msg_perm.gid,</span><br><span class="line">        msqds.msg_perm.mode, msqds.msg_qnum, msqds.__msg_cbytes, msqds.msg_qbytes);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 7.删除消息队列</span></span><br><span class="line">    <span class="keyword">if</span> (msgctl(msgqid, IPC_RMID, <span class="literal">NULL</span>))</span><br><span class="line">        PRINT_ERR(<span class="string">&quot;msgctl error&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="共享内存"><a href="#共享内存" class="headerlink" title="共享内存"></a>共享内存</h2><h3 id="共享内存的工作原理"><a href="#共享内存的工作原理" class="headerlink" title="共享内存的工作原理"></a>共享内存的工作原理</h3><p>共享内存是所有进程间通信方式中效率最高的一个，因为当创建共享内存之后，需要通信的A和B进程可以直接操作这块物理内存空间 ，省去了向内核拷贝数据的过程。共享内存的大小是 <code>4K</code> 的整数倍。</p>
<h3 id="shmget-shmat-shmdt-shmctl"><a href="#shmget-shmat-shmdt-shmctl" class="headerlink" title="shmget shmat shmdt shmctl"></a><code>shmget</code> <code>shmat</code> <code>shmdt</code> <code>shmctl</code></h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/shm.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">shmget</span><span class="params">(<span class="type">key_t</span> key, <span class="type">size_t</span> size, <span class="type">int</span> shmflg)</span>;</span><br><span class="line"><span class="comment">// 功能：创建共享内存</span></span><br><span class="line"><span class="comment">// 参数：</span></span><br><span class="line"><span class="comment">//     @key:键值</span></span><br><span class="line"><span class="comment">//         key:通过ftok获取</span></span><br><span class="line"><span class="comment">//         IPC_PRIVATE：只能用于亲缘间进程的通信</span></span><br><span class="line"><span class="comment">// 	@size:共享内存的大小 4k整数倍</span></span><br><span class="line"><span class="comment">//     @msgflag:共享的标志位</span></span><br><span class="line"><span class="comment">//         IPC_CREAT|0666  或   IPC_CREAT|IPC_EXCL|0666</span></span><br><span class="line"><span class="comment">// 返回值：成功返回共享内存编号，失败返回-1置位错误码</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> *<span class="title function_">shmat</span><span class="params">(<span class="type">int</span> shmid, <span class="type">const</span> <span class="type">void</span> *shmaddr, <span class="type">int</span> shmflg)</span>;</span><br><span class="line"><span class="comment">// 功能：映射共享内存到当前的进程空间</span></span><br><span class="line"><span class="comment">// 参数：</span></span><br><span class="line"><span class="comment">//     @shmid:共享内存的编号</span></span><br><span class="line"><span class="comment">//     @shmaddr:NULL，让系统自动分配</span></span><br><span class="line"><span class="comment">//     @shmflg:共享内存的操作方式</span></span><br><span class="line"><span class="comment">//          0：读写</span></span><br><span class="line"><span class="comment">//          SHM_RDONLY：只读</span></span><br><span class="line"><span class="comment">// 返回值：成功返回共享内存的首地址，失败返回（void *）-1,并置位错误码</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">shmdt</span><span class="params">(<span class="type">const</span> <span class="type">void</span> *shmaddr)</span>;</span><br><span class="line"><span class="comment">// 功能：取消地址映射</span></span><br><span class="line"><span class="comment">// 参数：</span></span><br><span class="line"><span class="comment">//     @shmaddr:指向共享内存的指针</span></span><br><span class="line"><span class="comment">// 返回值：成功返回0，失败返回-1置位错误码</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">shmctl</span><span class="params">(<span class="type">int</span> shmid, <span class="type">int</span> cmd, <span class="keyword">struct</span> shmid_ds *buf)</span>;</span><br><span class="line"><span class="comment">// 功能：共享内存控制的函数</span></span><br><span class="line"><span class="comment">// 参数：</span></span><br><span class="line"><span class="comment">//     @shmid:共享内存的编号</span></span><br><span class="line"><span class="comment">//     @cmd:操作的命令码</span></span><br><span class="line"><span class="comment">//          IPC_STAT ：获取</span></span><br><span class="line"><span class="comment">//          IPC_SET：设置</span></span><br><span class="line"><span class="comment">// 		 IPC_RMID：删除共享内存</span></span><br><span class="line"><span class="comment">//         	标记要销毁的段。实际上，只有在最后一个进程将其分离之后</span></span><br><span class="line"><span class="comment">//         	(也就是说，关联结构shmid_ds的shm_nattch成员为零时)，</span></span><br><span class="line"><span class="comment">//         	段才会被销毁。调用者必须是段的所有者或创建者，或具有特权。buf参数被忽略。</span></span><br><span class="line"><span class="comment">// 	@buf:共享内存属性结构体指针</span></span><br><span class="line"><span class="comment">// 返回值:成功返回0，失败返回-1置位错误码</span></span><br></pre></td></tr></table></figure>
<p>01write.c</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;head.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SHMSIZE (4096)</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span>* argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">key_t</span> key;</span><br><span class="line">    <span class="type">int</span> shmid;</span><br><span class="line">    <span class="type">char</span>* waddr;</span><br><span class="line">    <span class="comment">// 1.获取键值 ftok</span></span><br><span class="line">    <span class="keyword">if</span> ((key = ftok(<span class="string">&quot;/home&quot;</span>, <span class="string">&#x27;g&#x27;</span>)) == <span class="number">-1</span>)</span><br><span class="line">        PRINT_ERR(<span class="string">&quot;ftok error&quot;</span>);</span><br><span class="line">    <span class="comment">// 2.创建共享内存 shmget</span></span><br><span class="line">    <span class="keyword">if</span> ((shmid = shmget(key, SHMSIZE, IPC_CREAT | <span class="number">0666</span>)) == <span class="number">-1</span>)</span><br><span class="line">        PRINT_ERR(<span class="string">&quot;shmget error&quot;</span>);</span><br><span class="line">    <span class="comment">// 3.将共享内存映射到用户空间 shmat</span></span><br><span class="line">    <span class="keyword">if</span> ((waddr = shmat(shmid, <span class="literal">NULL</span>, <span class="number">0</span>)) == (<span class="type">void</span>*)<span class="number">-1</span>)</span><br><span class="line">        PRINT_ERR(<span class="string">&quot;shmat error&quot;</span>);</span><br><span class="line">    <span class="comment">// 4.共享内存操作（写）</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;input &gt; &quot;</span>);</span><br><span class="line">        fgets(waddr, SHMSIZE, <span class="built_in">stdin</span>);</span><br><span class="line">        <span class="keyword">if</span> (waddr[<span class="built_in">strlen</span>(waddr) - <span class="number">1</span>] == <span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">            waddr[<span class="built_in">strlen</span>(waddr) - <span class="number">1</span>] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">strcmp</span>(waddr, <span class="string">&quot;quit&quot;</span>) == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 5.取消映射 shmdt</span></span><br><span class="line">    <span class="keyword">if</span>(shmdt(waddr))</span><br><span class="line">        PRINT_ERR(<span class="string">&quot;shmdt error&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>02read.c</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;head.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SHMSIZE (4096)</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span>* argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">key_t</span> key;</span><br><span class="line">    <span class="type">int</span> shmid;</span><br><span class="line">    <span class="type">char</span>* raddr;</span><br><span class="line">    <span class="comment">// 1.获取键值 ftok</span></span><br><span class="line">    <span class="keyword">if</span> ((key = ftok(<span class="string">&quot;/home&quot;</span>, <span class="string">&#x27;g&#x27;</span>)) == <span class="number">-1</span>)</span><br><span class="line">        PRINT_ERR(<span class="string">&quot;ftok error&quot;</span>);</span><br><span class="line">    <span class="comment">// 2.创建共享内存 shmget</span></span><br><span class="line">    <span class="keyword">if</span> ((shmid = shmget(key, SHMSIZE, IPC_CREAT | <span class="number">0666</span>)) == <span class="number">-1</span>)</span><br><span class="line">        PRINT_ERR(<span class="string">&quot;shmget error&quot;</span>);</span><br><span class="line">    <span class="comment">// 3.将共享内存映射到用户空间 shmat</span></span><br><span class="line">    <span class="keyword">if</span> ((raddr = shmat(shmid, <span class="literal">NULL</span>, <span class="number">0</span>)) == (<span class="type">void</span>*)<span class="number">-1</span>)</span><br><span class="line">        PRINT_ERR(<span class="string">&quot;shmat error&quot;</span>);</span><br><span class="line">    <span class="comment">// 4.从共享内存中数数据</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        getchar(); <span class="comment">// 敲回车读一次数据，如果不写这句话会疯狂刷屏</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;read:%s\n&quot;</span>, raddr);</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">strncmp</span>(raddr, <span class="string">&quot;quit&quot;</span>, <span class="number">4</span>) == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 5.取消映射 shmdt</span></span><br><span class="line">    <span class="keyword">if</span> (shmdt(raddr))</span><br><span class="line">        PRINT_ERR(<span class="string">&quot;shmdt error&quot;</span>);</span><br><span class="line">    <span class="comment">// 6.删除共享内存 shmctl</span></span><br><span class="line">    <span class="keyword">if</span> (shmctl(shmid, IPC_RMID, <span class="literal">NULL</span>))</span><br><span class="line">        PRINT_ERR(<span class="string">&quot;shmctl error&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="shmctl-函数详解"><a href="#shmctl-函数详解" class="headerlink" title="shmctl 函数详解"></a><code>shmctl</code> 函数详解</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">shmctl</span><span class="params">(<span class="type">int</span> shmid, <span class="type">int</span> cmd, <span class="keyword">struct</span> shmid_ds *buf)</span>;</span><br><span class="line"><span class="comment">// 功能：共享内存控制的函数</span></span><br><span class="line"><span class="comment">// 参数：</span></span><br><span class="line"><span class="comment">//     @shmid:共享内存的编号</span></span><br><span class="line"><span class="comment">//     @cmd:操作的命令码</span></span><br><span class="line"><span class="comment">//          IPC_STAT ：获取  (ipcs -m)</span></span><br><span class="line"><span class="comment">//          IPC_SET：设置</span></span><br><span class="line"><span class="comment">// 		 IPC_RMID：删除共享内存 （ipcrm -m shmid）</span></span><br><span class="line"><span class="comment">//         	标记要销毁的段。实际上，只有在最后一个进程将其分离之后</span></span><br><span class="line"><span class="comment">//         	(也就是说，关联结构shmid_ds的shm_nattch成员为零时)，</span></span><br><span class="line"><span class="comment">//         	段才会被销毁。调用者必须是段的所有者或创建者，或具有特权。buf参数被忽略。</span></span><br><span class="line"><span class="comment">// 	@buf:共享内存属性结构体指针</span></span><br><span class="line"><span class="comment">// 返回值:成功返回0，失败返回-1置位错误码</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// eg1:</span></span><br><span class="line">shmctl(shmid,IPC_RMID,<span class="literal">NULL</span>); <span class="comment">//删除共享内存 </span></span><br><span class="line"><span class="comment">// eg2：</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">shmid_ds</span> <span class="title">buf</span>;</span></span><br><span class="line">shmctl(shmid,IPC_STAT,&amp;buf); <span class="comment">//获取消息队列的属性</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//以下是shmid_ds结果的详解</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">shmid_ds</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ipc_perm</span> <span class="title">shm_perm</span>;</span> <span class="comment">//权限结构体</span></span><br><span class="line">    <span class="type">size_t</span> shm_segsz;		  <span class="comment">//共享内存的大小，单位是字节</span></span><br><span class="line">    <span class="type">__time_t</span> shm_atime;		  <span class="comment">//最后一次调用shmat的时间</span></span><br><span class="line">    <span class="type">__time_t</span> shm_dtime;		  <span class="comment">//最后一次调用shmdt的时间</span></span><br><span class="line">    <span class="type">__time_t</span> shm_ctime;		  <span class="comment">//最后一次调用shmctl改变属性的时间</span></span><br><span class="line">    <span class="type">__pid_t</span> shm_cpid;		  <span class="comment">//创建共享内存的PID</span></span><br><span class="line">    <span class="type">__pid_t</span> shm_lpid;		  <span class="comment">//最后一次操作共享内存的PID</span></span><br><span class="line">    <span class="type">shmatt_t</span> shm_nattch;	  <span class="comment">//当前多少个进程关联共享内存</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ipc_perm</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">__key_t</span> __key;			<span class="comment">//键值</span></span><br><span class="line">    <span class="type">__uid_t</span> uid;			<span class="comment">//消息队列所属的uid</span></span><br><span class="line">    <span class="type">__gid_t</span> gid;			<span class="comment">//消息队列所属的gid</span></span><br><span class="line">    <span class="type">__uid_t</span> cuid;			<span class="comment">//创建消息队列的uid</span></span><br><span class="line">    <span class="type">__gid_t</span> cgid;			<span class="comment">//创建消息队列的gid</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">short</span> <span class="type">int</span> mode;	<span class="comment">//消息队列的读写权限</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="信号灯集"><a href="#信号灯集" class="headerlink" title="信号灯集"></a>信号灯集</h2><h3 id="信号灯集工作原理"><a href="#信号灯集工作原理" class="headerlink" title="信号灯集工作原理"></a>信号灯集工作原理</h3><p>信号量（信号灯集）是实现 <strong>进程同步</strong> 的机制，在一个信号灯集中可以有很多个信号灯。在信号灯集内信号灯相互独立，每个灯的值的改变不会影响其他的信号灯，信号灯的值一般设置为二值量（ <code>1</code> 或者 <code>0</code> ，<code>1</code> 代表有资源，<code>0</code> 代表没有资源）。</p>
<h3 id="semget-semctl-semop"><a href="#semget-semctl-semop" class="headerlink" title="semget semctl semop"></a><code>semget</code> <code>semctl</code> <code>semop</code></h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/sem.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">semget</span><span class="params">(<span class="type">key_t</span> key, <span class="type">int</span> nsems, <span class="type">int</span> semflg)</span>;</span><br><span class="line"><span class="comment">// 功能：创建一个信号灯集</span></span><br><span class="line"><span class="comment">// 参数：</span></span><br><span class="line"><span class="comment">//     @key:键值</span></span><br><span class="line"><span class="comment">//          IPC_PRIVATE </span></span><br><span class="line"><span class="comment">//          key</span></span><br><span class="line"><span class="comment">//     @nsems:信号灯集合中信号灯的个数</span></span><br><span class="line"><span class="comment">//     @semflag:创建的标志位</span></span><br><span class="line"><span class="comment">//         IPC_CREAT|0666  或  IPC_CREAT|IPC_EXCL|0666</span></span><br><span class="line"><span class="comment">// 返回值：成功返回semid,失败返回-1置位错误码</span></span><br><span class="line">             </span><br><span class="line"><span class="type">int</span> <span class="title function_">semctl</span><span class="params">(<span class="type">int</span> semid, <span class="type">int</span> semnum, <span class="type">int</span> cmd, ...)</span>;</span><br><span class="line"><span class="comment">// 功能：信号灯集的控制函数</span></span><br><span class="line"><span class="comment">// 参数：</span></span><br><span class="line"><span class="comment">//     @semid信号灯集的ID</span></span><br><span class="line"><span class="comment">//     @senum:信号灯的编号</span></span><br><span class="line"><span class="comment">//     @cmd:命令码</span></span><br><span class="line"><span class="comment">//         SETVAL：设置信号灯的值 ---&gt;第四个参数val选项</span></span><br><span class="line"><span class="comment">//         GETVAL：获取信号灯的值 ---&gt;不需要第四个参数</span></span><br><span class="line"><span class="comment">// 		IPC_STAT：获取信号灯集的属性---&gt;第二个参数被忽略，第四个参数buf选项</span></span><br><span class="line"><span class="comment">//         IPC_SET ：设置信号灯集的属性---&gt;第四个参数buf选项</span></span><br><span class="line"><span class="comment">// 		IPC_RMID:第二参数被忽略，第4个参数不用填写</span></span><br><span class="line"><span class="comment">// 	@...:</span></span><br><span class="line"><span class="comment">// 		  union semun &#123;</span></span><br><span class="line"><span class="comment">//                int              val;    /* Value for SETVAL */</span></span><br><span class="line"><span class="comment">//                struct semid_ds *buf;    /* Buffer for IPC_STAT, IPC_SET */</span></span><br><span class="line"><span class="comment">//            &#125;;</span></span><br><span class="line"><span class="comment">// 返回值：失败返回-1置位错误码</span></span><br><span class="line"><span class="comment">//     	成功：</span></span><br><span class="line"><span class="comment">//     		GETVAL:成功返回信号灯的值</span></span><br><span class="line"><span class="comment">//             其余的命令码成功返回0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// eg:设置灯的值</span></span><br><span class="line"><span class="class"><span class="keyword">union</span> <span class="title">semun</span> <span class="title">sem</span> =</span> &#123;</span><br><span class="line">	.val = <span class="number">1</span>,</span><br><span class="line">&#125;</span><br><span class="line">semctl(semid,<span class="number">0</span>,SETVAL,sem); <span class="comment">//将0号灯初始值设置为1</span></span><br><span class="line"><span class="class"><span class="keyword">union</span> <span class="title">semun</span> <span class="title">sem</span> =</span> &#123;</span><br><span class="line">	.val = <span class="number">0</span>,</span><br><span class="line">&#125;</span><br><span class="line">semctl(semid,<span class="number">1</span>,SETVAL,sem); <span class="comment">//将1号灯初始值设置为0</span></span><br><span class="line"><span class="comment">// eg:获取信号灯的值</span></span><br><span class="line">val = semctl(semid,<span class="number">0</span>,GETVAL); <span class="comment">//获取0号灯的值</span></span><br><span class="line"><span class="comment">// eg:获取信号灯集的属性</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">semid_ds</span> <span class="title">buf</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">union</span> <span class="title">semun</span> <span class="title">sem</span> =</span> &#123;</span><br><span class="line">  	.buf = &amp;buf,</span><br><span class="line">&#125;</span><br><span class="line">semctl(semid,<span class="number">0</span>，IPC_STAT,sem); <span class="comment">//获取信号灯集的属性，第二参数被忽略</span></span><br><span class="line"><span class="comment">// eg:删除信号等集</span></span><br><span class="line">semctl(semid,<span class="number">0</span>,IPC_RMID); <span class="comment">//删除信号等集</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">semop</span><span class="params">(<span class="type">int</span> semid, <span class="keyword">struct</span> sembuf *sops, <span class="type">size_t</span> nsops)</span>;</span><br><span class="line"><span class="comment">// 功能：信号灯集中信号灯的操作函数</span></span><br><span class="line"><span class="comment">// 参数：</span></span><br><span class="line"><span class="comment">//     @semid:信号灯集的编号</span></span><br><span class="line"><span class="comment">//     @sops:操作方式</span></span><br><span class="line"><span class="comment">//         struct sembuf&#123;</span></span><br><span class="line"><span class="comment">//            unsigned short sem_num;  //信号灯的编号</span></span><br><span class="line"><span class="comment">//            short sem_op;   //操作方式（PV）</span></span><br><span class="line"><span class="comment">//             					-1:P操作，申请资源</span></span><br><span class="line"><span class="comment">//                              1:V操作，释放资源</span></span><br><span class="line"><span class="comment">//            short sem_flg;  //操作的标志位</span></span><br><span class="line"><span class="comment">//             				    0：阻塞</span></span><br><span class="line"><span class="comment">//                              IPC_NOWAIT：非阻塞方式操作</span></span><br><span class="line"><span class="comment">//         &#125;</span></span><br><span class="line"><span class="comment">// 	   @nsops:本次操作信号灯的个数</span></span><br><span class="line"><span class="comment">// 返回值：成功返回0，失败返回-1置位错误码</span></span><br></pre></td></tr></table></figure>
<p>01write.c</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;head.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SHMSIZE (4096)</span></span><br><span class="line"><span class="class"><span class="keyword">union</span> <span class="title">semun</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> val; <span class="comment">/* Value for SETVAL */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">semid_ds</span>* <span class="title">buf</span>;</span> <span class="comment">/* Buffer for IPC_STAT, IPC_SET */</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">int</span> <span class="title function_">mysem_init</span><span class="params">(<span class="type">int</span> semid, <span class="type">int</span> which, <span class="type">int</span> value)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">union</span> <span class="title">semun</span> <span class="title">sem</span> =</span> &#123;</span><br><span class="line">        .val = value,</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">if</span> (semctl(semid, which, SETVAL, sem) == <span class="number">-1</span>)</span><br><span class="line">        PRINT_ERR(<span class="string">&quot;semctl error&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">P</span><span class="params">(<span class="type">int</span> semid, <span class="type">int</span> which)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sembuf</span> <span class="title">op</span> =</span> &#123;</span><br><span class="line">        .sem_num = which, <span class="comment">// 那个灯</span></span><br><span class="line">        .sem_op = <span class="number">-1</span>, <span class="comment">// -1 P申请   1 V释放</span></span><br><span class="line">        .sem_flg = <span class="number">0</span>, <span class="comment">// 阻塞</span></span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">if</span> (semop(semid, &amp;op, <span class="number">1</span>))</span><br><span class="line">        PRINT_ERR(<span class="string">&quot;semop P error&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">V</span><span class="params">(<span class="type">int</span> semid, <span class="type">int</span> which)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sembuf</span> <span class="title">op</span> =</span> &#123;</span><br><span class="line">        .sem_num = which, <span class="comment">// 那个灯</span></span><br><span class="line">        .sem_op = <span class="number">1</span>, <span class="comment">// -1 P申请   1 V释放</span></span><br><span class="line">        .sem_flg = <span class="number">0</span>, <span class="comment">// 阻塞</span></span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">if</span> (semop(semid, &amp;op, <span class="number">1</span>))</span><br><span class="line">        PRINT_ERR(<span class="string">&quot;semop V error&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span>* argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">key_t</span> key;</span><br><span class="line">    <span class="type">int</span> shmid, semid;</span><br><span class="line">    <span class="type">char</span>* waddr;</span><br><span class="line">    <span class="comment">// 1.获取键值 ftok</span></span><br><span class="line">    <span class="keyword">if</span> ((key = ftok(<span class="string">&quot;/home&quot;</span>, <span class="string">&#x27;g&#x27;</span>)) == <span class="number">-1</span>)</span><br><span class="line">        PRINT_ERR(<span class="string">&quot;ftok error&quot;</span>);</span><br><span class="line">    <span class="comment">// 2.创建共享内存 shmget</span></span><br><span class="line">    <span class="keyword">if</span> ((shmid = shmget(key, SHMSIZE, IPC_CREAT | <span class="number">0666</span>)) == <span class="number">-1</span>)</span><br><span class="line">        PRINT_ERR(<span class="string">&quot;shmget error&quot;</span>);</span><br><span class="line">    <span class="comment">// 3.将共享内存映射到用户空间 shmat</span></span><br><span class="line">    <span class="keyword">if</span> ((waddr = shmat(shmid, <span class="literal">NULL</span>, <span class="number">0</span>)) == (<span class="type">void</span>*)<span class="number">-1</span>)</span><br><span class="line">        PRINT_ERR(<span class="string">&quot;shmat error&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4.创建信号灯集，并初始化信号灯</span></span><br><span class="line">    <span class="keyword">if</span> ((semid = semget(key, <span class="number">2</span>, IPC_CREAT | IPC_EXCL | <span class="number">0666</span>)) == <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (errno = EEXIST) &#123;</span><br><span class="line">            semid = semget(key, <span class="number">2</span>, IPC_CREAT|<span class="number">0666</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            PRINT_ERR(<span class="string">&quot;semget error&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        mysem_init(semid, <span class="number">0</span>, <span class="number">1</span>); <span class="comment">// 将0号灯设置为1</span></span><br><span class="line">        mysem_init(semid, <span class="number">1</span>, <span class="number">0</span>); <span class="comment">// 将1号灯设置为0</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 5.共享内存操作（写）</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        P(semid, <span class="number">0</span>); <span class="comment">// 申请0号灯资源</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;input &gt; &quot;</span>);</span><br><span class="line">        fgets(waddr, SHMSIZE, <span class="built_in">stdin</span>);</span><br><span class="line">        <span class="keyword">if</span> (waddr[<span class="built_in">strlen</span>(waddr) - <span class="number">1</span>] == <span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">            waddr[<span class="built_in">strlen</span>(waddr) - <span class="number">1</span>] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">        V(semid, <span class="number">1</span>); <span class="comment">// 释放1号灯资源</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">strcmp</span>(waddr, <span class="string">&quot;quit&quot;</span>) == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 6.取消映射 shmdt</span></span><br><span class="line">    <span class="keyword">if</span> (shmdt(waddr))</span><br><span class="line">        PRINT_ERR(<span class="string">&quot;shmdt error&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>02read.c</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;head.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SHMSIZE (4096)</span></span><br><span class="line"><span class="class"><span class="keyword">union</span> <span class="title">semun</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> val; <span class="comment">/* Value for SETVAL */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">semid_ds</span>* <span class="title">buf</span>;</span> <span class="comment">/* Buffer for IPC_STAT, IPC_SET */</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">int</span> <span class="title function_">mysem_init</span><span class="params">(<span class="type">int</span> semid, <span class="type">int</span> which, <span class="type">int</span> value)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">union</span> <span class="title">semun</span> <span class="title">sem</span> =</span> &#123;</span><br><span class="line">        .val = value,</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">if</span> (semctl(semid, which, SETVAL, sem) == <span class="number">-1</span>)</span><br><span class="line">        PRINT_ERR(<span class="string">&quot;semctl error&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">P</span><span class="params">(<span class="type">int</span> semid, <span class="type">int</span> which)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sembuf</span> <span class="title">op</span> =</span> &#123;</span><br><span class="line">        .sem_num = which, <span class="comment">// 那个灯</span></span><br><span class="line">        .sem_op = <span class="number">-1</span>, <span class="comment">// -1 P申请   1 V释放</span></span><br><span class="line">        .sem_flg = <span class="number">0</span>, <span class="comment">// 阻塞</span></span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">if</span> (semop(semid, &amp;op, <span class="number">1</span>))</span><br><span class="line">        PRINT_ERR(<span class="string">&quot;semop P error&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">V</span><span class="params">(<span class="type">int</span> semid, <span class="type">int</span> which)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sembuf</span> <span class="title">op</span> =</span> &#123;</span><br><span class="line">        .sem_num = which, <span class="comment">// 那个灯</span></span><br><span class="line">        .sem_op = <span class="number">1</span>, <span class="comment">// -1 P申请   1 V释放</span></span><br><span class="line">        .sem_flg = <span class="number">0</span>, <span class="comment">// 阻塞</span></span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">if</span> (semop(semid, &amp;op, <span class="number">1</span>))</span><br><span class="line">        PRINT_ERR(<span class="string">&quot;semop V error&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span>* argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">key_t</span> key;</span><br><span class="line">    <span class="type">int</span> shmid, semid;</span><br><span class="line">    <span class="type">char</span>* raddr;</span><br><span class="line">    <span class="comment">// 1.获取键值 ftok</span></span><br><span class="line">    <span class="keyword">if</span> ((key = ftok(<span class="string">&quot;/home&quot;</span>, <span class="string">&#x27;g&#x27;</span>)) == <span class="number">-1</span>)</span><br><span class="line">        PRINT_ERR(<span class="string">&quot;ftok error&quot;</span>);</span><br><span class="line">    <span class="comment">// 2.创建共享内存 shmget</span></span><br><span class="line">    <span class="keyword">if</span> ((shmid = shmget(key, SHMSIZE, IPC_CREAT | <span class="number">0666</span>)) == <span class="number">-1</span>)</span><br><span class="line">        PRINT_ERR(<span class="string">&quot;shmget error&quot;</span>);</span><br><span class="line">    <span class="comment">// 3.将共享内存映射到用户空间 shmat</span></span><br><span class="line">    <span class="keyword">if</span> ((raddr = shmat(shmid, <span class="literal">NULL</span>, <span class="number">0</span>)) == (<span class="type">void</span>*)<span class="number">-1</span>)</span><br><span class="line">        PRINT_ERR(<span class="string">&quot;shmat error&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4.创建信号灯集，并初始化信号灯</span></span><br><span class="line">    <span class="keyword">if</span> ((semid = semget(key, <span class="number">2</span>, IPC_CREAT | IPC_EXCL | <span class="number">0666</span>)) == <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (errno = EEXIST) &#123;</span><br><span class="line">            semid = semget(key, <span class="number">2</span>, IPC_CREAT | <span class="number">0666</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            PRINT_ERR(<span class="string">&quot;semget error&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        mysem_init(semid, <span class="number">0</span>, <span class="number">1</span>); <span class="comment">// 将0号灯设置为1</span></span><br><span class="line">        mysem_init(semid, <span class="number">1</span>, <span class="number">0</span>); <span class="comment">// 将1号灯设置为0</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 5.从共享内存中数数据</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        P(semid, <span class="number">1</span>); <span class="comment">// 申请1号灯资源</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;read:%s\n&quot;</span>, raddr);</span><br><span class="line">        V(semid, <span class="number">0</span>); <span class="comment">// 释放0号灯资源</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">strncmp</span>(raddr, <span class="string">&quot;quit&quot;</span>, <span class="number">4</span>) == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 6.取消映射 shmdt</span></span><br><span class="line">    <span class="keyword">if</span> (shmdt(raddr))</span><br><span class="line">        PRINT_ERR(<span class="string">&quot;shmdt error&quot;</span>);</span><br><span class="line">    <span class="comment">// 7.删除共享内存 shmctl</span></span><br><span class="line">    <span class="keyword">if</span> (shmctl(shmid, IPC_RMID, <span class="literal">NULL</span>))</span><br><span class="line">        PRINT_ERR(<span class="string">&quot;shmctl error&quot;</span>);</span><br><span class="line">    <span class="comment">// 8.删除信号灯集</span></span><br><span class="line">    <span class="keyword">if</span> (semctl(semid, <span class="number">0</span>, IPC_RMID))</span><br><span class="line">        PRINT_ERR(<span class="string">&quot;semctl error&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="套接字"><a href="#套接字" class="headerlink" title="套接字"></a>套接字</h1><p><code>socket</code> 套接字本来是用于同主机的进程间通信的。后来有了TCP&#x2F;IP协议族加入后又进行的功能的拓展与升级，实现了多个不同主机间的进程间通信。<br><code>socket</code> 是一个系统调用的接口，会返回一个文件描述符，用户通过网络收发数据时，只需对此文件描述符进行读写操作即可，读就是接收，写就是发送。相当于把复杂的网络通信过程转换成了IO操作。</p>
<p>此处之涉及本地间的通信，不涉及网络通信，更多在另一篇文章中进行介绍。</p>
<h2 id="本地间-TCP-通信"><a href="#本地间-TCP-通信" class="headerlink" title="本地间 TCP 通信"></a>本地间 <code>TCP</code> 通信</h2><p>服务器</p>
<ul>
<li>创建套接字 <code>socket</code></li>
<li>填充服务器本地信息结构体 <code>sockaddr_un</code></li>
<li>将套接字与服务器本地信息结构体绑定 <code>bind</code></li>
<li>将套接字设置为被动监听状态 <code>listen</code></li>
<li>阻塞等待客户端的连接请求 <code>accept</code></li>
<li>进行通信 <code>recv</code> &#x2F; <code>send</code> 或  <code>read</code> &#x2F; <code>write</code></li>
</ul>
<p>客户端</p>
<ul>
<li>创建套接字 <code>socket</code></li>
<li>填充服务器本地信息结构体 <code>sockaddr_un</code></li>
<li>发送客户端的连接请求 <code>connect</code></li>
<li>进行通信 <code>send</code> &#x2F; <code>recv</code></li>
</ul>
<p>本地通信结构体</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">man 7 unix <span class="comment"># 可以查看到结构体的定义</span></span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_un</span> &#123;</span></span><br><span class="line">    <span class="type">sa_family_t</span>   sun_family;         <span class="comment">// AF_UNIX       </span></span><br><span class="line">    <span class="type">char</span>          sun_path[<span class="number">108</span>];      <span class="comment">// pathname </span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>客户端</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netinet/ip.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdbool.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/un.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> <span class="type">const</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//1.创建流式套接字：</span></span><br><span class="line">    <span class="type">int</span> socket_fd = socket(AF_LOCAL,SOCK_STREAM,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(socket_fd == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;socket err:&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//2.创建一个网络信息结构体:</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_un</span> <span class="title">serverInfo</span> =</span> &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    serverInfo.sun_family = AF_LOCAL;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>* processfileName = <span class="string">&quot;myserver&quot;</span>;</span><br><span class="line">    <span class="built_in">memcpy</span>(serverInfo.sun_path,processfileName,<span class="built_in">strlen</span>(processfileName));</span><br><span class="line"></span><br><span class="line">    <span class="comment">//使用connect函数连接主机：</span></span><br><span class="line">    <span class="type">int</span> ret = connect(socket_fd,(<span class="type">const</span> <span class="keyword">struct</span> sockaddr*)&amp;serverInfo,<span class="keyword">sizeof</span>(serverInfo));</span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;connect err:&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">char</span> buf[<span class="number">128</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">memset</span>(buf,<span class="number">0</span>,<span class="keyword">sizeof</span>(buf));</span><br><span class="line">        <span class="comment">//发出数据：</span></span><br><span class="line">        fgets(buf,<span class="keyword">sizeof</span>(buf),<span class="built_in">stdin</span>);</span><br><span class="line">        <span class="type">int</span> nbytes = write(socket_fd,buf,<span class="built_in">strlen</span>(buf));</span><br><span class="line">        <span class="keyword">if</span>(nbytes == <span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            perror(<span class="string">&quot;write err:&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//接收数据：</span></span><br><span class="line">        <span class="built_in">memset</span>(buf,<span class="number">0</span>,<span class="keyword">sizeof</span>(buf));</span><br><span class="line">        nbytes = read(socket_fd,buf,<span class="keyword">sizeof</span>(buf));</span><br><span class="line">        <span class="keyword">if</span>(nbytes == <span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            perror(<span class="string">&quot;read err:&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(nbytes == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;对端已经关闭了\n&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;服务器发来的数据: %s \n&quot;</span>,buf);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>服务器</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netinet/ip.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdbool.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/un.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> <span class="type">const</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 1.创建流式监听套接字类型：本地套接字。</span></span><br><span class="line">    <span class="type">int</span> listen_fd = socket(AF_LOCAL, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (listen_fd == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;socket() err:&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 2.定义一个网络地址信息结构体：</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_un</span> <span class="title">serverInfo</span>;</span></span><br><span class="line">    <span class="built_in">memset</span>(&amp;serverInfo, <span class="number">0</span>, <span class="keyword">sizeof</span>(serverInfo));</span><br><span class="line">    serverInfo.sun_family = AF_LOCAL;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>* processfileName = <span class="string">&quot;myserver&quot;</span>;</span><br><span class="line">    <span class="built_in">memcpy</span>(serverInfo.sun_path,processfileName,<span class="built_in">strlen</span>(processfileName));</span><br><span class="line">    <span class="comment">// 端口号都是2字节，short类型，所以一定要注意字节序的问题：</span></span><br><span class="line">    <span class="comment">// 3.绑定网络地址信息结构体：</span></span><br><span class="line">    <span class="type">int</span> ret = bind(listen_fd, (<span class="type">const</span> <span class="keyword">struct</span> sockaddr *)&amp;serverInfo, <span class="keyword">sizeof</span>(serverInfo));</span><br><span class="line">    <span class="keyword">if</span> (ret == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;bind err:&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 4.设置监听的状态：</span></span><br><span class="line">    ret = listen(listen_fd, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (ret == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;listen err:&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// struct sockaddr clientInfo = &#123;0&#125;;//如果关于客户端地址信息就写一个客户端的信息结构体。</span></span><br><span class="line">    <span class="comment">// int clientlen;</span></span><br><span class="line">    <span class="comment">// 5.阻塞等待客户端的连接：</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;本地套接字通信服务进程启动\n&quot;</span>);</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> connect_fd = accept(listen_fd, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">        <span class="keyword">if</span> (connect_fd == <span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            perror(<span class="string">&quot;accept err:&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 数据的收发：</span></span><br><span class="line">            <span class="comment">// 定义用户数据的缓冲区buf;</span></span><br><span class="line">            <span class="type">char</span> buf[<span class="number">128</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">            <span class="type">int</span> nbtyes = read(connect_fd, buf,<span class="keyword">sizeof</span>(buf));</span><br><span class="line">            <span class="keyword">if</span> (nbtyes == <span class="number">-1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                perror(<span class="string">&quot;read err:&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(nbtyes == <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;对端断开了连接\n&quot;</span>);</span><br><span class="line">                close(connect_fd);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;客户端发来的数据为 %s \n&quot;</span>,buf);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="本地间-UDP-通信"><a href="#本地间-UDP-通信" class="headerlink" title="本地间 UDP 通信"></a>本地间 <code>UDP</code> 通信</h2><p>服务器：</p>
<ul>
<li>创建套接字 <code>socket</code></li>
<li>填充服务器本地信息结构体 <code>sockaddr_un</code></li>
<li>将套接字与服务器本地信息结构体绑定 <code>bind</code></li>
<li>进行通信 <code>recvfrom</code> &#x2F; <code>sendto</code></li>
</ul>
<p>客户端：</p>
<ul>
<li>创建套接字 <code>socket</code></li>
<li>填充客户端本地信息结构体 <code>sockaddr_un</code></li>
<li>将套接字与客户端本地信息结构体绑定 <code>bind</code> ，<em>如果不绑定 服务器没法给客户端回信</em></li>
<li>填充服务器本地信息结构体 sockaddr_un</li>
<li>进行通信 sendto&#x2F; recvfrom</li>
</ul>
<p>服务器</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdbool.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netinet/ip.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/un.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> <span class="type">const</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//1.创建用户数据报类套接字本地通信域：</span></span><br><span class="line">    <span class="type">int</span> socket_dgram = socket(AF_LOCAL,SOCK_DGRAM,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(socket_dgram == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;socket err:&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//bind网络信息结构体：</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_un</span> <span class="title">serverInfo</span> =</span> &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    serverInfo.sun_family = AF_LOCAL;</span><br><span class="line">    <span class="comment">//构建本地socket套接字文件：</span></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>* processfileName = <span class="string">&quot;Local_udp_server&quot;</span>;</span><br><span class="line">    <span class="built_in">memcpy</span>(serverInfo.sun_path,processfileName,<span class="built_in">strlen</span>(processfileName));</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> ret = bind(socket_dgram,(<span class="keyword">struct</span> sockaddr*)&amp;serverInfo,<span class="keyword">sizeof</span>(serverInfo));</span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;bind err:&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//接收数据与发送数据：</span></span><br><span class="line">    <span class="comment">//定义一个接收方的信息结构体：</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_un</span> <span class="title">udp_clientInfo</span> =</span> &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="type">int</span> info_len = <span class="keyword">sizeof</span>(udp_clientInfo);</span><br><span class="line">    <span class="comment">//定义一个用户数据的缓冲buf;</span></span><br><span class="line">    <span class="type">char</span> buf[<span class="number">128</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;本地udp进程服务启动\n&quot;</span>);</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">memset</span>(buf,<span class="number">0</span>,<span class="keyword">sizeof</span>(buf));</span><br><span class="line">        <span class="type">int</span> nbytes = recvfrom(socket_dgram,buf,<span class="keyword">sizeof</span>(buf),<span class="number">0</span>,</span><br><span class="line">                (<span class="keyword">struct</span> sockaddr*)&amp;udp_clientInfo,&amp;info_len);</span><br><span class="line">        <span class="keyword">if</span>(nbytes == <span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            perror(<span class="string">&quot;recvfrom err:&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(nbytes == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;没有接收到任何数据\n&quot;</span>);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;udp客户进程文件:[%s] 发来数据-&gt;\n&quot;</span>,</span><br><span class="line">            udp_clientInfo.sun_path);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;udp服务器接收的数据为: %s \n&quot;</span>,buf);</span><br><span class="line">        <span class="comment">//udp 回显：</span></span><br><span class="line">        nbytes = sendto(socket_dgram,buf,<span class="built_in">strlen</span>(buf),<span class="number">0</span>,</span><br><span class="line">        (<span class="keyword">struct</span> sockaddr*)&amp;udp_clientInfo,<span class="keyword">sizeof</span>(udp_clientInfo));</span><br><span class="line">        <span class="keyword">if</span>(nbytes == <span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            perror(<span class="string">&quot;sendto err:&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>客户端</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netinet/ip.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdbool.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/un.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> <span class="type">const</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//构建UDP服务器：</span></span><br><span class="line">    <span class="comment">//1.构建用户数据报套接字：</span></span><br><span class="line">    <span class="type">int</span> udp_fd = socket(AF_LOCAL, SOCK_DGRAM, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (udp_fd == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;socket err:&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2.构建网络地址信息结构体：</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_un</span> <span class="title">udp_serverInfo</span> =</span> &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    udp_serverInfo.sun_family = AF_LOCAL;</span><br><span class="line">    <span class="comment">//改成socket文件的形式：</span></span><br><span class="line">    <span class="comment">//构建本地socket套接字文件：</span></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>* processfileName = <span class="string">&quot;Local_udp_server&quot;</span>;</span><br><span class="line">    <span class="comment">//strncpy(udp_serverInfo.sun_path, processfileName, sizeof(udp_serverInfo.sun_path) - 1);</span></span><br><span class="line">    <span class="built_in">memcpy</span>(udp_serverInfo.sun_path, processfileName,<span class="built_in">strlen</span>(processfileName));</span><br><span class="line">    <span class="comment">//绑定本地的客户端的套接字文件：</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_un</span> <span class="title">udp_clientInfo</span> =</span> &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    udp_clientInfo.sun_family = AF_LOCAL;</span><br><span class="line">    <span class="comment">//改成socket文件的形式：</span></span><br><span class="line">    <span class="comment">//构建本地socket套接字文件：</span></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>* clientfileName = <span class="string">&quot;Local_udp_client&quot;</span>;</span><br><span class="line">    <span class="comment">//strncpy(udp_clientInfo.sun_path, clientfileName, sizeof(udp_clientInfo.sun_path) - 1);</span></span><br><span class="line">    <span class="built_in">memcpy</span>(udp_clientInfo.sun_path, clientfileName,<span class="built_in">strlen</span>(clientfileName));</span><br><span class="line">    <span class="type">socklen_t</span> len = <span class="keyword">sizeof</span>(udp_clientInfo);</span><br><span class="line">    <span class="type">int</span> ret = bind(udp_fd, (<span class="keyword">struct</span> sockaddr*)&amp;udp_clientInfo, len);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//3.定义一用户数据缓冲区：</span></span><br><span class="line">    <span class="type">char</span> buf[<span class="number">128</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">memset</span>(buf, <span class="number">0</span>, <span class="keyword">sizeof</span>(buf));</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;请输入你要发送的udp数据：\n&quot;</span>);</span><br><span class="line">        fgets(buf, <span class="keyword">sizeof</span>(buf), <span class="built_in">stdin</span>);</span><br><span class="line">        <span class="comment">//发送数据：sendto:</span></span><br><span class="line">        <span class="type">int</span> nbytes = sendto(udp_fd, buf, <span class="built_in">strlen</span>(buf), <span class="number">0</span>, (<span class="keyword">struct</span> sockaddr*)&amp;udp_serverInfo, <span class="keyword">sizeof</span>(udp_serverInfo));</span><br><span class="line">        <span class="keyword">if</span> (nbytes == <span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            perror(<span class="string">&quot;sendto err:&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">memset</span>(buf, <span class="number">0</span>, <span class="keyword">sizeof</span>(buf));</span><br><span class="line">        <span class="comment">//接收数据：recvfrom:</span></span><br><span class="line">        nbytes = recvfrom(udp_fd, buf, <span class="keyword">sizeof</span>(buf) - <span class="number">1</span>, <span class="number">0</span>, (<span class="keyword">struct</span> sockaddr*)&amp;udp_clientInfo, &amp;len);</span><br><span class="line">        <span class="keyword">if</span> (nbytes == <span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            perror(<span class="string">&quot;recvfrom err:&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;对端发来的数据为:%s \n&quot;</span>, buf);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="守护进程"><a href="#守护进程" class="headerlink" title="守护进程"></a>守护进程</h1><p>守护进程是后台运行的进程，它会随着系统的启动而启动，会随着系统的终止而终止，类似于 windows 上的各种服务。<br>例如 windows 上的网络管理的服务，ubuntu 上的 <code>sshd</code> 的服务，ubuntu 上的 <strong>资源管理</strong> 的进程</p>
<h2 id="守护进程创建的流程"><a href="#守护进程创建的流程" class="headerlink" title="守护进程创建的流程"></a>守护进程创建的流程</h2><ol>
<li><p>创建孤儿进程</p>
</li>
<li><p>设置孤儿进程的会话id和组id</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">pid_t</span> <span class="title function_">setsid</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="comment">// 功能：设置会话id</span></span><br><span class="line"><span class="comment">// 参数：</span></span><br><span class="line"><span class="comment">//     @无</span></span><br><span class="line"><span class="comment">// 返回值：成功返回新的会话id，失败返回-1，置位错误码</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>切换目录到&#x2F;var&#x2F;log目录下</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">chdir</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *path)</span>;</span><br><span class="line"><span class="comment">// 功能：切换目录</span></span><br><span class="line"><span class="comment">// 参数：</span></span><br><span class="line"><span class="comment">//     @path:路径</span></span><br><span class="line"><span class="comment">// 返回值：成功返回0，失败返回-1置位错误码</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>设置umask的值0</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">mode_t</span> <span class="title function_">umask</span><span class="params">(<span class="type">mode_t</span> mask)</span>;</span><br><span class="line"><span class="comment">// 功能：设置文件的掩码</span></span><br><span class="line"><span class="comment">// 参数：</span></span><br><span class="line"><span class="comment">//     @mask:掩码值</span></span><br><span class="line"><span class="comment">// 返回值：返回设置前的掩码值，总是会成功</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>创建日志文件</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> fd;</span><br><span class="line"><span class="keyword">if</span>((fd = open(<span class="string">&quot;./daemon.log&quot;</span>,O_RDWR|O_CREAT|O_APPEND,<span class="number">0666</span>))==<span class="number">-1</span>)</span><br><span class="line">    PRINT_ERR(<span class="string">&quot;open error&quot;</span>);</span><br></pre></td></tr></table></figure>
</li>
<li><p>文件描述符重定向工作</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">dup2(fd,<span class="number">0</span>);</span><br><span class="line">dup2(fd,<span class="number">1</span>);</span><br><span class="line">dup2(fd,<span class="number">2</span>);</span><br></pre></td></tr></table></figure>
</li>
<li><p>开启自己的服务</p>
</li>
</ol>
<h2 id="文件描述符重定向"><a href="#文件描述符重定向" class="headerlink" title="文件描述符重定向"></a>文件描述符重定向</h2><h3 id="dup-dup2-函数"><a href="#dup-dup2-函数" class="headerlink" title="dup dup2 函数"></a><code>dup</code> <code>dup2</code> 函数</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">dup</span><span class="params">(<span class="type">int</span> oldfd)</span>;</span><br><span class="line"><span class="comment">// 功能：将使用oldfd生成newfd,newfd采用文件描述符最小未使用的原则分配的。</span></span><br><span class="line"><span class="comment">//     oldfd和newfd都能操作文件，两者共用光标。</span></span><br><span class="line"><span class="comment">// 参数：</span></span><br><span class="line"><span class="comment">//     @oldfd:旧的文件描述符</span></span><br><span class="line"><span class="comment">// 返回值：成功返回新的文件描述符，失败返回-1置位错误码</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">dup2</span><span class="params">(<span class="type">int</span> oldfd, <span class="type">int</span> newfd)</span>;</span><br><span class="line"><span class="comment">// 功能：将oldfd重定向到newfd中，newfd是用户自己指定的，如果newfd</span></span><br><span class="line"><span class="comment">//     之前被分配过在使用前会关闭它们。</span></span><br><span class="line"><span class="comment">// 参数：</span></span><br><span class="line"><span class="comment">//     @oldfd:旧的文件描述符</span></span><br><span class="line"><span class="comment">//     @newfd:新的文件描述符</span></span><br><span class="line"><span class="comment">// 返回值：成功返回新的文件描述符，失败返回-1置位错误码</span></span><br></pre></td></tr></table></figure>
<p><code>dup</code></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;head.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span>* argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> fd;</span><br><span class="line">    <span class="keyword">if</span> ((fd = open(<span class="string">&quot;./daemon.log&quot;</span>, O_RDWR | O_CREAT | O_APPEND, <span class="number">0666</span>)) == <span class="number">-1</span>)</span><br><span class="line">        PRINT_ERR(<span class="string">&quot;open error&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//关闭标准输入，标准输出，标准出错</span></span><br><span class="line">    close(<span class="number">0</span>);</span><br><span class="line">    close(<span class="number">1</span>);</span><br><span class="line">    close(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//将0,1,2重定向到文件fd中</span></span><br><span class="line">    dup(fd);</span><br><span class="line">    dup(fd);</span><br><span class="line">    dup(fd);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;hello daemon dup process...\n&quot;</span>);</span><br><span class="line">    fflush(<span class="built_in">stdout</span>);</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>,<span class="string">&quot;this is test daemon dup stderr...\n&quot;</span>);</span><br><span class="line">    lseek(fd,<span class="number">0</span>,SEEK_SET);</span><br><span class="line">    <span class="type">char</span> ch;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%c&quot;</span>,&amp;ch);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;ch = %c\n&quot;</span>,ch);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>dup2</code></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;head.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span>* argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> fd;</span><br><span class="line">    <span class="keyword">if</span> ((fd = open(<span class="string">&quot;./daemon.log&quot;</span>, O_RDWR | O_CREAT | O_APPEND, <span class="number">0666</span>)) == <span class="number">-1</span>)</span><br><span class="line">        PRINT_ERR(<span class="string">&quot;open error&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    dup2(fd,<span class="number">0</span>);</span><br><span class="line">    dup2(fd,<span class="number">1</span>);</span><br><span class="line">    dup2(fd,<span class="number">2</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;hello daemon dup process...\n&quot;</span>);</span><br><span class="line">    fflush(<span class="built_in">stdout</span>);</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>,<span class="string">&quot;this is test daemon dup stderr...\n&quot;</span>);</span><br><span class="line">    lseek(fd,<span class="number">0</span>,SEEK_SET);</span><br><span class="line">    <span class="type">char</span> ch;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%c&quot;</span>,&amp;ch);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;ch = %c\n&quot;</span>,ch);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="守护进程创建的实例"><a href="#守护进程创建的实例" class="headerlink" title="守护进程创建的实例"></a>守护进程创建的实例</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;head.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span>* argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">pid_t</span> pid;</span><br><span class="line">    <span class="type">int</span> fd;</span><br><span class="line">    <span class="keyword">if</span> ((pid = fork()) == <span class="number">-1</span>) &#123;</span><br><span class="line">        PRINT_ERR(<span class="string">&quot;fork error&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (pid == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 1.孤儿进程</span></span><br><span class="line">        <span class="comment">// 2.设置会话id</span></span><br><span class="line">        <span class="keyword">if</span>(setsid()==<span class="number">-1</span>)</span><br><span class="line">            PRINT_ERR(<span class="string">&quot;setsid error&quot;</span>);</span><br><span class="line">        <span class="comment">// 3.切换目录(/var/log/)</span></span><br><span class="line">        <span class="keyword">if</span> (chdir(<span class="string">&quot;/&quot;</span>))</span><br><span class="line">            PRINT_ERR(<span class="string">&quot;chdir error&quot;</span>);</span><br><span class="line">        <span class="comment">// 4.修改掩码</span></span><br><span class="line">        umask(<span class="number">0</span>);</span><br><span class="line">        <span class="comment">// 5.创建日志文件</span></span><br><span class="line">        <span class="keyword">if</span> ((fd = open(<span class="string">&quot;./daemon.log&quot;</span>, O_RDWR | O_CREAT | O_APPEND, <span class="number">0666</span>)) == <span class="number">-1</span>)</span><br><span class="line">            PRINT_ERR(<span class="string">&quot;open error&quot;</span>);</span><br><span class="line">        <span class="comment">// 6.文件描述符重定向</span></span><br><span class="line">        dup2(fd,<span class="number">0</span>);</span><br><span class="line">        dup2(fd,<span class="number">1</span>);</span><br><span class="line">        dup2(fd,<span class="number">2</span>);</span><br><span class="line">        <span class="comment">// 7.开启自己的服务</span></span><br><span class="line">        <span class="type">char</span> s[] = <span class="string">&quot;i am test daemon process\n&quot;</span>;</span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">            write(<span class="number">1</span>,s,<span class="built_in">strlen</span>(s));</span><br><span class="line">            sleep(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 让父进程退出</span></span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h1 id="进程内程序替换函数"><a href="#进程内程序替换函数" class="headerlink" title="进程内程序替换函数"></a>进程内程序替换函数</h1><p>终端执行 <code>a.out</code> 程序, 首先会执行fork产生一个子进程，当产生子进程之后，子进程的 <code>.text</code>段存放的是终端的可执行程序，需要将这个段内的内容替换成 <code>a.out</code> 。此时就可以执行 <code>a.out</code> 应用程序了，以上的功能可以通过 <code>system</code> 完成。 </p>
<h2 id="system-函数"><a href="#system-函数" class="headerlink" title="system 函数"></a><code>system</code> 函数</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">system</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *command)</span>;</span><br><span class="line"><span class="comment">// 功能：首先会fork一个子进程，在子进程内执行command这个可执行程序</span></span><br><span class="line"><span class="comment">// 参数：</span></span><br><span class="line"><span class="comment">//     @command:可执行程序的路径及名字</span></span><br><span class="line"><span class="comment">// 返回值：</span></span><br><span class="line"><span class="comment">//    *如果command为NULL，如果终端可用返回非0，如果终端不可用返回0</span></span><br><span class="line"><span class="comment">//    *如果无法创建子进程，或者无法检索其状态，则返回值为-1。</span></span><br><span class="line"><span class="comment">//    *如果命令不能在子进程中执行，返回退出状态（效果和exit(status)一样的）</span></span><br><span class="line"><span class="comment">//    *如果所有系统调用都成功，则返回值是用于执行命令的子shell的终止状态。</span></span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;head.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span>* argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 首先会创建一个子进程，在子进程内执行&quot;/bin/ls&quot;可执行程序</span></span><br><span class="line">    <span class="comment">//  if(system(&quot;/bin/ls -l&quot;))</span></span><br><span class="line">    <span class="comment">//      PRINT_ERR(&quot;system error&quot;);</span></span><br><span class="line">	</span><br><span class="line">    <span class="comment">// if(system(&quot;./b.out&quot;))</span></span><br><span class="line">    <span class="comment">//     PRINT_ERR(&quot;system error&quot;);</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (system(<span class="string">&quot;./myshell.sh 111 222 333 4444 555&quot;</span>))</span><br><span class="line">        PRINT_ERR(<span class="string">&quot;system error&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="函数接口"><a href="#函数接口" class="headerlink" title="函数接口"></a>函数接口</h1><p><code>fopen</code> <code>fclose</code> <code>fgetc</code> <code>fputc</code> <code>fgets</code> <code>fputs</code> <code>fread</code> <code>fwrite</code> <code>fseek</code> <code>ftell</code> <code>rewind</code><br><code>perror</code> <code>strerror</code> <code>snprintf</code> <code>sprintf</code> <code>fprintf</code> <code>time</code> <code>localtime</code><br><code>open</code> <code>read</code> <code>write</code> <code>close</code> <code>lseek</code> <code>stat</code> <code>lstat</code> <code>getpwuid</code> <code>getgrgid</code><br><code>opendir</code> <code>readdir</code> <code>closedir</code><br><code>fork</code> <code>getpid</code> <code>getppid</code> <code>exit</code> <code>_exit</code> <code>wait</code> <code>waitpid</code> <code>dup</code> <code>dup2</code> <code>system</code><br><code>pthread_create</code> <code>pthread_self</code> <code>pthread_exit</code> <code>pthread_join</code> <code>pthread_detach</code> <code>pthread_cancel</code><br><code>pthread_mutex_init</code> <code>pthread_mutex_lock</code> <code>pthread_mutex_unlock</code> <code>pthread_mutex_destroy</code><br><code>sem_init</code> <code>sem_wait</code> <code>sem_post</code> <code>sem_destroy</code><br><code>pthread_cond_init</code> <code>pthread_cond_wait</code> <code>pthread_cond_signal</code><br><code>pthread_cond_broatcast</code> <code>pthread_cond_destroy</code><br><code>pipe</code> <code>mkfifo</code> <code>signal</code> <code>kill</code> <code>raise</code> <code>alarm</code><br><code>ftok</code> <code>msgget</code> <code>msgsnd</code> <code>msgrcv</code> <code>msgctl</code><br><code>shmget</code> <code>shmat</code> <code>shmdt</code> <code>shmctl</code><br><code>semget</code> <code>semctl</code> <code>semop</code></p>
]]></content>
  </entry>
  <entry>
    <title>套接字</title>
    <url>/2022/11/15/%E5%A5%97%E6%8E%A5%E5%AD%97/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>高并发</title>
    <url>/2022/12/10/%E9%AB%98%E5%B9%B6%E5%8F%91/</url>
    <content><![CDATA[<p>本文包含高并发相关的知识。以及一些高并发解决方案。</p>
<span id="more"></span>

<h1 id="前置"><a href="#前置" class="headerlink" title="前置"></a>前置</h1><h2 id="并发"><a href="#并发" class="headerlink" title="并发"></a>并发</h2><p>并发服务器可以同时处理多个请求，但它们是在同一个处理器或者计算机核心上交替执行的。在并发服务器中，服务器可以同时响应多个请求，但是每个请求必须等待前一个请求完成之后才能继续执行，因为它们共享同一个处理器资源。这种方式可以通过使用多线程、多进程、事件驱动等技术来实现，可以充分利用计算机的多核心资源。  </p>
<p>虽然 CPU 在同一时刻只能执行一个任务，但是通过将 CPU 的使用权在恰当的时机分配给不同的任务，使得多个任务在视觉上看起来是一起执行的。CPU 的执行速度极快，多任务切换的时间也极短，用户根本感受不到，所以并发执行看起来才跟真的一样。  </p>
<h2 id="并行"><a href="#并行" class="headerlink" title="并行"></a>并行</h2><p>并行服务器则是可以同时处理多个请求，并且这些请求是在多个处理器或计算机核心上并行执行的。在并行服务器中，不同的请求可以被分配到不同的处理器或计算机核心上并行执行，因此可以更快地完成任务。这种方式可以通过使用分布式计算、集群等技术来实现，可以充分利用多台或多核计算机的计算资源。 </p>
<p>双核 CPU 执行两个任务时，每个核心各自执行一个任务，和单核 CPU 在两个任务之间不断切换相比，它的执行效率更高。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>因此，单核CPU上运行多进程或多线程，只能实现并发执行；如果在多核CPU上运行多进程或多线程，可以实现并行执行。虽然并发服务器和并行服务器都可以处理多个请求，但它们的处理方式和资源利用方式是不同的。</p>
<p>并发服务器主要是在单个处理器或计算机核心上交替处理多个请求，而并行服务器则是在多个处理器或计算机核心上同时处理多个请求。</p>
<h1 id="IO-操作"><a href="#IO-操作" class="headerlink" title="IO 操作"></a>IO 操作</h1><h2 id="阻塞-IO"><a href="#阻塞-IO" class="headerlink" title="阻塞 IO"></a>阻塞 IO</h2><p>阻塞式IO是一种同步IO操作方式，即在进行IO操作时，程序会一直阻塞等待，直到IO操作完成后才会继续执行下一步操作。在网络编程中，通常会使用阻塞式IO进行数据的读取和发送等操作。  </p>
<p><strong>优点</strong>: 操作简单易用</p>
<p><strong>缺点</strong>: 只能处理一个IO操作，无法同时处理多个连接，可能会导致程序的效率低下。</p>
<h2 id="非阻塞-IO"><a href="#非阻塞-IO" class="headerlink" title="非阻塞 IO"></a>非阻塞 IO</h2><p>非阻塞式 IO 是一种异步 IO 操作方式，即在进行 IO 操作时，程序会立即返回，并继续执行其他操作，而不是一直等待IO操作完成。</p>
<p>程序可以通过不断查询 IO 操作的状态，来检测 IO 操作是否完成。在网络编程中，通常会使用非阻塞式 IO 配合轮询或信号等方式，来实现多个连接的同时处理。</p>
<p><strong>优点</strong>: 可以处理多个连接，提高程序的并发性和响应速度</p>
<p><strong>缺点</strong>: 增加了程序的复杂度，需要进行状态查询，可能会浪费CPU资源。</p>
<h3 id="非阻塞-IO-的实现"><a href="#非阻塞-IO-的实现" class="headerlink" title="非阻塞 IO 的实现"></a>非阻塞 IO 的实现</h3><p>在 Linux 中可以使用 <code>fcntl</code> 系统调用来设置非阻塞 IO</p>
<p><code>fcntl</code> 是 Unix &#x2F; Linux 系统下的一个系统调用函数，全称：<code>file control</code><br>用于对已经打开的文件描述符进行一些控制操作，如复制文件描述符，修改文件状态标志等。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">fcntl</span><span class="params">(<span class="type">int</span> fd, <span class="type">int</span> cmd, ... <span class="comment">/* arg */</span> )</span>;</span><br><span class="line"><span class="comment">// 功能：对已经打开的文件描述符进行一些控制操作</span></span><br><span class="line"><span class="comment">// 参数：</span></span><br><span class="line"><span class="comment">//      @fd : 需要操作的文件描述符</span></span><br><span class="line"><span class="comment">//      @cmd : 控制命令，</span></span><br><span class="line"><span class="comment">//          F_DUPFD：复制文件描述符，可以用来获取一个新的文件描述符，</span></span><br><span class="line"><span class="comment">//                   该文件描述符与原来的描述符指向同一个文件。</span></span><br><span class="line"><span class="comment">//          F_GETFD：获取文件描述符的标记值（close-on-exec）。</span></span><br><span class="line"><span class="comment">//          F_SETFD：设置文件描述符的标记值。</span></span><br><span class="line"><span class="comment">//          F_GETFL：获取文件状态标志。</span></span><br><span class="line"><span class="comment">//          F_SETFL：设置文件状态标志。</span></span><br><span class="line"><span class="comment">//          F_GETLK：获取文件锁信息。</span></span><br><span class="line"><span class="comment">//          F_SETLK：设置文件锁。</span></span><br><span class="line"><span class="comment">//          F_SETLKW：设置文件锁，如果无法获取锁，则阻塞等待锁的释放。</span></span><br><span class="line"><span class="comment">//          F_GETOWN：获取文件所有者的进程。</span></span><br><span class="line"><span class="comment">//          F_SETOWN：设置文件所有者的进程。</span></span><br><span class="line"><span class="comment">//      @arg : 可选的参数，具体的含义和使用方式取决于cmd参数。如果不需要额外参数可写0或不写。</span></span><br><span class="line"><span class="comment">//          O_APPEND：写入时追加到文件末尾。</span></span><br><span class="line"><span class="comment">//          O_NONBLOCK：以非阻塞方式打开文件。</span></span><br><span class="line"><span class="comment">//          O_SYNC：强制写入到磁盘。</span></span><br><span class="line"><span class="comment">//          O_ASYNC：启用异步通知。</span></span><br><span class="line"><span class="comment">// 返回值: 成功返回0，失败返回-1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 文件锁分为共享锁和独占锁两种类型，</span></span><br><span class="line"><span class="comment">// 可以通过fcntl函数设置和获取文件锁信息，实现文件读写的同步控制。</span></span><br></pre></td></tr></table></figure>

<h2 id="异步-IO"><a href="#异步-IO" class="headerlink" title="异步 IO"></a>异步 IO</h2><p>异步 IO 与非阻塞式 IO 相比，异步 IO 通过回调函数的方式来处理IO操作的完成事件，避免了阻塞和轮询等开销，程序的效率更高。</p>
<p><strong>优点</strong>: 能够处理大量的并发IO请求，适合高并发场景</p>
<p><strong>缺点</strong>: 是增加了程序的复杂度，代码可读性差，难以调试和维护。</p>
<p>异步模式 是一种编程模式，其特点是在调用一个耗时的操作时不会阻塞程序的执行，而是通过回调函数的方式在操作完成后再通知程序进行处理。在异步模式下，程序可以同时处理多个操作，提高了程序的并发性和响应速度。</p>
<h3 id="内核事件轮询机制"><a href="#内核事件轮询机制" class="headerlink" title="内核事件轮询机制"></a>内核事件轮询机制</h3><p>内核事件轮询检测（Kernel polling）是一种用于检测设备或文件描述符是否有数据可读或可写的技术。  </p>
<p>比如一般情况下，在计算中，当一个进程需要从非阻塞IO描述符中读取或写入数据时，通常会使用一个循环，不停的检测IO接口描述符中是否有数据产生，如果有就读取，如果没有就继续循环检测，但这样会大量的无效轮询，浪费大量的CPU资源。</p>
<p><strong>内核事件轮询检测技术</strong> 可以解决这个问题，<br>它通过在内核中注册一个回调函数，当设备或文件描述符的状态发生变化时，内核会调用该回调函数，通知进程可以进行读取或写入操作。这种方式避免了进程在等待过程中的无效轮询，从而提高了CPU的利用率。</p>
<p>异步模式通常使用事件循环来实现，程序通过注册事件和回调函数的方式告诉事件循环要监听哪些事件，当事件发生时，事件循环会自动调用相应的回调函数进行处理。</p>
<p>事件循环可以使用操作系统提供的API（<code>epoll</code>、<code>kqueue</code> 等）或者第三方库（<code>libevent</code>、<code>libuv</code> 等）来实现。</p>
<h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdbool.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="comment">// 修改文件描述符的行为或属性的方式：</span></span><br><span class="line"><span class="comment">// fcntl函数：</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">set_nonblock</span><span class="params">(<span class="type">int</span> fd)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//获取文件描述符操作状态</span></span><br><span class="line">    <span class="type">int</span> flags = fcntl(fd, F_GETFL, <span class="number">0</span>);</span><br><span class="line">    <span class="comment">//增加文件描述符操作状态为非阻塞.</span></span><br><span class="line">    flags |= O_NONBLOCK;</span><br><span class="line">    <span class="comment">//用新的状态设置文件描述符。</span></span><br><span class="line">    <span class="keyword">if</span> (fcntl(fd, F_SETFL, flags) == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;fcntl err:&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 当异步信号发出时，自动执行的函数：槽函数：</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> mouse_fd = <span class="number">-1</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">async_slots_functions</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> buf[<span class="number">128</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="type">int</span> nbytes = read(mouse_fd, buf, <span class="keyword">sizeof</span>(buf) - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (nbytes == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;read err:&quot;</span>);</span><br><span class="line">        usleep(<span class="number">10000</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d读取了%d \n&quot;</span>,i++, nbytes);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置异步IO通知：</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">set_async</span><span class="params">(<span class="type">int</span> fd)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//1.获取文件描述符的操作行为的状态。</span></span><br><span class="line">    <span class="type">int</span> flags = fcntl(fd, F_GETFL, <span class="number">0</span>);</span><br><span class="line">    <span class="comment">//2.添加异步通知操作状态。</span></span><br><span class="line">    flags |= O_ASYNC;</span><br><span class="line">    <span class="comment">//3.设置状态到描述符之中</span></span><br><span class="line">    <span class="keyword">if</span> (fcntl(fd, F_SETFL, flags) == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;fcntl err:&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//4.设置文件描述符异步通知的进程为：当前进程。</span></span><br><span class="line">    <span class="keyword">if</span> (fcntl(fd, F_SETOWN, getpid()) == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;fcntl err:&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//5.设置异步通知回调的执行函数：异步信号处理槽函数：</span></span><br><span class="line">    signal(SIGIO, async_slots_functions);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> <span class="type">const</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    mouse_fd = open(<span class="string">&quot;/dev/input/mouse0&quot;</span>, O_RDONLY);</span><br><span class="line">    <span class="keyword">if</span> (mouse_fd == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;open err:&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 用户数据缓冲区：</span></span><br><span class="line">    <span class="type">char</span> buf[<span class="number">128</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="comment">// set_nonblock(mouse_fd);</span></span><br><span class="line">    set_async(mouse_fd);</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">static</span> <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d大家好,才是真的好！\n&quot;</span>, i++);</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="IO-多路复用"><a href="#IO-多路复用" class="headerlink" title="IO 多路复用"></a>IO 多路复用</h2><p>IO多路复用本身是使用单个线程来同时处理多个连接的IO请求。在网络编程中，常见的IO多路复用方式包括<code>select</code>、<code>poll</code> 和 <code>epoll</code>等。</p>
<p><strong>优点</strong>: 可以避免创建大量的线程或进程来处理IO请求，提高了程序的效率，同时可以处理大量的并发IO请求。</p>
<p><strong>缺点</strong>: 增加了程序的复杂度，需要进行状态查询，同时IO多路复用的实现方式不同，可能会存在性能差异。</p>
<h2 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h2><p>不同的IO操作方式各有优缺点，应根据具体场景和需求选择合适的方式。</p>
<p><strong>高并发</strong> 的网络编程中，可以使用 IO 多路复用技术来实现非阻塞式IO操作，同时避免了线程和进程的创建，提高了程序的效率。<br><strong>低并发</strong> 的场景中，可以使用阻塞式IO操作，简单易用。</p>
<p><strong>高性能</strong> 和 <strong>高并发</strong> 的网络编程中，可以结合使用多种IO操作方式，如使用异步IO技术来处理大量的并发IO请求，使用IO多路复用技术来实现非阻塞式IO操作，提高程序的效率和响应速度。</p>
<p><strong>非阻塞式IO</strong> 和 <strong>IO多路复用</strong> 技术通常被使用在 <strong>高并发</strong> 的网络编程中。<br><strong>非阻塞式IO</strong> 通过轮询或信号等方式来实现多个连接的同时处理，可以减少阻塞等待IO操作完成的时间，提高程序的效率。<br><strong>IO多路复用</strong> 技术则是通过一个线程来同时处理多个连接的IO请求，减少了线程和进程的创建，降低了系统开销，提高了程序的效率和响应速度。</p>
<h1 id="多进程并发"><a href="#多进程并发" class="headerlink" title="多进程并发"></a>多进程并发</h1><p>多进程技术在其他文章已经说明，这里不再赘述。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">sigaction</span><span class="params">(<span class="type">int</span> signum, <span class="type">const</span> <span class="keyword">struct</span> sigaction *act, <span class="keyword">struct</span> sigaction *oldact)</span>;</span><br><span class="line"><span class="comment">// 功能：注册信号处理函数</span></span><br><span class="line"><span class="comment">// 参数：</span></span><br><span class="line"><span class="comment">//      @signum : 表示所要处理的信号的编号。</span></span><br><span class="line"><span class="comment">//      @act : 是一个指向struct sigaction类型的结构体指针，该结构体定义了对该信号的处理方式，</span></span><br><span class="line"><span class="comment">//            包括指定处理函数、处理标志等。如果该参数为NULL，则忽略信号。</span></span><br><span class="line"><span class="comment">//            sigaction &#123;</span></span><br><span class="line"><span class="comment">//                void (*sa_handler)(int);         // 信号处理函数指针</span></span><br><span class="line"><span class="comment">//                void (*sa_sigaction)(int, siginfo_t *, void *); // 替代的信号处理函数指针</span></span><br><span class="line"><span class="comment">//                sigset_t sa_mask;                // 额外屏蔽的信号集</span></span><br><span class="line"><span class="comment">//                int sa_flags;                    // 用于指定信号处理的标志</span></span><br><span class="line"><span class="comment">//                void (*sa_restorer)(void);        // 过时的恢复函数指针</span></span><br><span class="line"><span class="comment">//            &#125;;</span></span><br><span class="line"><span class="comment">//      @oldact : 参数是一个指向struct sigaction类型的结构体指针，用于保存原来的信号处理方式。</span></span><br><span class="line"><span class="comment">//                如果该参数为NULL，则忽略原来的信号处理方式。</span></span><br><span class="line"><span class="comment">// 返回值：</span></span><br><span class="line"><span class="comment">//      成功时返回0，失败时返回-1。</span></span><br></pre></td></tr></table></figure>

<p><img src="/../image/concurrence1.png" alt="concurrence 1"></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netinet/ip.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdbool.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//回收资源的函数：</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">recyle_res</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> pid = waitpid(<span class="number">-1</span>,<span class="literal">NULL</span>,<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;回收了子进程%d的资源\n&quot;</span>,pid);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> <span class="type">const</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 1.创建流式监听套接字类型：</span></span><br><span class="line">    <span class="type">int</span> listen_fd = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (listen_fd == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;socket() err:&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 2.定义一个网络地址信息结构体：</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">serverInfo</span>;</span></span><br><span class="line">    <span class="built_in">memset</span>(&amp;serverInfo, <span class="number">0</span>, <span class="keyword">sizeof</span>(serverInfo));</span><br><span class="line">    serverInfo.sin_family = AF_INET;</span><br><span class="line">    <span class="comment">// 端口号都是2字节，short类型，所以一定要注意字节序的问题：</span></span><br><span class="line">    serverInfo.sin_port = htons(<span class="number">9999</span>);</span><br><span class="line">    serverInfo.sin_addr.s_addr = inet_addr(<span class="string">&quot;192.168.250.100&quot;</span>);</span><br><span class="line">    <span class="comment">// 3.绑定网络地址信息结构体：</span></span><br><span class="line">    <span class="type">int</span> ret = bind(listen_fd, (<span class="type">const</span> <span class="keyword">struct</span> sockaddr *)&amp;serverInfo, <span class="keyword">sizeof</span>(serverInfo));</span><br><span class="line">    <span class="keyword">if</span> (ret == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;bind err:&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 4.设置监听的状态：</span></span><br><span class="line">    ret = listen(listen_fd, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (ret == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;listen err:&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;多进程服务器启动\n&quot;</span>);</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> connect_fd = accept(listen_fd,<span class="literal">NULL</span>,<span class="literal">NULL</span>);</span><br><span class="line">        <span class="keyword">if</span>(connect_fd == <span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            perror(<span class="string">&quot;connect err:&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//创建子进程来处理链接套接字中的事务：</span></span><br><span class="line">        <span class="type">int</span> pid = fork();</span><br><span class="line">        <span class="keyword">if</span>(pid == <span class="number">0</span>)<span class="comment">//子进程</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">char</span> buf[<span class="number">128</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">memset</span>(buf,<span class="number">0</span>,<span class="keyword">sizeof</span>(buf));</span><br><span class="line">                <span class="type">int</span> nbytes = read(connect_fd,buf,<span class="keyword">sizeof</span>(buf)<span class="number">-1</span>);</span><br><span class="line">                <span class="keyword">if</span>(nbytes == <span class="number">-1</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    perror(<span class="string">&quot;read err:&quot;</span>);</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(nbytes == <span class="number">0</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;对方断开链接\n&quot;</span>);</span><br><span class="line">                    close(connect_fd);</span><br><span class="line">                    <span class="built_in">exit</span>(<span class="number">0</span>);<span class="comment">//SIGCHILD</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;客户端发来的数据：%s \n&quot;</span>,buf);</span><br><span class="line">                <span class="comment">//回显示：</span></span><br><span class="line">                nbytes = write(connect_fd,buf,<span class="built_in">strlen</span>(buf));</span><br><span class="line">                <span class="keyword">if</span>(nbytes == <span class="number">-1</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    perror(<span class="string">&quot;write err:&quot;</span>);</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(pid &gt; <span class="number">0</span>)<span class="comment">//父进程：</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//认识信号注册函数sigaction:</span></span><br><span class="line">            <span class="keyword">struct</span> sigaction sa = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">            sa.sa_handler = recyle_res;</span><br><span class="line">            sa.sa_flags = SA_RESTART;</span><br><span class="line">            <span class="comment">//异步信号处理子进程的资源回收的问题：</span></span><br><span class="line">            sigaction(SIGCHLD,&amp;sa,<span class="literal">NULL</span>);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            perror(<span class="string">&quot;fork err:&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>多进程并发服务器最大可并发的连接是有限的</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">ulimit</span> -a <span class="comment"># 查看系统的资源限制</span></span><br></pre></td></tr></table></figure>

<h1 id="多线程并发"><a href="#多线程并发" class="headerlink" title="多线程并发"></a>多线程并发</h1><p>多进程技术在其他文章已经说明，这里不再赘述。</p>
<p>在 Linux 中一个进程可以创建子线程数量可以通过以下路径配置文件查看：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">cat</span> /proc/sys/kernel/threads-max <span class="comment">#也可以通过修改这个配置文件中的数量增加线程量。</span></span><br></pre></td></tr></table></figure>

<p>理论上一个进程，可以创建很多线程，但一个进程可以创建的最大线程数受到许多因素的影响，例如系统硬件资源、进程的配置、线程的堆栈大小、进程的虚拟内存限制等等。</p>
<p>在 Linux 中，每个线程都有一个独立的内核栈，用于存储线程的执行上下文、局部变量、函数调用栈等信息。每个线程的内核栈的大小是固定的，并且由系统内核在创建线程时分配和初始化。</p>
<p>每个线程都有两种类型的栈：用户栈和内核栈。<br><strong>用户栈</strong> 用于存储线程的执行上下文、局部变量、函数调用栈等信息，是线程执行代码时的主要工作区域。<br><strong>内核栈</strong> 用于存储线程在内核中执行时所需要的状态信息，例如系统调用、中断处理等。<br>内核栈和用户栈是两个独立的栈，分别用于不同的目的。</p>
<p>线程的内核栈和用户栈在概念上是不同的，但在实际实现中，它们可能使用同一块物理内存。例如，在 x86 架构上，线程的内核栈和用户栈都是在同一块物理内存区域中，但是它们使用不同的段寄存器来访问这个内存区域。</p>
<p><strong>注意</strong>: 线程的内核栈和用户栈的大小是可以独立设置的。在大多数情况下，<br><strong>用户栈</strong> 的大小由编译器和链接器决定<br><strong>内核栈</strong> 的大小可以通过调用 <code>pthread_attr_setstacksize</code> 函数来设置。<br>线程的用户栈和内核栈在使用上有一些不同之处，但它们共同构成了线程的执行环境。在大多数 Linux 系统中，线程的内核栈的大小通常在 2MB 左右。</p>
<blockquote>
<p>线程的内核栈的大小是与线程的数量有关的。如果系统中创建了大量的线程，并且每个线程的内核栈大小都很大，那么可能会导致系统资源不足，从而影响系统的性能和稳定性。因此，在创建线程时，需要根据实际应用的需求和系统的硬件资源情况来设置线程的内核栈大小，以达到最佳的性能和可靠性。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netinet/ip.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdbool.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//子线程执行的函数：</span></span><br><span class="line"><span class="type">void</span> * <span class="title function_">subThreadTask</span><span class="params">(<span class="type">void</span>* arg)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> connect_fd = *(<span class="type">int</span>*)arg;</span><br><span class="line">    <span class="type">char</span> buf[<span class="number">128</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">memset</span>(buf,<span class="number">0</span>,<span class="keyword">sizeof</span>(buf));</span><br><span class="line">        <span class="type">int</span> nbytes = read(connect_fd,buf,<span class="keyword">sizeof</span>(buf)<span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">if</span>(nbytes == <span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(nbytes == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;对方已经关闭了\n&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//打印一下：</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;客户端发来的数据: %s \n&quot;</span>,buf);</span><br><span class="line">        <span class="comment">//回显服务器：</span></span><br><span class="line">        nbytes = write(connect_fd,buf,<span class="built_in">strlen</span>(buf));</span><br><span class="line">        <span class="keyword">if</span>(nbytes == <span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            perror(<span class="string">&quot;write err:&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> <span class="type">const</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> listen_fd = socket(AF_INET,SOCK_STREAM,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(listen_fd == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;socket err:&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//创建网络信息结构体：</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">serverInfo</span> =</span> &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    serverInfo.sin_family = AF_INET;</span><br><span class="line">    serverInfo.sin_port = htons(<span class="number">8080</span>);</span><br><span class="line">    serverInfo.sin_addr.s_addr = INADDR_ANY;</span><br><span class="line">    <span class="comment">//bind:</span></span><br><span class="line">    <span class="type">int</span> ret = bind(listen_fd,(<span class="keyword">struct</span> sockaddr*)&amp;serverInfo,<span class="keyword">sizeof</span>(serverInfo));</span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;bind err:&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//设置套接字为监听套接字：</span></span><br><span class="line">    ret = listen(listen_fd,<span class="number">5</span>);</span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;liseten err:&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;多线程并发服务器启动\n&quot;</span>);</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> connect_fd = accept(listen_fd,<span class="literal">NULL</span>,<span class="literal">NULL</span>);</span><br><span class="line">        <span class="keyword">if</span>(connect_fd == <span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//1.创建子线程：</span></span><br><span class="line">        <span class="type">pthread_t</span> subThreadId;</span><br><span class="line">        pthread_create(&amp;subThreadId,<span class="literal">NULL</span>,subThreadTask,(<span class="type">void</span>*)&amp;connect_fd);</span><br><span class="line">        <span class="comment">//2.设定为分离态：</span></span><br><span class="line">        pthread_detach(subThreadId);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="IO-多路复用-1"><a href="#IO-多路复用-1" class="headerlink" title="IO 多路复用"></a>IO 多路复用</h1><p>IO多路复用 <code>IO multiplexing</code> 是一种高效的网络编程技术，可以在单个线程中处理多个I&#x2F;O事件，从而提高程序的并发性能和效率，它允许一个进程同时监听多个文件描述符 <code>sockets</code>，并等待其中任何一个文件描述符可读或可写事件产生时立即响应。</p>
<p>在Linux中，常用的IO多路复用机制包括 <code>select</code>、<code>poll</code> 和 <code>epoll</code>。<br>相比于阻塞IO和非阻塞IO，IO多路复用的优势在于可以避免轮询、提高IO响应速度，同时也可以减少CPU占用率。</p>
<h2 id="IO-多路复用的方式"><a href="#IO-多路复用的方式" class="headerlink" title="IO 多路复用的方式"></a>IO 多路复用的方式</h2><p><code>select</code>、<code>poll</code> 和 <code>epoll</code> 都是 I&#x2F;O 多路复用的机制，它们的目的是：在不创建新线程的情况下支持多客户端连接，并实现高并发的网络编程。因此，它们建立的服务器一般都是单线程的。</p>
<p>这些机制的工作原理是通过单个线程同时监听多个客户端连接的事件，当有事件发生时，再对相应的事件进行处理。由于单个线程只需要负责监听和处理 I&#x2F;O 事件，所以无需创建多个线程，就能支持多客户端连接。  </p>
<h2 id="使用流程"><a href="#使用流程" class="headerlink" title="使用流程"></a>使用流程</h2><ol>
<li>首先要创建一个文件描述符的集合。（数据结构）</li>
<li>把关心的文件描述符放入到这个集合之中。</li>
<li>使用 <code>select</code>、<code>poll</code>、<code>epoll</code> 等这个 linux 中的系统调用，把关心的文件描述符的集合放在入到内核态中，由内核事件监测事件机制来监测集合中描述的事件的产生。</li>
<li>当事件产生时，相应的 <code>select</code>、<code>poll</code>、或 <code>epoll_wait</code> 函数则马上解除阻塞，并返回有事件的文件描述符的个数。</li>
<li>在进程中马上处理这些有事件的文件描述符。</li>
</ol>
<p><img src="/../image/concurrence2.png" alt="concurrence 2"></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/select.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="comment">// 1. fd_set为文件描述符集合类型，是一个结构体：</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FD_SETSIZE = 1024</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">fd_set</span> &#123;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> fds_bits[FD_SETSIZE / (<span class="number">8</span> * <span class="keyword">sizeof</span>(<span class="type">long</span>))];<span class="comment">//位图</span></span><br><span class="line">&#125; fd_set;</span><br><span class="line"><span class="comment">//所在fd_set结构体类型是一个位域数组。共1024个bit位的数组，所以它可以保存1024描述符的是否就绪状态。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. select接口API:</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">select</span><span class="params">(<span class="type">int</span> nfds, fd_set *readfds, fd_set *writefds, fd_set *exceptfds, <span class="keyword">struct</span> timeval *timeout)</span>;</span><br><span class="line"><span class="comment">// 功能：监控一组文件描述符的状态，当其中有描述符就绪时，函数返回，并且可以知道哪些描述符已经就绪。</span></span><br><span class="line"><span class="comment">// 参数：</span></span><br><span class="line"><span class="comment">//      @nfds : 需要监控的文件描述符的个数，即文件描述符集合中最大的文件描述符加1。</span></span><br><span class="line"><span class="comment">//      @readfds : 读文件描述符集合。</span></span><br><span class="line"><span class="comment">//      @writefds : 写文件描述符集合。</span></span><br><span class="line"><span class="comment">//      @exceptfds : 异常文件描述符集合。</span></span><br><span class="line"><span class="comment">//      @timeout : 超时时间，如果在指定的时间内没有任何文件描述符就绪，则返回0，否则返回就绪的文件描述符的个数。</span></span><br><span class="line"><span class="comment">// 返回值：</span></span><br><span class="line"><span class="comment">//      成功时返回就绪的文件描述符的个数，失败时返回-1。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 配合select完成任务的几个宏函数：</span></span><br><span class="line"><span class="comment">// 1.用于将指定的文件描述符fd从文件描述符集合set中删除。</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">FD_CLR</span><span class="params">(<span class="type">int</span> fd, fd_set *<span class="built_in">set</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2.用于判断指定的文件描述符fd是否在文件描述符集合set中，如果存在，则返回非零值，否则返回0。</span></span><br><span class="line"><span class="type">int</span>  <span class="title function_">FD_ISSET</span><span class="params">(<span class="type">int</span> fd, fd_set *<span class="built_in">set</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3.用于将指定的文件描述符fd加入到文件描述符集合set中</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">FD_SET</span><span class="params">(<span class="type">int</span> fd, fd_set *<span class="built_in">set</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 4.用于将文件描述符集合清空，即将所有位都设为0</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">FD_ZERO</span><span class="params">(fd_set *<span class="built_in">set</span>)</span>;</span><br></pre></td></tr></table></figure>

<h2 id="select-并发"><a href="#select-并发" class="headerlink" title="select 并发"></a><code>select</code> 并发</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdbool.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netinet/ip.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> <span class="type">const</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> listen_fd = socket(AF_INET,SOCK_STREAM,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(listen_fd == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;socket err:&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//构建信息结构体：</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">serverInfo</span> =</span> &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    serverInfo.sin_family = AF_INET;</span><br><span class="line">    serverInfo.sin_port = htons(<span class="number">8080</span>);</span><br><span class="line">    serverInfo.sin_addr.s_addr = INADDR_ANY;</span><br><span class="line">    <span class="comment">//bind:</span></span><br><span class="line">    <span class="type">int</span> ret = bind(listen_fd,(<span class="keyword">struct</span> sockaddr*)&amp;serverInfo,<span class="keyword">sizeof</span>(serverInfo));</span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;bind err:&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//把套接字设定为监听状态：</span></span><br><span class="line">    ret = listen(listen_fd,<span class="number">10</span>);</span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;listen err:&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//设定文件描述符的集合：</span></span><br><span class="line">    fd_set readfd_save_set,readfd_modify_set;</span><br><span class="line">    FD_ZERO(&amp;readfd_save_set);</span><br><span class="line">    <span class="comment">//把要关心文件描述符放入到集合之中：</span></span><br><span class="line">    FD_SET(listen_fd,&amp;readfd_save_set);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//设置个最大描述符：</span></span><br><span class="line">    <span class="type">int</span> maxfd = listen_fd;</span><br><span class="line">    <span class="comment">//定义一个用户数据收发的缓冲buf;</span></span><br><span class="line">    <span class="type">char</span> buf[<span class="number">128</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//开启一个循环：</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;开启一个小型的select并发服务器\n&quot;</span>);</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        readfd_modify_set = readfd_save_set;</span><br><span class="line">        <span class="type">int</span> fds = select(maxfd + <span class="number">1</span>,&amp;readfd_modify_set,<span class="literal">NULL</span>,<span class="literal">NULL</span>,<span class="literal">NULL</span>);</span><br><span class="line">        <span class="keyword">if</span>(fds == <span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            perror(<span class="string">&quot;select err:&quot;</span>);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//一定有事件产生：</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> event_fd = <span class="number">3</span>;event_fd &lt; maxfd + <span class="number">1</span>;event_fd++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(FD_ISSET(event_fd,&amp;readfd_modify_set))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(event_fd == listen_fd)<span class="comment">//有新的客户端的链接。</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="type">int</span> connect_fd = accept(event_fd,<span class="literal">NULL</span>,<span class="literal">NULL</span>);</span><br><span class="line">                    <span class="keyword">if</span>(connect_fd == <span class="number">-1</span>)</span><br><span class="line">                    &#123;</span><br><span class="line">                        perror(<span class="string">&quot;accept err:&quot;</span>);</span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    FD_SET(connect_fd,&amp;readfd_save_set);</span><br><span class="line">                    maxfd = maxfd &gt; connect_fd ? maxfd : connect_fd;</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;客户端与服务建立了连接\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span>&#123;<span class="comment">//有数据可读，意味着可以收发数据了。</span></span><br><span class="line">                    <span class="built_in">memset</span>(buf,<span class="number">0</span>,<span class="keyword">sizeof</span>(buf));</span><br><span class="line">                    <span class="type">int</span> nbytes = read(event_fd,buf,<span class="keyword">sizeof</span>(buf)<span class="number">-1</span>);</span><br><span class="line">                    <span class="keyword">if</span>(nbytes == <span class="number">-1</span>)</span><br><span class="line">                    &#123;</span><br><span class="line">                        perror(<span class="string">&quot;read err:&quot;</span>);</span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span>(nbytes == <span class="number">0</span>)</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="built_in">printf</span>(<span class="string">&quot;客户端已经断开了连接\n&quot;</span>);</span><br><span class="line">                        FD_CLR(event_fd,&amp;readfd_save_set);</span><br><span class="line">                        close(event_fd);</span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">//打印一下对方发来的数据：</span></span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;客户端发来的数据：%s \n&quot;</span>,buf);</span><br><span class="line">                    <span class="comment">//回显：</span></span><br><span class="line">                    nbytes = write(event_fd,buf,<span class="built_in">strlen</span>(buf));</span><br><span class="line">                    <span class="keyword">if</span>(nbytes == <span class="number">-1</span>)</span><br><span class="line">                    &#123;</span><br><span class="line">                        perror(<span class="string">&quot;write err:&quot;</span>);</span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="select-的缺点"><a href="#select-的缺点" class="headerlink" title="select 的缺点"></a>select 的缺点</h3><p><code>select</code>  </p>
<ol>
<li><strong>描述符多时会低效</strong>：每次调用 <code>select</code> 函数时，都会将用户态中的描述符拷贝到内核态，由内核来检测事件的产生，在有事件时，他遍历整个集合，并将相应的位置 1，同时把整个集合再次从内核态再拷贝到用户态，这样会带来很大的开销。当文件描述符集合很大时，这种开销就更加明显。</li>
<li><strong>只支持较小的文件描述符集合</strong>：在一些操作系统中，<code>select</code> 函数对文件描述符集合的大小有限制，一般为1024。这意味着当需要同时监控的文件描述符数量很大时，就不能使用 <code>select</code> 函数了。</li>
<li><strong>事件处理效率低</strong>：当多个文件描述符有事件发生时，select函数只能依次处理每个文件描述符，这样就会导致事件处理效率低下。</li>
</ol>
<p>总之，<code>select</code> 函数在高并发场景下的表现并不理想，一些新的 IO 多路复用技术，如 <code>epoll</code> 和 <code>kqueue</code> 等，已经被广泛采用，以提高性能和可扩展性。</p>
<h2 id="poll-并发"><a href="#poll-并发" class="headerlink" title="poll 并发"></a><code>poll</code> 并发</h2><p>poll构建并发服务器的思路与select是一样的，唯一的区别是：要监测的文件描述符的集合使用的数组。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;poll.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">poll</span><span class="params">(<span class="keyword">struct</span> pollfd *fds, <span class="type">nfds_t</span> nfds, <span class="type">int</span> timeout)</span>;</span><br><span class="line"><span class="comment">// 功能：监控一组文件描述符的状态，当其中有描述符就绪时，函数返回，并且可以知道哪些描述符已经就绪。</span></span><br><span class="line"><span class="comment">// 参数：</span></span><br><span class="line"><span class="comment">//      @fds : 文件描述符集合，是一个指向 pollfd 结构体数组的指针。</span></span><br><span class="line"><span class="comment">//              struct pollfd &#123;</span></span><br><span class="line"><span class="comment">//                  int fd;        // 文件描述符，初始设置为-1，将被忽略;</span></span><br><span class="line"><span class="comment">//                  short events;  // 要监视的事件   event mask short</span></span><br><span class="line"><span class="comment">//                  short revents; // 实际发生的事件 real event mask short</span></span><br><span class="line"><span class="comment">//              &#125;;</span></span><br><span class="line"><span class="comment">//              //额外知识点：掩码主要是用来分类或分段的。可以理解为区分的。</span></span><br><span class="line"><span class="comment">//      @nfds : fds 数组中有效描述符元素的数量</span></span><br><span class="line"><span class="comment">//      @timeout : timeout 是等待时间，单位为毫秒。-1为阻塞</span></span><br><span class="line"><span class="comment">// 返回值：</span></span><br><span class="line"><span class="comment">//      成功时返回就绪的文件描述符的个数，失败时返回-1。</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>需要注意的是，poll 函数在处理大量文件描述符时的性能可能较低，因为每次调用 poll 函数都需要遍历整个 pollfd 数组。为了提高性能，可以使用 epoll 函数来代替 poll 函数。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdbool.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netinet/ip.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;poll.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> <span class="type">const</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> listen_fd = socket(AF_INET,SOCK_STREAM,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(listen_fd == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;socket err:&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//创建网络信息结构体：</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">serverInfo</span> =</span> &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    serverInfo.sin_family = AF_INET;</span><br><span class="line">    serverInfo.sin_port = htons(<span class="number">8080</span>);</span><br><span class="line">    serverInfo.sin_addr.s_addr = INADDR_ANY;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//bind信息结构体：</span></span><br><span class="line">    <span class="type">int</span> ret = bind(listen_fd,(<span class="keyword">struct</span> sockaddr*)&amp;serverInfo,<span class="keyword">sizeof</span>(serverInfo));</span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;bind err:&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//把套接字设定为监听态：</span></span><br><span class="line">    ret = listen(listen_fd,<span class="number">5</span>);</span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;liste err:&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//开启构建poll中型并发服务器：</span></span><br><span class="line">    <span class="comment">//1.创建描述的集合：pollfd事件结构体数组：</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">pollfd</span> <span class="title">fdArray</span>[2048] =</span> &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2048</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        fdArray[i].fd = <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//2.把关心的文件描述符放入到集合，就这是事件结构体数组;</span></span><br><span class="line">    <span class="type">int</span> nfds = <span class="number">0</span>;</span><br><span class="line">    fdArray[nfds].fd = listen_fd;<span class="comment">//关心的文件描述符。</span></span><br><span class="line">    fdArray[nfds].events = POLLIN;<span class="comment">//关心的事件。</span></span><br><span class="line">    nfds++;</span><br><span class="line">    <span class="comment">//用户收入数据缓冲区buf:</span></span><br><span class="line">    <span class="type">char</span> buf[<span class="number">128</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="comment">//3.进入并发循环：</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;poll中型并发服务器启动\n&quot;</span>);</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> n_fd = poll(fdArray,nfds,<span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">if</span>(n_fd == <span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            perror(<span class="string">&quot;poll err:&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//遍历集合：</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; nfds;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//判断集合中的元素是否有你关系的事件：通过revents属性&amp;运算来判断。</span></span><br><span class="line">            <span class="keyword">if</span>(fdArray[i].revents &amp; POLLIN)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(fdArray[i].fd == listen_fd)<span class="comment">//有链接请求：</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="type">int</span> connect_fd = accept(listen_fd,<span class="literal">NULL</span>,<span class="literal">NULL</span>);</span><br><span class="line">                    <span class="keyword">if</span>(connect_fd == <span class="number">-1</span>)</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    fdArray[nfds].fd = connect_fd;</span><br><span class="line">                    fdArray[nfds].events = POLLIN;</span><br><span class="line">                    nfds++;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span>&#123;<span class="comment">//有收发数据的请求：</span></span><br><span class="line">                    <span class="built_in">memset</span>(buf,<span class="number">0</span>,<span class="keyword">sizeof</span>(buf));</span><br><span class="line">                    <span class="type">int</span> nbytes = read(fdArray[i].fd,buf,<span class="keyword">sizeof</span>(buf)<span class="number">-1</span>);</span><br><span class="line">                    <span class="keyword">if</span>(nbytes == <span class="number">-1</span>)</span><br><span class="line">                    &#123;</span><br><span class="line">                        perror(<span class="string">&quot;read err:&quot;</span>);</span><br><span class="line">                        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span>(nbytes == <span class="number">0</span>)</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="built_in">printf</span>(<span class="string">&quot;对方服务器已经关闭\n&quot;</span>);</span><br><span class="line">                        <span class="comment">//关闭套接字的一种方式：</span></span><br><span class="line">                        nfds--;</span><br><span class="line">                        close(fdArray[i].fd);</span><br><span class="line">                        fdArray[i] = fdArray[nfds];</span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">//打印一下客户端发来的数据：</span></span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;客户端发来的数据为:%s \n&quot;</span>,buf);</span><br><span class="line">                    <span class="comment">//回显:</span></span><br><span class="line">                    nbytes = write(fdArray[i].fd,buf,<span class="built_in">strlen</span>(buf));</span><br><span class="line">                    <span class="keyword">if</span>(nbytes == <span class="number">-1</span>)</span><br><span class="line">                    &#123;</span><br><span class="line">                        perror(<span class="string">&quot;write err:&quot;</span>);</span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="epoll-并发"><a href="#epoll-并发" class="headerlink" title="epoll 并发"></a><code>epoll</code> 并发</h2><p><code>epoll</code> 是Linux系统中用于高效处理大量并发连接的一种机制，相比于传统的select和poll函数，具有更高的性能和更好的扩展性，是实现高性能网络服务器的重要工具之一。</p>
<p>在 <code>epoll</code> 机制中，内核使用两个数据结构来维护被监视的文件描述符和对应的事件：一个是红黑树，用于快速查找某个文件描述符的状态；另一个是双向链表，用于保存发生了事件的文件描述符。</p>
<p>具体来说，每个被监视的文件描述符都会在内核中对应一个 <code>epitem</code> 结构体，其中包含了文件描述符的状态信息，如感兴趣的事件类型、事件状态、回调函数等。所有的 <code>epitem</code> 结构体通过一个红黑树连接起来，红黑树的每个节点代表一个文件描述符。</p>
<p>当某个文件描述符上发生了感兴趣的事件时，内核会将该文件描述符的 <code>epitem</code> 结构体从红黑树中取出，并将其插入到一个双向链表中，这个双向链表的头部是 <code>epoll</code> 实例的就绪列表。程序调用 <code>epoll_wait</code> 函数时，会从这个就绪列表中取出已经准备就绪的文件描述符，并将相应的事件返回给程序。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/epoll.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">epoll_create</span><span class="params">(<span class="type">int</span> size)</span>;</span><br><span class="line"><span class="comment">// 功能：创建一个 epoll 实例，返回一个文件描述符，用于后续的 epoll 函数调用。</span></span><br><span class="line"><span class="comment">// 参数：</span></span><br><span class="line"><span class="comment">//      @size : epoll 实例的大小，该参数在创建 epoll 实例时会被忽略，只是用于内核的优化。</span></span><br><span class="line"><span class="comment">// 返回值：</span></span><br><span class="line"><span class="comment">//      成功时返回一个文件描述符，失败时返回-1, 并设置 errno。</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">epoll_ctl</span><span class="params">(<span class="type">int</span> epfd, <span class="type">int</span> op, <span class="type">int</span> fd, <span class="keyword">struct</span> epoll_event *event)</span>;</span><br><span class="line"><span class="comment">// 功能：向 epoll 实例中添加、删除或修改文件描述符。</span></span><br><span class="line"><span class="comment">// 参数：</span></span><br><span class="line"><span class="comment">//      @epfd : epoll 实例的文件描述符。</span></span><br><span class="line"><span class="comment">//      @op : 操作类型</span></span><br><span class="line"><span class="comment">//         EPOLL_CTL_ADD : 向 epoll 实例中添加文件描述符。</span></span><br><span class="line"><span class="comment">//         EPOLL_CTL_MOD : 修改 epoll 实例中的文件描述符。</span></span><br><span class="line"><span class="comment">//         EPOLL_CTL_DEL : 从 epoll 实例中删除文件描述符。</span></span><br><span class="line"><span class="comment">//      @fd : 需要添加、删除或修改的文件描述符。</span></span><br><span class="line"><span class="comment">//      @event : 事件类型，是一个 epoll_event 结构体。</span></span><br><span class="line"><span class="comment">//         struct epoll_event &#123;</span></span><br><span class="line"><span class="comment">//             uint32_t events;</span></span><br><span class="line"><span class="comment">//             epoll_data_t data;</span></span><br><span class="line"><span class="comment">//         &#125;;</span></span><br><span class="line"><span class="comment">//             typedef union epoll_data &#123;</span></span><br><span class="line"><span class="comment">//                 void *ptr;</span></span><br><span class="line"><span class="comment">//                 int fd;</span></span><br><span class="line"><span class="comment">//                 uint32_t u32;</span></span><br><span class="line"><span class="comment">//                 uint64_t u64;</span></span><br><span class="line"><span class="comment">//             &#125; epoll_data_t;</span></span><br><span class="line"><span class="comment">// 返回值：</span></span><br><span class="line"><span class="comment">//      成功时返回0，失败时返回-1, 并设置 errno。</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">epoll_wait</span><span class="params">(<span class="type">int</span> epfd, <span class="keyword">struct</span> epoll_event *events, <span class="type">int</span> maxevents, <span class="type">int</span> timeout)</span>;</span><br><span class="line"><span class="comment">// 功能：等待文件描述符上的事件发生。</span></span><br><span class="line"><span class="comment">// 参数：</span></span><br><span class="line"><span class="comment">//      @epfd : epoll 实例的文件描述符。</span></span><br><span class="line"><span class="comment">//      @events : 用于保存事件的数组。</span></span><br><span class="line"><span class="comment">//      @maxevents : events 数组的大小。</span></span><br><span class="line"><span class="comment">//      @timeout : 等待时间，单位为毫秒</span></span><br><span class="line"><span class="comment">//          -1 : 阻塞等待，直到有事件发生。</span></span><br><span class="line"><span class="comment">//           0 : 不阻塞，立即返回。</span></span><br><span class="line"><span class="comment">//          &gt;0 : 等待指定的时间。</span></span><br><span class="line"><span class="comment">// 返回值：</span></span><br><span class="line"><span class="comment">//      成功时返回就绪的文件描述符的个数，失败时返回-1, 并设置 errno。</span></span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdbool.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netinet/ip.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/epoll.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> <span class="type">const</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> listen_fd = socket(AF_INET,SOCK_STREAM,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(listen_fd == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;socket err:&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//创建网络信息结构体：</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">serverInfo</span> =</span> &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    serverInfo.sin_family = AF_INET;</span><br><span class="line">    serverInfo.sin_port = htons(<span class="number">8080</span>);</span><br><span class="line">    serverInfo.sin_addr.s_addr = INADDR_ANY;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//bind信息结构体：</span></span><br><span class="line">    <span class="type">int</span> ret = bind(listen_fd,(<span class="keyword">struct</span> sockaddr*)&amp;serverInfo,<span class="keyword">sizeof</span>(serverInfo));</span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;bind err:&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//把套接字设定为监听态：</span></span><br><span class="line">    ret = listen(listen_fd,<span class="number">5</span>);</span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;liste err:&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//创建一个文件描述的集合：</span></span><br><span class="line">    <span class="type">int</span> epfd = epoll_create1(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(epfd == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;epoll_create1 err:&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//把关心的文件描述符放入到epoll实例的红黑树中。</span></span><br><span class="line">    <span class="comment">//定义一个事件结构体，把感兴趣的文件描述符与感兴趣事件，加入到epoll实例之中:</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> <span class="title">ev</span> =</span> &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    ev.data.fd = listen_fd;</span><br><span class="line">    ev.events = EPOLLIN;</span><br><span class="line">    ret = epoll_ctl(epfd,EPOLL_CTL_ADD,listen_fd,&amp;ev);</span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;epoll_ctl err:&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//定义一个接收内核发来的有事件的（已经就绪的）文件描述符的集合（数据结构）</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> <span class="title">event_fdArray</span>[256] =</span> &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="comment">//获取最大接收的有事件的个数：</span></span><br><span class="line">    <span class="type">int</span> max_events = <span class="keyword">sizeof</span>(event_fdArray) / <span class="keyword">sizeof</span>(<span class="keyword">struct</span> epoll_event);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//定义一个用户数据缓冲区buf:</span></span><br><span class="line">    <span class="type">char</span> buf[<span class="number">128</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="comment">//进入并发循环：</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;epoll大型并发服务器启动\n&quot;</span>);</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> nfds = epoll_wait(epfd,event_fdArray,max_events,<span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">if</span>(nfds == <span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            perror(<span class="string">&quot;epoll_wait err:&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//遍历事件就绪的描述符的集合：</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; nfds; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(event_fdArray[i].data.fd == listen_fd)<span class="comment">//有链接的请求：</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="type">int</span> connect_fd = accept(listen_fd,<span class="literal">NULL</span>,<span class="literal">NULL</span>);</span><br><span class="line">                <span class="keyword">if</span>(connect_fd == <span class="number">-1</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    perror(<span class="string">&quot;accept err:&quot;</span>);</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                ev.data.fd = connect_fd;</span><br><span class="line">                ev.events = EPOLLIN;</span><br><span class="line">                ret = epoll_ctl(epfd,EPOLL_CTL_ADD,connect_fd,&amp;ev);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;<span class="comment">//有数据读写的请求：</span></span><br><span class="line">                <span class="built_in">memset</span>(buf,<span class="number">0</span>,<span class="keyword">sizeof</span>(buf));</span><br><span class="line">                <span class="type">int</span> nbytes = read(event_fdArray[i].data.fd,buf,<span class="keyword">sizeof</span>(buf)<span class="number">-1</span>);</span><br><span class="line">                <span class="keyword">if</span>(nbytes == <span class="number">-1</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    perror(<span class="string">&quot;read err:&quot;</span>);</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(nbytes == <span class="number">0</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;客户端关闭了连接\n&quot;</span>);</span><br><span class="line">                    ret = epoll_ctl(epfd,EPOLL_CTL_DEL,event_fdArray[i].data.fd,&amp;event_fdArray[i]);</span><br><span class="line">                    <span class="keyword">if</span>(ret == <span class="number">-1</span>)</span><br><span class="line">                    &#123;</span><br><span class="line">                        perror(<span class="string">&quot;epoll_ctl err:&quot;</span>);</span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">//想着关闭无效已经关闭套接字资源。</span></span><br><span class="line">                    close(event_fdArray[i].data.fd);</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;客户端发来的数据：%s \n&quot;</span>,buf);</span><br><span class="line">                <span class="comment">//回显一下：</span></span><br><span class="line">                nbytes = write(event_fdArray[i].data.fd,buf,<span class="built_in">strlen</span>(buf));</span><br><span class="line">                <span class="keyword">if</span>(nbytes == <span class="number">-1</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    perror(<span class="string">&quot;write err:&quot;</span>);</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h2><p><code>epoll</code>、<code>select</code> 和 <code>poll</code> 都是依赖于 <strong>事件检测机制</strong> 的 I&#x2F;O 多路复用的机制，可以同时监听多个文件描述符的读写事件，并在事件发生时通知程序进行处理。它们的实现方式和底层机制不同，因此有以下区别：</p>
<p><strong>应用程序对文件描述符的时间复杂度</strong>：<br>在select和poll中，应用程序需要将要监听的文件描述符集合传递给内核，内核将这些文件描述符复制到内核空间，然后将它们加入到一个由内核维护的数据结构中，然后在等待事件时，应用程序阻塞等待内核通知有事件发生，内核查找事件集合的时间复杂度为O(n)<br>在epoll中，应用程序需要将要监听的文件描述符加入到一个由内核维护的红黑树中，然后在等待事件时,当有事件发生时，内核会在红黑树中查找对应的文件描述符并通知应用程序。内核查找事件树的时间复杂度为O(logN),  在新的kernal2.6之后为散列表，遍历时间为O(1);</p>
<p><strong>文件描述符数量的处理方式</strong>：<br>在select和poll中，每次调用select和poll时，应用程序需要将所有要监听的文件描述符都传递给内核，内核需要遍历所有文件描述符，这样当文件描述符很多时，效率会比较低。<br>在epoll中，应用程序只需要在第一次调用epoll时将所有要监听的文件描述符加入到红黑树中，然后在后续的调用中，只需要传递一个epoll实例，这个实例中包含了之前加入的所有文件描述符，不需要再次传递文件描述符，因此效率会更高。</p>
<p><strong>内存的处理方式</strong>：<br>在select和poll中，内核需要将应用程序传递的文件描述符复制到内核空间，这样会产生一定的内存开销。有事件时，再把这个集合传递到用户进程空间，浪费大量的拷贝与遍历算力。<br>在epoll中，内核只需要在第一次调用epoll时将文件描述符加入红黑树中，后续的调用只需要传递epoll实例，不需要重复传递文件描述符，只传递有事件已经就绪的文件描述符的集合，因此内存开销会比较小，可以大在提升服务器并发的能力。</p>
<p>总之，虽然 <code>select</code>、<code>poll</code> 和 <code>epoll</code> 都是 I&#x2F;O 多路复用的机制，但它们在实现方式和性能上都有所不同，应用程序可以根据自己的需求选择合适的机制。</p>
]]></content>
  </entry>
</search>
