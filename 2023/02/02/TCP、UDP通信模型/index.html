<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":true},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="本文主要位通信协议、网络体系结构、TCP&#x2F;IP协议、常见包头等分析介绍使用。">
<meta property="og:type" content="article">
<meta property="og:title" content="TCP、UDP通信模型">
<meta property="og:url" content="http://example.com/2023/02/02/TCP%E3%80%81UDP%E9%80%9A%E4%BF%A1%E6%A8%A1%E5%9E%8B/index.html">
<meta property="og:site_name" content="境">
<meta property="og:description" content="本文主要位通信协议、网络体系结构、TCP&#x2F;IP协议、常见包头等分析介绍使用。">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/image/SimpleProtocol.png">
<meta property="og:image" content="http://example.com/image/TCPIPModel.png">
<meta property="og:image" content="http://example.com/image/TCPIP.png">
<meta property="og:image" content="http://example.com/image/TCPIPClan.png">
<meta property="og:image" content="http://example.com/image/Package.png">
<meta property="og:image" content="http://example.com/image/DataFrames.png">
<meta property="og:image" content="http://example.com/image/IPHand.png">
<meta property="og:image" content="http://example.com/image/MACHand.png">
<meta property="og:image" content="http://example.com/image/TCPDate.png">
<meta property="og:image" content="http://example.com/image/TCPHandshake.png">
<meta property="og:image" content="http://example.com/image/TCPWave.png">
<meta property="og:image" content="http://example.com/image/KernelBuffer.png">
<meta property="og:image" content="http://example.com/image/UDPData.png">
<meta property="og:image" content="http://example.com/image/UDPModel.png">
<meta property="article:published_time" content="2023-02-02T14:07:08.000Z">
<meta property="article:modified_time" content="2023-09-28T04:22:32.243Z">
<meta property="article:author" content="XiaoMingMingBai">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/image/SimpleProtocol.png">

<link rel="canonical" href="http://example.com/2023/02/02/TCP%E3%80%81UDP%E9%80%9A%E4%BF%A1%E6%A8%A1%E5%9E%8B/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>TCP、UDP通信模型 | 境</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">境</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

  <a href="https://github.com/xiaomingmingbai" class="github-corner" title="Follow me on GitHub" aria-label="Follow me on GitHub" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/02/02/TCP%E3%80%81UDP%E9%80%9A%E4%BF%A1%E6%A8%A1%E5%9E%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="XiaoMingMingBai">
      <meta itemprop="description" content="选择有时候比努力更重要">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="境">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          TCP、UDP通信模型
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-02-02 22:07:08" itemprop="dateCreated datePublished" datetime="2023-02-02T22:07:08+08:00">2023-02-02</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-09-28 12:22:32" itemprop="dateModified" datetime="2023-09-28T12:22:32+08:00">2023-09-28</time>
              </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>20k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>37 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p>本文主要位通信协议、网络体系结构、TCP&#x2F;IP协议、常见包头等分析介绍使用。</p>
<span id="more"></span>

<h1 id="前置"><a href="#前置" class="headerlink" title="前置"></a>前置</h1><p>计算机网络的本质作用其实就是让<strong>IT设备</strong>之间能够进行数据传输和<strong>信息交互（通信）</strong><br>最简单的通信模型如下：<br><img src="/../image/SimpleProtocol.png" alt="Alt text"></p>
<p>其中<strong>通信协议</strong>的作用就是 让通信的双方能够识别并能接收到数据信息。<br><img src="/../image/TCPIPModel.png" alt="Alt text"></p>
<p>这种层次结构使得不同的协议可以在不同的层次上进行交互和搭配，而彼此之间不会产生不必要的干扰，提高了网络管理的效率和可靠性。</p>
<h1 id="TCP-IP协议簇的体系结构"><a href="#TCP-IP协议簇的体系结构" class="headerlink" title="TCP&#x2F;IP协议簇的体系结构"></a>TCP&#x2F;IP协议簇的体系结构</h1><p>TCP&#x2F;IP协议族是Internet中最重要的一组协议，并且广泛应用于各种计算机网络和系统之间的通信。<br>TCP&#x2F;IP协议族（簇）的体系结构其实也是现实版的OSI体系，是现实的工业互联标准，共有四层：<br><img src="/../image/TCPIP.png" alt="Alt text"></p>
<h2 id="网络的体系结构"><a href="#网络的体系结构" class="headerlink" title="网络的体系结构"></a>网络的体系结构</h2><ul>
<li>网络采用分而治之的方法设计，将网络的功能划分为不同的模块，以分层的形式有机组合在一起。</li>
<li>每层实现不同的功能，其内部实现方法对外部其他层次来说是透明的，每层向上一层提供服务，同时使用下层提供的服务。</li>
<li>网络体系结构即指网络层次和每层所使用的协议的集合。</li>
</ul>
<h2 id="常见的TCP-IP协议"><a href="#常见的TCP-IP协议" class="headerlink" title="常见的TCP&#x2F;IP协议"></a>常见的TCP&#x2F;IP协议</h2><p>按照四层模型，TCP&#x2F;IP协议族具有以下四层：</p>
<ol>
<li><p><strong>应用层（Application Layer）</strong>：应用层提供了与特定应用程序和网络服务的通信接口。任何需要从网络中获取数据的应用程序，如Web浏览器、邮件客户端、FTP客户端等，都是在应用层实现的。常见的应用层协议包括HTTP、FTP、SMTP、POP3等。</p>
<ul>
<li><code>HTTP（HyperText Transfer Protocol）协议</code>：用于Web服务器和Web浏览器之间互相传输超文本信息，实现浏览器访问万维网的功能。</li>
<li><code>SMTP（Simple Mail Transfer Protocol）协议</code>：用于邮件传输协议，使邮箱能够发送和接收邮件。</li>
<li><code>POP3（Post Office Protocol version 3）协议</code>：用于收取邮件，将服务器中的邮件下载到客户端计算机。</li>
<li><code>FTP（File Transfer Protocol）协议</code>：用于在网络上传输文件，实现文件共享及远程文件传输等功能。</li>
<li><code>TFTP简单文件传输协议</code>：使用UDP传输。</li>
<li><code>DNS解析协议</code>：把url域名解析成ip地址的一种协议。</li>
<li><code>NFS文件共享协议</code>：一般使用UDP传输。</li>
</ul>
</li>
<li><p><strong>传输层（Transport Layer）</strong>：传输层为应用程序提供了端到端的通信，为不同主机的通信进程设定端口号，并将数据在不同主机之间传输。常见的传输层协议包括TCP、UDP等</p>
<ul>
<li><code>TCP（Transmission Control Protocol）协议</code>：一种可靠的、面向连接的协议，用于确保数据的可靠传输，保障数据的准确（数据无误，无丢失，无失序，无重复到达的通信）。<ul>
<li>优点：准确，缺点：传输效率不高。</li>
<li>场景：数据要求严格的传输。</li>
</ul>
</li>
<li><code>UDP（User Datagram Protocol）协议</code>：一种不可靠的、无连接的协议，用于在不需要可靠数据传输时，提高数据传输效率。<ul>
<li>优点：传输效率高，缺点：可能会有丢包现象</li>
<li>场景：对数据要求不高的场景。</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>网络层（Internet Layer）</strong>：网络层用于实现IP协议，对数据包的传输进行路由选择和寻址，并通过向下一层提供不可靠的数据报送程序来实现传输。常见的网络层协议为IP（Internet Protocol）协议以及相关协议例如ICMP、ARP等。</p>
<ul>
<li><code>IP（Internet Protocol）协议</code>：IP协议使得不同的计算机可以互相通信，并能够在不同的网络之间传递数据包，实现了整个互联网的路由功能。是Internet中发送数据的关键协议之一。</li>
<li><code>ICMP（Internet Control Message Protocol）协议</code>：用于在IP主机，路由器之间的传递控制消息，比如ping命令、网络是否可达等等。</li>
<li><code>IGMP （Internet Group Message Protocol）协议</code>：互联网组管理协议，是一个组播协议，用于主机和组播路由之间的通信。</li>
</ul>
</li>
<li><p><strong>物理层和数据链路层（Link Layer）</strong>：物理层和数据链路层用于实现与物理媒介的接口，将比特流转换为实际可传输的信号。它们是一组紧密相连的层，负责处理数据帧、网络接口卡（NIC）、帧的检错、流量控制等相应的操作。常见的物理层和数据链路层协议包括以太网、PPP、SLIP等。</p>
<ul>
<li><code>ARP（Address Resolution Protocol）协议</code>：将IP地址转换成物理地址，使一个通信节点（如计算机）能够定位另一个通信节点（如路由器）的物理地址。</li>
<li><code>RARP(Reverse Address Resolution Protocol) 协议</code>：通过MAC地址获取对方的ip地址。</li>
</ul>
</li>
</ol>
<h2 id="TCP-IP四层模型中不同层次使用的协议之间的关系"><a href="#TCP-IP四层模型中不同层次使用的协议之间的关系" class="headerlink" title="TCP&#x2F;IP四层模型中不同层次使用的协议之间的关系"></a>TCP&#x2F;IP四层模型中不同层次使用的协议之间的关系</h2><ol>
<li>应用层：应用层负责应用程序数据的格式或者说协议，使用的协议有<code>HTTP</code>、<code>FTP</code>、<code>SMTP</code>、<code>DNS</code>等；</li>
<li>传输层：传输层负责端到端的通信，包括数据的分段和重新组装，使用的协议有<code>TCP</code>和<code>UDP</code>；</li>
<li>网络层：网络层负责网络上的寻址、路由和分组传输，使用的协议有<code>IP</code>、<code>ICMP</code>和<code>ARP</code>；</li>
<li>数据链路层：数据链路层负责物理网络上的数据传输，包括数据的分帧、差错校验和流量控制等，使用的协议有<code>以太网</code>和<code>PPP</code>。</li>
</ol>
<p>因此，<strong>TCP&#x2F;IP四层模型</strong>中每层使用的协议是相互独立、功能分层的，每个层次上使用的协议都为上一层提供服务（比如，如果应用层使用<code>TFTP</code>，那么上一层的网络传递协议选择就一定要选择<code>UDP</code>，因为<code>TFTP</code>不支持<code>TCP</code>,只支持<code>UDP</code>）。最终，所有协议协同工作，实现了网络中各种应用程序之间的通信。<br><img src="/../image/TCPIPClan.png" alt="Alt text"></p>
<h2 id="封包与拆包过程"><a href="#封包与拆包过程" class="headerlink" title="封包与拆包过程"></a>封包与拆包过程</h2><p><img src="/../image/Package.png" alt="Alt text">  </p>
<p><strong>发送端：</strong></p>
<ol>
<li><p><strong>应用层</strong> - 发送端的应用程序将数据进行封装，将数据转换为网络可传输的格式，例如HTTP协议、FTP协议、SMTP协议等。</p>
</li>
<li><p><strong>传输层</strong> - 这个阶段选用TCP或UDP协议，根据应用层选择对应的协议，如果是可靠传输会选择TCP协议进行传输，而无需可靠传输的数据则会选择UDP协议，并设置好SERVER IP和端口号。</p>
</li>
<li><p><strong>网络层</strong> - 进行IP地址的解析，将数据封装成IP数据包，进行路由选择，通过路由器或交换机将数据包发送到互联网上。</p>
</li>
<li><p><strong>数据链路层</strong> - 将IP数据包封装在数据帧中，设置好目的MAC地址和源MAC地址，通过本机所连的交换机转发到接入的路由器。</p>
</li>
<li><p><strong>物理层</strong> - 讲数字信号转换成模拟信号，在传输线上进行数据传输，利用调制、编码、解码、调幅等技术进行信号转换和传输。</p>
</li>
</ol>
<p><strong>接收端：</strong></p>
<ol>
<li><p><strong>物理层</strong> - 接收方收到模拟信号后，将模拟信号转换为数字信号。</p>
</li>
<li><p><strong>数据链路层</strong> - 将收到的数据帧中的MAC头和数据载荷分离，每一帧内找出自己的MAC地址，校验数据帧的数据完整性和正确性。</p>
</li>
<li><p><strong>网络层</strong> - 进行IP协议解析，从IP数据包中提取出源IP地址和目标IP地址。</p>
</li>
<li><p><strong>传输层</strong> - 进行TCP协议解析，判断数据是否为可靠传输，根据TCP头部信息中的端口号，将数据传输给对应的应用层进行处理。</p>
</li>
<li><p><strong>应用层</strong> - 最终数据将由接收方的应用程序进行处理，解码并完成相关操作。</p>
</li>
<li><p><strong>回传信息</strong> - 接收方应用程序处理过程中或处理完成后，可发送一条ACK信息表示数据已接收成功。</p>
</li>
</ol>
<blockquote>
<p><strong>注意</strong> 在整个数据传输过程中，可能会遇到不同的网络问题，例如网络试验慢、数据包丢失等，因此需要利用相应的协议和技术进行性能优化和错误处理来确保数据传输的正确和稳定。</p>
</blockquote>
<h2 id="数据帧"><a href="#数据帧" class="headerlink" title="数据帧"></a>数据帧</h2><p><code>TCP/IP</code>通信中，一帧数据的大小是由底层传输介质的<code>MTU</code>（<code>Maximum Transmission Unit</code>，最大传输单元）决定的。不同的网络设备和网络传输介质有不同的<code>MTU</code>，比如以太网的<code>MTU</code>一般为1500字节，而无线网络的<code>MTU</code>一般较小。</p>
<p>在发送数据时，<code>TCP</code>协议会将数据分割成多个大小相等的<code>IP</code>数据包（<code>IP</code>数据报文），每个数据包的大小不能超过<code>MTU</code>。在传输过程中，这些数据包在不同的网络设备之间被逐一传递，直到到达目的地，并在目的地重新组装成完整的数据。因此，<code>TCP/IP</code>通信中一帧数据的大小是不固定的，而是由网络设备的<code>MTU</code>所决定的。</p>
<p>传输每帧数据包的大小一般为：46~1500字节，在Linux中可以通过ifconfig进行查看，但传输过程中以整个传输过程中的最小通路为准。<br><img src="/../image/DataFrames.png" alt="Alt text"></p>
<p>TCP段，如果是UDP则占8个字节。</p>
<p>所以：</p>
<p>UDP 包MTU的大小就应该是 1500 - IP头(20) - UDP头(8) &#x3D; 1472(Bytes)<br>TCP 包MTU的大小就应该是 1500 - IP头(20) - TCP头(20) &#x3D; 1460 (Bytes)</p>
<h1 id="数据帧的封装"><a href="#数据帧的封装" class="headerlink" title="数据帧的封装"></a>数据帧的封装</h1><p>数据从应用层向下传递，到达传输层时，为应用层数据，如果采用TCP传输则添加TCP报头，如果采用UDP传输则添加UDP报头，关于TCP报头及UDP报头在第二节与第三节均进行了介绍。当数据到达网络层时，则要再添加IP头。当到过数据链路层与物理层时，则要再添加MAC头。</p>
<h2 id="IP-头"><a href="#IP-头" class="headerlink" title="IP 头"></a>IP 头</h2><p><img src="/../image/IPHand.png" alt="Alt text"></p>
<ol>
<li>**<code>版本</code>**：IP协议的版本。通信双方使用过的IP协议的版本必须一致，目前最广泛使用的IP协议版本号为34(即IPv4)</li>
<li>**<code>首部长度</code>**：单位是4倍（共4bit）比如表示IP头为20个字节，那么就是5. 即0101四位。</li>
<li>**<code>服务类型</code>**：一般不使用，取值为0。前3位：优先级，第4-7位：延时，吞吐量，可靠性，花费。第8位保留</li>
<li>**<code>总长度</code>**：指首部加上数据的总长度，单位为字节。最大长度为65535字节。</li>
<li><strong><code>标识</code>（identification）</strong>：用来标识主机发送的每一份数据报。IP软件在存储器中维持一个计数器，每产生一个数据报，计数器就加1，并将此值赋给标识字段。</li>
<li>**<code>标志</code>**（flag）：目前只有两位有意义。标志字段中的最低位记为MF。MF&#x3D;1即表示后面“还有分片”的数据报。MF&#x3D;0表示这已是若干数据报片中的最后一个。标志字段中间的一位记为DF，意思是“不能分片”，只有当DF&#x3D;0时才允许分片</li>
<li>**<code>片偏移</code>**：指出较长的分组在分片后，某片在源分组中的相对位置，也就是说，相对于用户数据段的起点，该片从何处开始。片偏移以8字节为偏移单位。</li>
<li>**<code>生存时间</code>**：TTL，表明是数据报在网络中的寿命，即为“跳数限制”，由发出数据报的源点设置这个字段。路由器在转发数据之前就把TTL值减一，当TTL值减为零时，就丢弃这个数据报。通常设置为32、64、128。</li>
<li>**<code>协议</code>**：指出此数据报携带的数据时使用何种协议，以便使目的主机的IP层知道应将数据部分上交给哪个处理过程，常用的ICMP(1),IGMP(2),TCP(6),UDP(17),IPv6（41）</li>
<li>**<code>首部校验和</code>**：只校验数据报的首部，不包括数据部分。</li>
<li>**<code>源地址</code>**：发送方IP地址</li>
<li>**<code>目的地址</code>**：接收方IP地址</li>
<li>**<code>选项</code>**：用来定义一些任选项；如记录路径、时间戳等。这些选项很少被使用，同时并不是所有主机和路由器都支持这些选项。一般忽略不计</li>
</ol>
<h2 id="MAC-头"><a href="#MAC-头" class="headerlink" title="MAC 头"></a>MAC 头</h2><p><img src="/../image/MACHand.png" alt="Alt text"></p>
<p>CRC即循环冗余校验码：是数据通信领域中最常用的一种查错校验码，其特征是信息字段和校验字段的长度可以任意选定。循环冗余检查是一种数据传输检错功能，对数据进行h多项式计算，并将得到的结果附在帧的后面，接收设备也执行类似的算法，以保证数据传输的正确性和完整性。</p>
<p>在这个数据帧中，默认一帧数据最大为为1518。</p>
<h1 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a>TCP</h1><h2 id="TCP-封装格式"><a href="#TCP-封装格式" class="headerlink" title="TCP 封装格式"></a>TCP 封装格式</h2><p>在应用层的数据在发生传递会在传输层，如果选择的TCP传输，将会为这个应用层数加前加上TCP报头，TCP报头如下：<br><img src="/../image/TCPDate.png" alt="Alt text"></p>
<ol>
<li>**<code>源端口号</code>**：发送方端口号</li>
<li>**<code>目的端口号</code>**：接收方端口号</li>
<li>**<code>序列号</code>**：本报文段的数据的第一个字节的序号，使用小写seq表示</li>
<li>**<code>确认序号</code>**：期望收到对方下一个报文段的第一个数据字节的序号，使用小写<code>ack</code>表示</li>
<li>**<code>首部长度（数据偏移）</code>**：4个bit,TCP报文段的数据起始处距离TCP报文段的起始处有多远，即首部长度。即以4字节为计算单位,取值通常为 5~15</li>
<li>**<code>保留</code>**：占6位，保留为今后拓展使用，目前应置为0.</li>
<li><strong><code>紧急URG</code></strong>: 此位置1，表明紧急指针字段有效，它告诉系统此报文段中有紧急数据，应尽快传送</li>
<li><strong><code>确认ACK</code></strong>: 仅当ACK&#x3D;1时确认号字段才有效，TCP规定，在连接建立后所有传达的报文段都必须把ACK置1</li>
<li>**<code>推送PSH</code>**：当两个应用进程进行交互式的通信时，有时在一端的应用进程希望在键入一个命令后立即就能够收到对方的响应。在这种情况下，TCP就可以使用推送（push）操作，这时，发送方TCP把PSH置1，并立即创建一个报文段发送出去，接收方收到PSH&#x3D;1的报文段，就尽快地（即“推送”向前）交付给接收应用进程，而不再等到整个缓存都填满后再向上交付</li>
<li><strong><code>复位RST</code></strong>: 用于复位相应的TCP连接时会置1</li>
<li><strong><code>同步SYN</code></strong>: 仅在三次握手建立TCP连接时有效。当SYN&#x3D;1而ACK&#x3D;0时，表明这是一个连接请求报文段，对方若同意建立连接，则应在相应的报文段中使用SYN&#x3D;1和ACK&#x3D;1.因此，SYN置1就表示这是一个连接请求或连接接受报文。</li>
<li>**<code>终止FIN</code>**：用来释放一个连接。当FIN&#x3D;1时，表明此报文段的发送方的数据已经发送完毕，并要求释放运输连接。</li>
<li>**<code>窗口</code>**：用于控制数据传输的速度和流量控制。窗口大小表示接收端当前可用的缓存大小，即接收端还可以接收多少字节的数据。这个值是一个16位的整数，可以表示的窗口大小为 0~65535 字节。当发送方发送数据时，它会根据接收方的窗口大小动态地调整发送的数据量，以避免接收方缓存区满了而导致数据丢失。发送方会根据接收方发送过来的窗口大小调整发送的数据量，如果窗口大小变小，发送方会减少发送的数据量，如果窗口大小变大，发送方则可以增加发送的数据量。TCP 的窗口大小控制可以防止数据包过多拥塞网络，也可以保证数据传输的流畅性和可靠性。在数据传输过程中，如果接收方的窗口大小为 0，发送方就会停止发送数据，等待接收方重新通知其窗口大小。这种流量控制的机制可以使得 TCP 在高速、高负载的网络中稳定运行，并有效地避免了数据的丢失和拥塞。</li>
<li>**<code>校验和</code>**：校验和字段用于检验 TCP 报头和数据段的数据是否正确，以保证数据传输的正确性和可靠性。这个字段是 16 位的整数。</li>
<li>**<code>紧急指针</code>**：仅在URG&#x3D;1时才有意义，它指出本报文段中的紧急数据的字节数（紧急数据结束后就是普通数据），即指出了紧急数据的末尾在报文中的位置，注意：即使窗口为零时也可发送紧急数据</li>
<li>**<code>选项</code>**：长度可变，最长可达40字节，当没有使用选项时，TCP首部长度是20字节</li>
</ol>
<h2 id="TCP-三次握手"><a href="#TCP-三次握手" class="headerlink" title="TCP 三次握手"></a>TCP 三次握手</h2><p>TCP 使用三次握手（three-way handshake）的方式来建立一个连接，以确保通信双方都能够正确地接收和发送数据。<br>发生在客户端connect函数 与  服务器的 accepet 函数之前：</p>
<p>三次握手的过程如下：</p>
<ol>
<li>客户端发送一个带有 SYN（同步序列号Synchronize Sequence Numbers）标志的数据包，表示客户端请求建立连接。客户端选择一个随机的序列号（序列号 A），并将该序列号放在 SYN 标志的字段中，然后向服务器端发送这个数据包。此时客户端进入 SYN_SENT 状态。</li>
<li>服务器收到客户端的请求后，会回复一个带有 SYN&#x2F;ACK 标志的数据包，表示服务器已经收到客户端的请求，并同意建立连接。服务器选择一个随机的序列号（序列号 B），并将该序列号放在 SYN 标志的字段中，将自己的初始序列号（序列号 A + 1）放在 ACK 标志的字段中，然后将数据包发送给客户端。此时服务器进入 SYN_RCVD 状态。</li>
<li>客户端收到服务器的回复后，会发送一个带有 ACK 标志的数据包，表示客户端确认已经收到了服务器的响应，并同意建立连接。客户端将服务器的初始序列号（序列号 B + 1）放在 ACK 标志的字段中，然后将数据包发送给服务器。此时客户端和服务器都进入 ESTABLISHED 状态，连接建立完成。</li>
</ol>
<p>三次握手的过程可以确保客户端和服务器都已经准备好建立连接，并可以正确地发送和接收数据。如果服务器没有收到客户端的请求，或者客户端没有收到服务器的响应，则会重新发送请求，直到建立连接成功。三次握手的机制可以有效地保证数据的可靠性和安全性，同时也避免了重复的连接请求和资源浪费。</p>
<p><img src="/../image/TCPHandshake.png" alt="Alt text"></p>
<h2 id="TCP-四次挥手"><a href="#TCP-四次挥手" class="headerlink" title="TCP 四次挥手"></a>TCP 四次挥手</h2><p><img src="/../image/TCPWave.png" alt="Alt text"></p>
<ol>
<li>客户端发送一个带有 FIN（结束标志）的数据包，表示客户端已经完成了所有的数据发送任务，并且准备关闭连接。客户端选择一个随机的序列号（序列号 C），并将该序列号放在 FIN 标志的字段中，然后向服务器端发送这个数据包。此时客户端进入 FIN_WAIT_1 状态。</li>
<li>服务器收到客户端的请求后，会回复一个带有 ACK 标志的数据包，表示服务器已经收到客户端的请求，并同意关闭连接。服务器将客户端的序列号（序列号 C + 1）放在 ACK 标志的字段中，然后将数据包发送给客户端。此时服务器进入 CLOSE_WAIT 状态，客户端收到服务器的回复后，进入 FIN_WAIT_2 状态。</li>
<li>服务器准备好关闭连接时，会发送一个带有 FIN 标志的数据包，表示服务器已经完成了所有的数据发送任务，并且准备关闭连接。服务器选择一个随机的序列号（序列号 D），并将该序列号放在 FIN 标志的字段中，将客户端的序列号（序列号 C + 1）放在 ACK 标志的字段中，然后将数据包发送给客户端。此时服务器进入 LAST_ACK 状态。</li>
<li>客户端收到服务器的回复后，会回复一个带有 ACK 标志的数据包，表示客户端已经收到服务器的回复，并同意关闭连接。客户端将服务器的序列号（序列号 D + 1）放在 ACK 标志的字段中，然后将数据包发送给服务器。此时客户端进入 TIME_WAIT 状态，等待 2MSL（最长报文段寿命）后，客户端和服务器都进入 CLOSED 状态，连接关闭完成。</li>
<li>服务器收到客户端的回复后，进入 CLOSED 状态，连接关闭完成。</li>
</ol>
<p>四次挥手的过程可以确保客户端和服务器都已经完成了所有的数据发送任务，并且准备好关闭连接。如果客户端没有收到服务器的回复，则会重新发送请求，直到关闭连接成功。</p>
<h2 id="粘包问题"><a href="#粘包问题" class="headerlink" title="粘包问题"></a>粘包问题</h2><p>由于TCP是基于<strong>字节流</strong>的，因此在发送端，只要把数据放入到发送缓冲区，就会发送出去，而不考虑数据包的大小。这就可能导致接收端收到的数据包大于发送端的数据包，也可能导致接收端收到的数据包小于发送端的数据包。这种情况就称为粘包。</p>
<blockquote>
<p><strong>字节流</strong>可以理解为一个双向的通道里流淌的数据，这个数据其实就是我们常说的二进制数据，简单来说就是一大堆 01 串。这些 01 串之间没有任何边界。</p>
</blockquote>
<p><strong>内核中的缓冲区</strong><br>Socket 内核缓冲区是指在操作系统内核中维护的一块内存，用于存储网络数据的临时缓存区。当应用程序通过 Socket 发送数据时，数据先被写入内核缓冲区，然后再由操作系统将数据发送到网络上。类似地，当应用程序从 Socket 接收数据时，数据也是先被读取到内核缓冲区中，然后再由应用程序读取。</p>
<p>内核缓冲区的作用是为了提高网络传输的效率和可靠性。当应用程序发送数据时，内核缓冲区可以将多个小数据包合并成一个大的数据包，从而减少网络传输中的开销。而当应用程序接收数据时，内核缓冲区可以对接收到的数据进行拆分和重组，以保证数据的完整性和正确性。</p>
<p>操作系统为每个 Socket 连接分配了两个内核缓冲区，一个用于发送数据，另一个用于接收数据。这些缓冲区的大小可以通过系统参数进行配置，一般情况下，应该根据实际情况合理调整缓冲区大小，以达到最佳的网络传输性能。</p>
<p><img src="/../image/KernelBuffer.png" alt="Alt text"></p>
<p>应用层传到 <code>TCP</code> 协议的数据，不是以<strong>消息报</strong>为单位向目的主机发送，而是以<strong>字节流</strong>的方式发送到下游，这些数据可能被<strong>切割和组装</strong>成各种数据包，接收端收到这些数据包后没有正确还原原来的消息，因此出现<strong>粘包现象</strong>。比如：在传输过程中，如果一端短段时间内发送多个数据包，为了提高传输效率内核中的Naggle算法，会将多个小的数据合并为一个较大的数据进行传输，可能就会数据粘连的问题。 </p>
<h3 id="产生的原因"><a href="#产生的原因" class="headerlink" title="产生的原因"></a>产生的原因</h3><p>关于Nagle算法导致的粘包问题</p>
<blockquote>
<p>MTU: Maximum Transmit Unit，最大传输单元。 由网络接口层（数据链路层）提供给网络层最大一次传输数据的大小；一般 MTU&#x3D;1500 Byte。<br>假设IP层有 &lt;&#x3D; 1500 byte 需要发送，只需要一个 IP 包就可以完成发送任务；假设 IP 层有&gt; 1500 byte 数据需要发送，需要分片才能完成发送，分片后的 IP Header ID 相同。<br>MSS：Maximum Segment Size 。 TCP 提交给 IP 层最大分段大小，不包含 TCP Header 和 TCP Option，只包含 TCP Payload ，MSS 是 TCP 用来限制应用层最大的发送字节数。</p>
</blockquote>
<p>假设 MTU&#x3D; 1500 byte，那么 MSS &#x3D; 1500- 20(IP Header) -20 (TCP Header) &#x3D; 1460 byte，如果应用层有 2000 byte 发送，那么需要两个切片才可以完成发送，第一个 TCP 切片 &#x3D; 1460，第二个 TCP 切片 &#x3D; 540。<br>在 Nagle 算法开启的状态下，数据包在以下两个情况会被发送：</p>
<blockquote>
<p>如果包长度达到MSS（或含有Fin包），立刻发送，否则等待下一个包到来；如果下一包到来后两个包的总长度超过MSS的话，就会进行拆分发送；<br>等待超时（一般为200ms），第一个包没到MSS长度，但是又迟迟等不到第二个包的到来，则立即发送。</p>
</blockquote>
<h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><ol>
<li>**<code>定长消息</code>**：在发送数据之前，将数据按照固定长度分割成多个数据包发送，接收方每次接收一个固定长度的数据包，从而避免了粘包问题。（缺点：虽然这种方式可以解决粘包和拆包的问题,但这种固定缓冲区大小的方式增加了不必要的数据传输;当这种方式当发送的数据比较小时会使用空字符来弥补,所以这种方式就大大的增加了网络传输的负担,所以它也不是最佳的解决方案。）</li>
<li>**<code>特定字符分割</code>**：在发送数据时，在每个数据包的结尾添加特定的字符或标记，接收方在接收数据时，根据特定字符或标记切分数据包，从而避免了粘包问题。（缺点是报文中不能有相同的字符或标记，不常用）</li>
<li>**<code>消息长度</code>**：在发送数据时，在每个数据包的开头添加表示消息长度的字段，接收方先读取消息长度，然后根据消息长度读取数据包，从而避免了粘包问题。（网络框架Netty所用的解决方案）</li>
<li>**<code>利用应用层协议</code>**：在应用层协议中定义消息格式和消息长度，从而避免TCP传输中的粘包问题。</li>
</ol>
<blockquote>
<p>注意</p>
<ol>
<li>发送方和接收方需要使用相同的方法，以保证数据能够正确地发送和接收。</li>
<li>在发送数据时，需要注意数据包的大小，不宜过大或过小，以避免传输效率低下或造成拥堵。</li>
<li>在接收数据时，需要及时读取数据，不要等待所有数据都接收完成再进行处理，以避免缓存溢出或处理延迟过大。</li>
</ol>
</blockquote>
<h3 id="Netty中的解决方案-消息长度"><a href="#Netty中的解决方案-消息长度" class="headerlink" title="Netty中的解决方案 - 消息长度"></a>Netty中的解决方案 - 消息长度</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netinet/ip.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdbool.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">write_N</span><span class="params">(<span class="type">int</span> fd, <span class="type">char</span>* buf, <span class="type">int</span> newMsgLen)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(buf == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> n = newMsgLen;</span><br><span class="line">    <span class="keyword">while</span>(n &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> len = write(fd,buf,n);</span><br><span class="line">        <span class="keyword">if</span>(len == <span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            perror(<span class="string">&quot;write err:&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        buf += len;</span><br><span class="line">        n -= len;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> newMsgLen;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">writeToSocket</span><span class="params">(<span class="type">int</span> fd,<span class="type">char</span>* buf, <span class="type">int</span> len)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(buf == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//1.获取要发送的报文的长度。</span></span><br><span class="line">    <span class="type">int</span> MsgLen = <span class="built_in">strlen</span>(buf);</span><br><span class="line">    <span class="comment">//2.把报文件长度设置为网络字节序：</span></span><br><span class="line">    <span class="type">int</span> MsgLen_netOrder = htonl(MsgLen);</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> senderBuf[<span class="number">4</span> + MsgLen];</span><br><span class="line">    <span class="built_in">memset</span>(senderBuf,<span class="number">0</span>,<span class="keyword">sizeof</span>(senderBuf));</span><br><span class="line">    <span class="comment">//3.通过内存拷贝的方式把数据放在有消息长度的用户缓冲区：</span></span><br><span class="line">    <span class="built_in">memcpy</span>(senderBuf,&amp;MsgLen_netOrder,<span class="number">4</span>);</span><br><span class="line">    <span class="comment">//4.拷贝报文：</span></span><br><span class="line">    <span class="built_in">memcpy</span>(senderBuf+<span class="number">4</span>,buf,MsgLen);</span><br><span class="line">    <span class="type">int</span> nbytes = write_N(fd,senderBuf,<span class="number">4</span> + MsgLen);</span><br><span class="line">    <span class="keyword">return</span> nbytes;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> <span class="type">const</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//1.创建流式套接字：</span></span><br><span class="line">    <span class="type">int</span> socket_fd = socket(AF_INET,SOCK_STREAM,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(socket_fd == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;socket err:&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//2.创建一个网络信息结构体:</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">serverInfo</span> =</span> &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    serverInfo.sin_family = AF_INET;</span><br><span class="line">    serverInfo.sin_port = htons(<span class="number">6666</span>);</span><br><span class="line">    serverInfo.sin_addr.s_addr = inet_addr(<span class="string">&quot;192.168.250.100&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//使用connect函数连接主机：</span></span><br><span class="line">    <span class="type">int</span> ret = connect(socket_fd,(<span class="type">const</span> <span class="keyword">struct</span> sockaddr*)&amp;serverInfo,<span class="keyword">sizeof</span>(serverInfo));</span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;connect err:&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>* str = <span class="string">&quot;hellowrold&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">30</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> nbytes = writeToSocket(socket_fd,str,<span class="built_in">strlen</span>(str));</span><br><span class="line">        <span class="keyword">if</span>(nbytes == <span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s \n&quot;</span>,str);</span><br><span class="line">    &#125;</span><br><span class="line">    close(socket_fd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netinet/ip.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdbool.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">read_N</span><span class="params">(<span class="type">int</span> fd, <span class="type">char</span>* buf, <span class="type">int</span> MsgLen)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(buf == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> n = MsgLen;</span><br><span class="line">    <span class="keyword">while</span> (n &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> nbytes = read(fd,buf,n);</span><br><span class="line">        <span class="keyword">if</span>(nbytes == <span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            perror(<span class="string">&quot;read err&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(nbytes == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;对端关闭\n&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        buf += nbytes;</span><br><span class="line">        n -= nbytes;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> MsgLen;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">readFromSocket</span><span class="params">(<span class="type">int</span> fd, <span class="type">char</span>* buf)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(buf == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> msgLen = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//1.先读取报文件前4个字节，报文件的长度：</span></span><br><span class="line">    <span class="type">int</span> nbytes = read(fd,&amp;msgLen,<span class="number">4</span>);</span><br><span class="line">    <span class="comment">//2.把读取网络字节序转成主机字节序</span></span><br><span class="line">    msgLen = ntohl(msgLen);</span><br><span class="line">    nbytes = read_N(fd,buf,msgLen);</span><br><span class="line">    <span class="comment">//返回读取字节数：</span></span><br><span class="line">    <span class="keyword">return</span> nbytes;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> <span class="type">const</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 1.创建流式监听套接字类型：</span></span><br><span class="line">    <span class="type">int</span> listen_fd = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (listen_fd == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;socket() err:&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 2.定义一个网络地址信息结构体：</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">serverInfo</span>;</span></span><br><span class="line">    <span class="built_in">memset</span>(&amp;serverInfo, <span class="number">0</span>, <span class="keyword">sizeof</span>(serverInfo));</span><br><span class="line">    serverInfo.sin_family = AF_INET;</span><br><span class="line">    <span class="comment">// 端口号都是2字节，short类型，所以一定要注意字节序的问题：</span></span><br><span class="line">    serverInfo.sin_port = htons(<span class="number">6666</span>);</span><br><span class="line">    serverInfo.sin_addr.s_addr = inet_addr(<span class="string">&quot;192.168.250.100&quot;</span>);</span><br><span class="line">    <span class="comment">// 3.绑定网络地址信息结构体：</span></span><br><span class="line">    <span class="type">int</span> ret = bind(listen_fd, (<span class="type">const</span> <span class="keyword">struct</span> sockaddr *)&amp;serverInfo, <span class="keyword">sizeof</span>(serverInfo));</span><br><span class="line">    <span class="keyword">if</span> (ret == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;bind err:&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 4.设置监听的状态：</span></span><br><span class="line">    ret = listen(listen_fd, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (ret == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;listen err:&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// struct sockaddr clientInfo = &#123;0&#125;;//如果关于客户端地址信息就写一个客户端的信息结构体。</span></span><br><span class="line">    <span class="comment">// int clientlen;</span></span><br><span class="line">    <span class="comment">// 5.阻塞等待客户端的连接：</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;循环服务器启动\n&quot;</span>);</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> connect_fd = accept(listen_fd, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">        <span class="keyword">if</span> (connect_fd == <span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            perror(<span class="string">&quot;accept err:&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 数据的收发：</span></span><br><span class="line">            <span class="comment">// 定义用户数据的缓冲区buf;</span></span><br><span class="line">            <span class="type">char</span> buf[<span class="number">128</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">            <span class="type">int</span> nbtyes = readFromSocket(connect_fd, buf);</span><br><span class="line">            <span class="keyword">if</span> (nbtyes == <span class="number">-1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                perror(<span class="string">&quot;read err:&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(nbtyes == <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;对端断开了连接\n&quot;</span>);</span><br><span class="line">                close(connect_fd);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;客户端发来的数据为 %s \n&quot;</span>,buf);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意 在TCP链接之后，如果断开之后，会出现短时间无法链接的情况</p>
<p>TCP是一个面向连接的协议，它使用三次握手建立连接，并使用四次挥手断开连接。在断开连接后，TCP会将连接的端口号等相关信息保存在一个连接表中，并将其保留一段时间。这个时间被称为TIME_WAIT状态，它通常持续几分钟，这段时间内，连接表中的信息仍然存在，以确保网络中任何延迟的数据包到达时，TCP可以正确处理。</p>
<p>当TCP连接关闭后，客户端和服务器端的TCP实现都会进入TIME_WAIT状态。在此状态下，这些连接表项不能被重新使用，因为TCP实现正在等待确保另一端确认连接已关闭。如果尝试在TIME_WAIT状态下重新建立TCP连接，会导致建立连接失败，因为TCP实现不能使用相同的端口和连接信息。</p>
<p>另外，如果连接的一方关闭了连接，而另一方尝试向已关闭的连接发送数据，那么TCP实现会返回一个RST数据包，指示连接已经关闭。因此，在关闭TCP连接后，如果尝试立即重新连接，可能会由于RST数据包而导致连接失败。</p>
<p>因此，要成功重新建立TCP连接，需要等待足够的时间使TIME_WAIT状态结束，或者在关闭连接后等待一段时间后再尝试重新连接。</p>
</blockquote>
<h1 id="UDP"><a href="#UDP" class="headerlink" title="UDP"></a>UDP</h1><p>无连接的，固定数据大小，不可靠的用户数据报协议。</p>
<p><img src="/../image/UDPData.png" alt="Alt text"></p>
<h2 id="收发数据"><a href="#收发数据" class="headerlink" title="收发数据"></a>收发数据</h2><h3 id="recv-recvfrom"><a href="#recv-recvfrom" class="headerlink" title="recv &#x2F; recvfrom"></a>recv &#x2F; recvfrom</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//read函数的升级版，因为read默认是一个阻塞函数。</span></span><br><span class="line"><span class="comment">//recv函数多了一个flags 是指使用阻塞读取，还是使用非阻塞读取。如果是阻塞则为0，非阻塞则为：MSG_DONTWAIT</span></span><br><span class="line"><span class="comment">//recvfrom函数多了源地址结构体，类似来电显示的功能。可以获取源地址。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @功能：接收数据</span></span><br><span class="line"><span class="comment"> * @参数：</span></span><br><span class="line"><span class="comment"> *      @sockfd: 套接字描述符</span></span><br><span class="line"><span class="comment"> *      @buf: 接收数据的缓冲区</span></span><br><span class="line"><span class="comment"> *      @len: 接收数据的长度</span></span><br><span class="line"><span class="comment"> *      @flags: 0：阻塞读取，MSG_DONTWAIT：非阻塞读取</span></span><br><span class="line"><span class="comment"> * @返回值：成功：返回读取的字节数，失败：-1</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">recv</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">void</span> *buf, <span class="type">size_t</span> len, <span class="type">int</span> flags)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @功能：接收数据</span></span><br><span class="line"><span class="comment"> * @参数：</span></span><br><span class="line"><span class="comment"> *      @sockfd: 套接字描述符</span></span><br><span class="line"><span class="comment"> *      @buf: 接收数据的缓冲区</span></span><br><span class="line"><span class="comment"> *      @len: 接收数据的长度</span></span><br><span class="line"><span class="comment"> *      @flags: 0：阻塞读取，MSG_DONTWAIT：非阻塞读取</span></span><br><span class="line"><span class="comment"> *      @src_addr: 源地址结构体</span></span><br><span class="line"><span class="comment"> *      @addrlen: 源地址结构体的长度</span></span><br><span class="line"><span class="comment"> * @返回值：成功：返回读取的字节数，失败：-1</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">recvfrom</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">void</span> *buf, <span class="type">size_t</span> len, <span class="type">int</span> flags,</span></span><br><span class="line"><span class="params">                    <span class="keyword">struct</span> sockaddr *src_addr, <span class="type">socklen_t</span> *addrlen)</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="send-sendto"><a href="#send-sendto" class="headerlink" title="send &#x2F; sendto"></a>send &#x2F; sendto</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="comment">//write函数的升级版，因为write默认是阻塞函数，即写满时，阻塞等待对方的读取之后再解除阻塞。</span></span><br><span class="line"><span class="comment">//send多了一个flags:阻塞为0，非阻塞为：MSG_DONTWAIT</span></span><br><span class="line"><span class="comment">//sendto双多了一个目的地址，即，数据将要发向哪一个ip地址的主机。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * @功能：发送数据</span></span><br><span class="line"><span class="comment"> * @参数：</span></span><br><span class="line"><span class="comment"> *      @sockfd: 套接字描述符</span></span><br><span class="line"><span class="comment"> *      @buf: 发送数据的缓冲区</span></span><br><span class="line"><span class="comment"> *      @len: 发送数据的长度</span></span><br><span class="line"><span class="comment"> *      @flags: 0：阻塞发送，MSG_DONTWAIT：非阻塞发送</span></span><br><span class="line"><span class="comment"> * @返回值：成功：返回发送的字节数，失败：-1</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">send</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">const</span> <span class="type">void</span> *buf, <span class="type">size_t</span> len, <span class="type">int</span> flags)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * @功能：发送数据</span></span><br><span class="line"><span class="comment"> * @参数：</span></span><br><span class="line"><span class="comment"> *      @sockfd: 套接字描述符</span></span><br><span class="line"><span class="comment"> *      @buf: 发送数据的缓冲区</span></span><br><span class="line"><span class="comment"> *      @len: 发送数据的长度</span></span><br><span class="line"><span class="comment"> *      @flags: 0：阻塞发送，MSG_DONTWAIT：非阻塞发送</span></span><br><span class="line"><span class="comment"> *      @dest_addr: 目的地址结构体</span></span><br><span class="line"><span class="comment"> *      @addrlen: 目的地址结构体的长度</span></span><br><span class="line"><span class="comment"> * @返回值：成功：返回发送的字节数，失败：-1</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">sendto</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">const</span> <span class="type">void</span> *buf, <span class="type">size_t</span> len, <span class="type">int</span> flags,</span></span><br><span class="line"><span class="params">                  <span class="type">const</span> <span class="keyword">struct</span> sockaddr *dest_addr, <span class="type">socklen_t</span> addrlen)</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="UDP-服务器"><a href="#UDP-服务器" class="headerlink" title="UDP 服务器"></a>UDP 服务器</h2><p><img src="/../image/UDPModel.png" alt="Alt text"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netinet/ip.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdbool.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> <span class="type">const</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//构建UDP服务器：</span></span><br><span class="line">    <span class="comment">//1.构建用户数据报套接字：</span></span><br><span class="line">    <span class="type">int</span> udp_fd = socket(AF_INET,SOCK_DGRAM,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(udp_fd == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;socket err:&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//构建网络地址信息结构体：</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">udp_serverInfo</span> =</span> &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    udp_serverInfo.sin_family = AF_INET;</span><br><span class="line">    udp_serverInfo.sin_port = htons(<span class="number">8888</span>);</span><br><span class="line">    udp_serverInfo.sin_addr.s_addr = INADDR_ANY;</span><br><span class="line">    <span class="comment">//2.绑定udp网络地址信息结构体：</span></span><br><span class="line">    <span class="type">int</span> ret = bind(udp_fd,(<span class="keyword">struct</span> sockaddr*)&amp;udp_serverInfo,<span class="keyword">sizeof</span>(udp_serverInfo));</span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;bind err:&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//定义一个用户数据缓冲区：</span></span><br><span class="line">    <span class="type">char</span> buf[<span class="number">128</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//定义一个udp客户端的地址信息结构体：</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">udp_clientInfo</span> =</span> &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="type">int</span> len = <span class="keyword">sizeof</span>(udp_clientInfo);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;udp服务器启动\n&quot;</span>);</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">memset</span>(buf,<span class="number">0</span>,<span class="keyword">sizeof</span>(buf));</span><br><span class="line">        <span class="comment">//接收数据：</span></span><br><span class="line">        <span class="type">int</span> nbytes = recvfrom(udp_fd,buf,<span class="keyword">sizeof</span>(buf)<span class="number">-1</span>,<span class="number">0</span>,(<span class="keyword">struct</span> sockaddr*)&amp;udp_clientInfo,&amp;len);</span><br><span class="line">        <span class="keyword">if</span>(nbytes == <span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            perror(<span class="string">&quot;recvfrom err:&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;udp客户端发来的数据:%s \n&quot;</span>,buf);</span><br><span class="line">        <span class="comment">//回显客户端:发出数据：</span></span><br><span class="line">        nbytes = sendto(udp_fd,buf,<span class="built_in">strlen</span>(buf),<span class="number">0</span>,(<span class="keyword">struct</span> sockaddr*)&amp;udp_clientInfo,len);</span><br><span class="line">        <span class="keyword">if</span>(nbytes == <span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            perror(<span class="string">&quot;write err:&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="UDP-客户端"><a href="#UDP-客户端" class="headerlink" title="UDP 客户端"></a>UDP 客户端</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netinet/ip.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdbool.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> <span class="type">const</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//构建UDP服务器：</span></span><br><span class="line">    <span class="comment">//1.构建用户数据报套接字：</span></span><br><span class="line">    <span class="type">int</span> udp_fd = socket(AF_INET,SOCK_DGRAM,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(udp_fd == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;socket err:&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//2.构建网络地址信息结构体：</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">udp_serverInfo</span> =</span> &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    udp_serverInfo.sin_family = AF_INET;</span><br><span class="line">    udp_serverInfo.sin_port = htons(<span class="number">8888</span>);</span><br><span class="line">    udp_serverInfo.sin_addr.s_addr = inet_addr(<span class="string">&quot;192.168.250.100&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//3.定义一用户数据缓冲区：</span></span><br><span class="line">    <span class="type">char</span> buf[<span class="number">128</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">memset</span>(buf,<span class="number">0</span>,<span class="keyword">sizeof</span>(buf));</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;请输入你要发送的udp数据：\n&quot;</span>);</span><br><span class="line">        fgets(buf,<span class="keyword">sizeof</span>(buf),<span class="built_in">stdin</span>);</span><br><span class="line">        <span class="comment">//发送数据：sendto:</span></span><br><span class="line">        <span class="type">int</span> nbytes = sendto(udp_fd,buf,<span class="built_in">strlen</span>(buf),<span class="number">0</span>,(<span class="keyword">struct</span> sockadd*)&amp;udp_serverInfo,<span class="keyword">sizeof</span>(udp_serverInfo));</span><br><span class="line">        <span class="keyword">if</span>(nbytes == <span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            perror(<span class="string">&quot;sendto err:&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">memset</span>(buf,<span class="number">0</span>,<span class="keyword">sizeof</span>(buf));</span><br><span class="line">        <span class="comment">//接收数据：recvfrom:</span></span><br><span class="line">        nbytes = recvfrom(udp_fd,buf,<span class="keyword">sizeof</span>(buf)<span class="number">-1</span>,<span class="number">0</span>,<span class="literal">NULL</span>,<span class="literal">NULL</span>);</span><br><span class="line">        <span class="keyword">if</span>(nbytes == <span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            perror(<span class="string">&quot;recvfrom err:&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;对端发来的数据为:%s \n&quot;</span>,buf);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


    </div>

    
    
    

      <footer class="post-footer">

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2023/01/25/%E8%A7%86%E9%A2%91%E6%B5%81%E7%A7%BB%E6%A4%8D/" rel="prev" title="视频流移植">
      <i class="fa fa-chevron-left"></i> 视频流移植
    </a></div>
      <div class="post-nav-item">
    <a href="/2023/02/02/%E5%A5%97%E6%8E%A5%E5%AD%97/" rel="next" title="套接字">
      套接字 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%89%8D%E7%BD%AE"><span class="nav-number">1.</span> <span class="nav-text">前置</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#TCP-IP%E5%8D%8F%E8%AE%AE%E7%B0%87%E7%9A%84%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84"><span class="nav-number">2.</span> <span class="nav-text">TCP&#x2F;IP协议簇的体系结构</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BD%91%E7%BB%9C%E7%9A%84%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84"><span class="nav-number">2.1.</span> <span class="nav-text">网络的体系结构</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B8%B8%E8%A7%81%E7%9A%84TCP-IP%E5%8D%8F%E8%AE%AE"><span class="nav-number">2.2.</span> <span class="nav-text">常见的TCP&#x2F;IP协议</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#TCP-IP%E5%9B%9B%E5%B1%82%E6%A8%A1%E5%9E%8B%E4%B8%AD%E4%B8%8D%E5%90%8C%E5%B1%82%E6%AC%A1%E4%BD%BF%E7%94%A8%E7%9A%84%E5%8D%8F%E8%AE%AE%E4%B9%8B%E9%97%B4%E7%9A%84%E5%85%B3%E7%B3%BB"><span class="nav-number">2.3.</span> <span class="nav-text">TCP&#x2F;IP四层模型中不同层次使用的协议之间的关系</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B0%81%E5%8C%85%E4%B8%8E%E6%8B%86%E5%8C%85%E8%BF%87%E7%A8%8B"><span class="nav-number">2.4.</span> <span class="nav-text">封包与拆包过程</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E5%B8%A7"><span class="nav-number">2.5.</span> <span class="nav-text">数据帧</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E5%B8%A7%E7%9A%84%E5%B0%81%E8%A3%85"><span class="nav-number">3.</span> <span class="nav-text">数据帧的封装</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#IP-%E5%A4%B4"><span class="nav-number">3.1.</span> <span class="nav-text">IP 头</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#MAC-%E5%A4%B4"><span class="nav-number">3.2.</span> <span class="nav-text">MAC 头</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#TCP"><span class="nav-number">4.</span> <span class="nav-text">TCP</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#TCP-%E5%B0%81%E8%A3%85%E6%A0%BC%E5%BC%8F"><span class="nav-number">4.1.</span> <span class="nav-text">TCP 封装格式</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#TCP-%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B"><span class="nav-number">4.2.</span> <span class="nav-text">TCP 三次握手</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#TCP-%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B"><span class="nav-number">4.3.</span> <span class="nav-text">TCP 四次挥手</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%B2%98%E5%8C%85%E9%97%AE%E9%A2%98"><span class="nav-number">4.4.</span> <span class="nav-text">粘包问题</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BA%A7%E7%94%9F%E7%9A%84%E5%8E%9F%E5%9B%A0"><span class="nav-number">4.4.1.</span> <span class="nav-text">产生的原因</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88"><span class="nav-number">4.4.2.</span> <span class="nav-text">解决方案</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Netty%E4%B8%AD%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88-%E6%B6%88%E6%81%AF%E9%95%BF%E5%BA%A6"><span class="nav-number">4.4.3.</span> <span class="nav-text">Netty中的解决方案 - 消息长度</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#UDP"><span class="nav-number">5.</span> <span class="nav-text">UDP</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%94%B6%E5%8F%91%E6%95%B0%E6%8D%AE"><span class="nav-number">5.1.</span> <span class="nav-text">收发数据</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#recv-recvfrom"><span class="nav-number">5.1.1.</span> <span class="nav-text">recv &#x2F; recvfrom</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#send-sendto"><span class="nav-number">5.1.2.</span> <span class="nav-text">send &#x2F; sendto</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#UDP-%E6%9C%8D%E5%8A%A1%E5%99%A8"><span class="nav-number">5.2.</span> <span class="nav-text">UDP 服务器</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#UDP-%E5%AE%A2%E6%88%B7%E7%AB%AF"><span class="nav-number">5.3.</span> <span class="nav-text">UDP 客户端</span></a></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">XiaoMingMingBai</p>
  <div class="site-description" itemprop="description">选择有时候比努力更重要</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">19</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/xiaomingmingbai" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;xiaomingmingbai" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:xiaomingmingbai@outlook.com" title="E-Mail → mailto:xiaomingmingbai@outlook.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">XiaoMingMingBai</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-area"></i>
    </span>
    <span title="站点总字数">275k</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="站点阅读时长">8:20</span>
</div>
  <div class="powered-by">
    <!--由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动 -->
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  


  <script async src="/js/cursor/fireworks.js"></script>


</body>
</html>
