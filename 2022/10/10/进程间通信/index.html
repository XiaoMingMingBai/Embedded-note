<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":true},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="本文包含进程的介绍和使用，以及进程间的通信方式。">
<meta property="og:type" content="article">
<meta property="og:title" content="进程以及进程间的通信">
<meta property="og:url" content="http://example.com/2022/10/10/%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1/index.html">
<meta property="og:site_name" content="境">
<meta property="og:description" content="本文包含进程的介绍和使用，以及进程间的通信方式。">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/image/fork1.png">
<meta property="og:image" content="http://example.com/image/fork2.png">
<meta property="article:published_time" content="2022-10-10T14:07:08.000Z">
<meta property="article:modified_time" content="2023-08-15T01:59:33.764Z">
<meta property="article:author" content="XiaoMingMingBai">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/image/fork1.png">

<link rel="canonical" href="http://example.com/2022/10/10/%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>进程以及进程间的通信 | 境</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">境</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

  <a href="https://github.com/xiaomingmingbai" class="github-corner" title="Follow me on GitHub" aria-label="Follow me on GitHub" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/10/10/%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="XiaoMingMingBai">
      <meta itemprop="description" content="选择有时候比努力更重要">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="境">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          进程以及进程间的通信
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-10-10 22:07:08" itemprop="dateCreated datePublished" datetime="2022-10-10T22:07:08+08:00">2022-10-10</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-08-15 09:59:33" itemprop="dateModified" datetime="2023-08-15T09:59:33+08:00">2023-08-15</time>
              </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>50k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>1:31</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p>本文包含进程的介绍和使用，以及进程间的通信方式。</p>
<span id="more"></span>

<h1 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h1><h2 id="进程的概念"><a href="#进程的概念" class="headerlink" title="进程的概念"></a>进程的概念</h2><p>进程是程序的一次执行过程，进程是一个正在执行的任务，<strong>进程是分配资源的最小单位</strong>。每一个进程都会分配自己的0-3G的内存空间，0-3G的内存空间有多份，而3-4G内核空间只有一份。在这0-3G内存空间中堆区、栈区、静态区（缓冲区，文件描述符）。</p>
<p>进程其实是内核创建的，每个进程在内核空间都对应的是一个 <code>task_struct(PCB)</code> 的结构体。正在运行的进程会被放到一个运行队列中，随着时间片轮询依次来执行进程。一个进程的崩溃不会影响另外一个进程的执行，<strong>进程的安全性高</strong>。</p>
<h3 id="进程和程序的区别"><a href="#进程和程序的区别" class="headerlink" title="进程和程序的区别"></a>进程和程序的区别</h3><p><strong>程序</strong>：程序是静态的，没有生命周期的概念，它是有序的指令的集合，在硬盘上存储着</p>
<p><strong>进程</strong>：进程是程序的一次执行过程，它是由生命周期的，随着程序的执行而运行，随着程序的终止而结束，在内存上存储着。可以分配自己的0-3G的内存空间</p>
<h3 id="进程的组成"><a href="#进程的组成" class="headerlink" title="进程的组成"></a>进程的组成</h3><ul>
<li>进程控制块<code>PCB task_struct</code><br>  进程的标识符PID，进程运行的状态，进程所属的用户uid，内存空间…</li>
<li>文本段<br>  存放可执行程序本身</li>
<li>数据段<br>  存放程序运行时候产生的数据，比如int a；a就在数据段存放</li>
</ul>
<h3 id="进程的种类"><a href="#进程的种类" class="headerlink" title="进程的种类"></a>进程的种类</h3><ul>
<li><p><strong>交互进程</strong> ：交互进程是由shell维护的，通过shell和用户进行交互，例如文本编辑器就是一个交互进程。  </p>
</li>
<li><p><strong>批处理进程</strong>：批处理进程的优先级比较低，通常情况下批处理进程都会被放到队列中执行，例如gcc编译程序的过程就是批处理进程。  </p>
</li>
<li><p><strong>守护进程</strong> ：守护进程是一个后台运行的进程，随着系统的启动而启动，随着系统的终止而终止，它会脱离终端执行，例如windows上的各种服务。</p>
</li>
</ul>
<h3 id="PID"><a href="#PID" class="headerlink" title="PID"></a>PID</h3><p>PID <code>process id</code> : 进程号，在linux系统上进程都会被分配一个ID，这个ID就是进程的标号。在linux系统上所有的进程都可以在 <code>/proc</code> 目录下查看。<code>PPID</code> 是进程的父进程号。在一个系统上可以通过如下命令查看能创建的最大进程的个数：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cat</span> /proc/sys/kernel/pid_max</span><br></pre></td></tr></table></figure>
<h3 id="特殊PID的进程"><a href="#特殊PID的进程" class="headerlink" title="特殊PID的进程"></a>特殊PID的进程</h3><p><strong>0号进程 <code>idle</code></strong> : 在linux系统启动的时候最先运行的进程就是0号进程，0号进程又叫空闲进程。如果系统上没有其他进程执行那么0号进程就执行。0号进程是1号进程和2号进程的父进程</p>
<p><strong>1号进程 <code>init</code></strong> : init进程是由0号进程创建得到的，它的主要工作是系统的初始化。当初始化工作执行完之后，它主要负责回收孤儿进程的资源。</p>
<p><strong>2号进程 <code>kthreadd</code></strong> : kthreadd是有0号进程创建出来的，它主要负责调度工作（调度器进程）</p>
<h3 id="进程相关命令"><a href="#进程相关命令" class="headerlink" title="进程相关命令"></a>进程相关命令</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">ps -ef <span class="comment"># 查看进程的父子关系</span></span><br><span class="line"><span class="comment"># PID:进程号</span></span><br><span class="line"><span class="comment"># PPID:父进程号</span></span><br><span class="line"><span class="comment"># TTY:如果是问号，说明没有终端与之对应</span></span><br><span class="line"><span class="comment"># CMD:进程名</span></span><br><span class="line"></span><br><span class="line">ps -ajx   <span class="comment"># 一般使用这条命令查看，查看到的进程的信息更完全</span></span><br><span class="line"><span class="comment"># PID:进程号</span></span><br><span class="line"><span class="comment"># PPID:父进程号</span></span><br><span class="line"><span class="comment"># PGID:进程组ID</span></span><br><span class="line"><span class="comment"># SID:会话ID</span></span><br><span class="line"><span class="comment"># 在linux系统上新开一个终端就会默认创建一个会话，一个会话包含多个进程组,其中进程组有分为前台进程组和后台进程组，前台进程组只有一个，后台进程组有多个。一个进程组内包含很多个进程，进程具备父子关系。</span></span><br><span class="line"><span class="comment"># TTY:如果是问号，说明没有终端与之对应</span></span><br><span class="line"><span class="comment"># TPGID:如果是-1就是守护进程</span></span><br><span class="line"></span><br><span class="line">sudo apt-get install htop</span><br><span class="line">top</span><br><span class="line">htop</span><br><span class="line"><span class="comment"># htop动态查看进程信息比top查看的更可视化一些</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">kill</span> -l <span class="comment"># 给进程发信号的命令</span></span><br><span class="line"><span class="built_in">kill</span>  -信号号  PID   <span class="comment"># 给PID进程发送信号</span></span><br><span class="line"><span class="comment"># SIGINT:打断正在执行的程序（ctrl+c）</span></span><br><span class="line"><span class="comment"># SIGKILL:杀死进程</span></span><br><span class="line"><span class="comment"># SIGSTOP:停止</span></span><br><span class="line"><span class="comment"># SIGCONT:继续</span></span><br><span class="line">    </span><br><span class="line">pidof FILE_NAME <span class="comment"># 查看进程号 pidof a.out  </span></span><br><span class="line">killall FILE_NAME <span class="comment"># 杀死有同名的进程 killall a.out</span></span><br><span class="line">        </span><br><span class="line"><span class="built_in">cat</span> /proc/sys/kernel/pid_max <span class="comment"># 查看最大进程号的命令</span></span><br></pre></td></tr></table></figure>

<h3 id="进程的状态"><a href="#进程的状态" class="headerlink" title="进程的状态"></a>进程的状态</h3><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">1.</span> 进程的状态</span><br><span class="line"><span class="bullet">    *</span> D    不可中断的等待态（sleep，不可被信号打断）</span><br><span class="line"><span class="bullet">    *</span> R    运行状态</span><br><span class="line"><span class="bullet">    *</span> S    可中断的等待态（sleep,可被信号打断）</span><br><span class="line"><span class="bullet">    *</span> T    停止状态</span><br><span class="line"><span class="bullet">    *</span> X    死亡状态</span><br><span class="line"><span class="bullet">    *</span> Z    僵尸态</span><br><span class="line"><span class="bullet">    *</span> I    空闲态</span><br><span class="line"></span><br><span class="line"><span class="bullet">2.</span> 进程的附加态</span><br><span class="line"><span class="bullet">    *</span> &lt;    高优先级进程</span><br><span class="line"><span class="bullet">    *</span> N    低优先级进程</span><br><span class="line"><span class="bullet">    *</span> L    锁在内存上</span><br><span class="line"><span class="bullet">    *</span> s    会话组组长</span><br><span class="line"><span class="bullet">    *</span> l    包含多线程</span><br><span class="line"><span class="bullet">    *</span> +    前台进程</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>孤儿进程</strong> ：一个进程的父进程死亡，此时当前的进程就是孤儿进程，孤儿进程被init收养</p>
<p><strong>僵尸态进程</strong> ：如果一个进程结束，父进程没有为它收尸，此时当前的进程就是僵尸进程。</p>
</blockquote>
<h3 id="进程状态切换实例"><a href="#进程状态切换实例" class="headerlink" title="进程状态切换实例"></a>进程状态切换实例</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;head.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc,<span class="type">const</span> <span class="type">char</span> * argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">./a.out <span class="comment"># 运行上述程序程序状态（前台休眠）</span></span><br><span class="line">ps -ajx | grep a.out <span class="comment"># 查看进程状态</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># ctrl + z  # 将进程变为停止态</span></span><br><span class="line">ps -ajx | grep a.out <span class="comment"># 查看进程状态</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">jobs</span> -l <span class="comment"># 查看状态</span></span><br><span class="line"><span class="built_in">bg</span> 1 <span class="comment"># 将停止态的进程变为后台休眠态</span></span><br><span class="line">ps -ajx | grep a.out <span class="comment"># 查看进程状态</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">fg</span> 1 <span class="comment"># 将后台休眠态的进程变为前台休眠态</span></span><br><span class="line">ps -ajx | grep a.out <span class="comment"># 查看进程状态</span></span><br></pre></td></tr></table></figure>

<h2 id="进程的创建及特点"><a href="#进程的创建及特点" class="headerlink" title="进程的创建及特点"></a>进程的创建及特点</h2><h3 id="如何创建进行"><a href="#如何创建进行" class="headerlink" title="如何创建进行"></a>如何创建进行</h3><p>进程的创建是拷贝父进程得到的，通过拷贝过程更容易得到子进程，并且能够标识进程的父子状态。</p>
<h3 id="创建进程的API"><a href="#创建进程的API" class="headerlink" title="创建进程的API"></a>创建进程的API</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">pid_t</span> <span class="title function_">fork</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="comment">// 功能：创建一个子进程</span></span><br><span class="line"><span class="comment">// 参数：</span></span><br><span class="line"><span class="comment">//     @无</span></span><br><span class="line"><span class="comment">// 返回值：成功父进程收到子进程的PID，子进程收到0</span></span><br><span class="line"><span class="comment">//     	  失败父进程收到-1，并置位错误码</span></span><br></pre></td></tr></table></figure>

<h3 id="创建进程的实例"><a href="#创建进程的实例" class="headerlink" title="创建进程的实例"></a>创建进程的实例</h3><p>创建一个子进程，不关注返回值</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;head.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span>* argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    fork();    <span class="comment">// 创建一个子进程</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>); <span class="comment">// 父子进程都在执行while(1);</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="创建进程的实例-1"><a href="#创建进程的实例-1" class="headerlink" title="创建进程的实例"></a>创建进程的实例</h3><p>创建多个子进程，不关注返回值</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;head.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span>* argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">        fork(); <span class="comment">// 创建一个子进程</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>  按照上述的写法：<code>fork n</code> 次就产生了 <code>2^n</code> 个进程</p>
</blockquote>
<p>可以分次总体的理解上述程序的执行过程</p>
<p><img src="/../image/fork1.png" alt="fork 1"></p>
<p>也可以按照父子关系理解上述程序的执行过程</p>
<p><img src="/../image/fork2.png" alt="fork 2"></p>
<h3 id="fork-和-缓冲区-结合问题"><a href="#fork-和-缓冲区-结合问题" class="headerlink" title="fork 和 缓冲区 结合问题"></a><code>fork</code> 和 <strong>缓冲区</strong> 结合问题</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;head.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span>* argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; i++) &#123;</span><br><span class="line">        fork(); </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;-&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述程序会打印8个 <code>-</code>。</p>
<p>原因是上述程序printf没有刷新缓冲区，所以在fork进程的时候，会将父进程缓冲区的内容也fork过来，所以最终打印了8个’-‘</p>
<h3 id="关注-fork-返回值"><a href="#关注-fork-返回值" class="headerlink" title="关注 fork 返回值"></a>关注 <code>fork</code> 返回值</h3><p><code>fork</code> 的返回值是区分父子进程的关键</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;head.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc,<span class="type">const</span> <span class="type">char</span> * argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">pid_t</span> pid;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//关注返回值可以让父子进程执行不同的代码区</span></span><br><span class="line">    pid = fork();</span><br><span class="line">    <span class="keyword">if</span>(pid == <span class="number">-1</span>)&#123;</span><br><span class="line">        PRINT_ERR(<span class="string">&quot;fork error&quot;</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(pid == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="comment">//子进程代码区</span></span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="comment">//父进程代码区</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="父子进程执行先后顺序"><a href="#父子进程执行先后顺序" class="headerlink" title="父子进程执行先后顺序"></a>父子进程执行先后顺序</h3><p>父子进程执行没有先后顺序，时间片轮询，上下文切换。</p>
<h3 id="父子进程内存空间问题"><a href="#父子进程内存空间问题" class="headerlink" title="父子进程内存空间问题"></a>父子进程内存空间问题</h3><p>在fork前父进程中所有的变量多被拷贝到了子进程中，在子进程中打印的变量的虚拟地址和父进程一样，但是两者在物理地址上一定是不同的，所以在子进程内修改变量的值，父进程中变量不会改变。父子进程内存空间相互独立。</p>
<p><strong>写时拷贝</strong> <code>cow（copy on write）</code><br>在使用fork产生子进程的时候，此时父子进程共用同一块物理内存，但是在子进程或者父进程中尝试修改a变量的时候，此时就会分配一块新的物理内存，此时父子进程a变量虚拟内存相同，但是对应的物理内存不同。</p>
<h3 id="多进程练习"><a href="#多进程练习" class="headerlink" title="多进程练习"></a>多进程练习</h3><p>使用两个进程拷贝同一个文件，父进程拷贝文件的前一半，子进程拷贝文件的后一半。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./a.out srcfile destfile</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;head.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">get_file_len</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* file)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> fd, len;</span><br><span class="line">    <span class="keyword">if</span> ((fd = open(file, O_RDONLY)) == <span class="number">-1</span>)</span><br><span class="line">        PRINT_ERR(<span class="string">&quot;open error&quot;</span>);</span><br><span class="line">    len = lseek(fd, <span class="number">0</span>, SEEK_END);</span><br><span class="line">    close(fd);</span><br><span class="line">    <span class="keyword">return</span> len;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">init_src_file</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* file)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> fd;</span><br><span class="line">    <span class="keyword">if</span> ((fd = open(file, O_WRONLY | O_CREAT | O_TRUNC, <span class="number">0666</span>)) == <span class="number">-1</span>)</span><br><span class="line">        PRINT_ERR(<span class="string">&quot;open error&quot;</span>);</span><br><span class="line"></span><br><span class="line">    close(fd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">copy_file</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* src, <span class="type">const</span> <span class="type">char</span>* dest, <span class="type">int</span> start, <span class="type">int</span> len)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> s[<span class="number">20</span>];</span><br><span class="line">    <span class="type">int</span> fd1, fd2;</span><br><span class="line">    <span class="type">int</span> ret, count = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 1.以只读方式打开源文件，以只写方式打开目标文件</span></span><br><span class="line">    <span class="keyword">if</span> ((fd1 = open(src, O_RDONLY)) == <span class="number">-1</span>)</span><br><span class="line">        PRINT_ERR(<span class="string">&quot;open src error&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> ((fd2 = open(dest, O_WRONLY)) == <span class="number">-1</span>)</span><br><span class="line">        PRINT_ERR(<span class="string">&quot;open dest error&quot;</span>);</span><br><span class="line">    <span class="comment">// 2.定位源和目标文件的光标</span></span><br><span class="line">    lseek(fd1, start, SEEK_SET);</span><br><span class="line">    lseek(fd2, start, SEEK_SET);</span><br><span class="line">    <span class="comment">// 3.循环拷贝</span></span><br><span class="line">    <span class="comment">// while (1) &#123;</span></span><br><span class="line">    <span class="comment">//     ret = read(fd1, s, sizeof(s)); // 从源文件中读</span></span><br><span class="line">    <span class="comment">//     count += ret; // 将每次读的数据加到count中</span></span><br><span class="line">    <span class="comment">//     if (count &gt;= len) &#123;</span></span><br><span class="line">    <span class="comment">//         write(fd2, s, (ret - (count - len)));</span></span><br><span class="line">    <span class="comment">//         break;</span></span><br><span class="line">    <span class="comment">//     &#125;</span></span><br><span class="line">    <span class="comment">//     write(fd2, s, ret);</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line">    <span class="keyword">while</span> (count &lt; len) &#123;</span><br><span class="line">        ret = read(fd1, s, <span class="keyword">sizeof</span>(s)); <span class="comment">// 从源文件中读</span></span><br><span class="line">        count += ret; <span class="comment">// 将每次读的数据加到count中</span></span><br><span class="line">        write(fd2, s, ret);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 4.关闭文件</span></span><br><span class="line">    close(fd1);</span><br><span class="line">    close(fd2);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span>* argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> len;</span><br><span class="line">    <span class="type">pid_t</span> pid;</span><br><span class="line">    <span class="comment">// 1.检查参数个数</span></span><br><span class="line">    <span class="keyword">if</span> (argc != <span class="number">3</span>) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;input error,try again\n&quot;</span>);</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;usage:./a.out srcfile destfile\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 2.获取源文件大小</span></span><br><span class="line">    len = get_file_len(argv[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3.创建出目标文件，并清空</span></span><br><span class="line">    init_src_file(argv[<span class="number">2</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4.fork进程，拷贝文件</span></span><br><span class="line">    <span class="keyword">if</span> ((pid = fork()) == <span class="number">-1</span>) &#123;</span><br><span class="line">        PRINT_ERR(<span class="string">&quot;fork error&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (pid == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 子进程</span></span><br><span class="line">        copy_file(argv[<span class="number">1</span>], argv[<span class="number">2</span>], len / <span class="number">2</span>, (len - len / <span class="number">2</span>));</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 父进程</span></span><br><span class="line">        copy_file(argv[<span class="number">1</span>], argv[<span class="number">2</span>], <span class="number">0</span>, len / <span class="number">2</span>);</span><br><span class="line">        wait(<span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>父子进程光标问题</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;head.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span>* argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">pid_t</span> pid;</span><br><span class="line">    <span class="type">int</span> fd;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果文件是在fork前打开的，此时父子进程共用同一个光标，如果在父进程修改光标，子进程会受到影响。</span></span><br><span class="line">    <span class="comment">// 如果不想让两个进程共用光标，可以在两个进程内分别打开。</span></span><br><span class="line">    <span class="keyword">if</span>((fd = open(<span class="string">&quot;./hello.txt&quot;</span>,O_RDWR))==<span class="number">-1</span>)</span><br><span class="line">        PRINT_ERR(<span class="string">&quot;open error&quot;</span>);</span><br><span class="line"></span><br><span class="line">    pid = fork();</span><br><span class="line">    <span class="keyword">if</span> (pid == <span class="number">-1</span>) &#123;</span><br><span class="line">        PRINT_ERR(<span class="string">&quot;fork error&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (pid == <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="comment">// 子进程</span></span><br><span class="line">      lseek(fd,<span class="number">5</span>,SEEK_SET);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">//父进程</span></span><br><span class="line">      sleep(<span class="number">1</span>);</span><br><span class="line">      <span class="type">char</span> ch;</span><br><span class="line">      read(fd,&amp;ch,<span class="number">1</span>);</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;ch = %c\n&quot;</span>,ch);</span><br><span class="line">    &#125;</span><br><span class="line">    close(fd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="进程相关的API接口"><a href="#进程相关的API接口" class="headerlink" title="进程相关的API接口"></a>进程相关的API接口</h2><h3 id="getpid-getppid-函数"><a href="#getpid-getppid-函数" class="headerlink" title="getpid getppid 函数"></a><code>getpid</code> <code>getppid</code> 函数</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">pid_t</span> <span class="title function_">getpid</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="comment">// 功能：获取当前进程进程号</span></span><br><span class="line"></span><br><span class="line"><span class="type">pid_t</span> <span class="title function_">getppid</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="comment">// 功能：获取父进程进程号</span></span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;head.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span>* argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">pid_t</span> pid;</span><br><span class="line">    <span class="comment">// 关注返回值可以让父子进程执行不同的代码区</span></span><br><span class="line">    pid = fork();</span><br><span class="line">    <span class="keyword">if</span> (pid == <span class="number">-1</span>) &#123;</span><br><span class="line">        PRINT_ERR(<span class="string">&quot;fork error&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (pid == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 子进程代码区</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;child:pid = %d,ppid = %d\n&quot;</span>,getpid(),getppid());</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 父进程代码区</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;parent:pid = %d,ppid = %d,cpid = %d\n&quot;</span>,getpid(),getppid(),pid);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="exit-exit-函数"><a href="#exit-exit-函数" class="headerlink" title="exit _exit 函数"></a><code>exit</code> <code>_exit</code> 函数</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">exit</span><span class="params">(<span class="type">int</span> status)</span>;</span><br><span class="line"><span class="comment">// 功能：结束进程，它是库函数，当使用exit结束进程时会刷新缓冲区</span></span><br><span class="line"><span class="comment">// 参数：</span></span><br><span class="line"><span class="comment">//     @status:进程退出的状态值 [0-255]</span></span><br><span class="line"><span class="comment">//         EXIT_SUCCESS (0)</span></span><br><span class="line"><span class="comment">//     	EXIT_FAILURE (1)</span></span><br><span class="line"><span class="comment">// 返回值：无</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> _exit(<span class="type">int</span> status);</span><br><span class="line"><span class="comment">// 功能：结束进程，它是系统调用，当使用_exit结束进程时不会刷新缓冲区</span></span><br><span class="line"><span class="comment">// 参数：</span></span><br><span class="line"><span class="comment">//     @status:进程退出的状态值 [0-255]</span></span><br><span class="line"><span class="comment">//         EXIT_SUCCESS (0)</span></span><br><span class="line"><span class="comment">//     	EXIT_FAILURE (1)</span></span><br><span class="line"><span class="comment">// 返回值：无</span></span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;head.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">func</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;111111111\n&quot;</span>); <span class="comment">//打印</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;2222222222&quot;</span>);  <span class="comment">//打印</span></span><br><span class="line">    <span class="built_in">exit</span>(EXIT_SUCCESS);    <span class="comment">//进程退出，子进程变成了僵尸进程</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;3333333333\n&quot;</span>);<span class="comment">//不会执行</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span>* argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">pid_t</span> pid;</span><br><span class="line">    <span class="comment">// 关注返回值可以让父子进程执行不同的代码区</span></span><br><span class="line">    pid = fork();</span><br><span class="line">    <span class="keyword">if</span> (pid == <span class="number">-1</span>) &#123;</span><br><span class="line">        PRINT_ERR(<span class="string">&quot;fork error&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (pid == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 子进程代码区</span></span><br><span class="line">        func();</span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>); <span class="comment">//不会执行</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 父进程代码区</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;head.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">func</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;111111111\n&quot;</span>); <span class="comment">//打印</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;2222222222&quot;</span>);  <span class="comment">//执行了，但是不会打印到终端，因为没刷新缓冲区</span></span><br><span class="line">    _exit(EXIT_SUCCESS);   <span class="comment">//退出进程，进程变成僵尸进程</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;3333333333\n&quot;</span>);<span class="comment">//没有执行</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span>* argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">pid_t</span> pid;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 关注返回值可以让父子进程执行不同的代码区</span></span><br><span class="line">    pid = fork();</span><br><span class="line">    <span class="keyword">if</span> (pid == <span class="number">-1</span>) &#123;</span><br><span class="line">        PRINT_ERR(<span class="string">&quot;fork error&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (pid == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 子进程代码区</span></span><br><span class="line">        func();</span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>); <span class="comment">//没有执行</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 父进程代码区</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="wait-waitpid-函数"><a href="#wait-waitpid-函数" class="headerlink" title="wait waitpid 函数"></a><code>wait</code> <code>waitpid</code> 函数</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">pid_t</span> <span class="title function_">wait</span><span class="params">(<span class="type">int</span> *wstatus)</span>;</span><br><span class="line"><span class="comment">// 功能：在父进程中调用wait回收子进程的资源（阻塞等待子进程结束）</span></span><br><span class="line"><span class="comment">// 参数：</span></span><br><span class="line"><span class="comment">//     @wstatus:接收到子进程_exit/exit退出的状态值</span></span><br><span class="line"><span class="comment">// 返回值：成功返回回收掉资源的进程号，失败返回-1，置位错误码</span></span><br><span class="line"></span><br><span class="line">wait(<span class="literal">NULL</span>); <span class="comment">//回收子进程的资源，但不关注子进程退出状态</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> wstatus;</span><br><span class="line">wait(&amp;wstatus);</span><br><span class="line"><span class="comment">// WIFEXITED(wstatus):      如果进程遇到exit/_exit/return正常退出，这个宏返回真</span></span><br><span class="line"><span class="comment">// WEXITSTATUS(wstatus)：   获取wstatus中bit8-bit15这8个bit，代表子进程退出的状态</span></span><br><span class="line"><span class="comment">// WIFSIGNALED(wstatus)：   如果是信号导致进程退出，这个宏返回真</span></span><br><span class="line"><span class="comment">// WTERMSIG(wstatus)：      获取信号号，信号号对应的是wstatus中bit0-bit6这7个bit位</span></span><br><span class="line">    </span><br><span class="line"><span class="type">pid_t</span> <span class="title function_">waitpid</span><span class="params">(<span class="type">pid_t</span> pid, <span class="type">int</span> *wstatus, <span class="type">int</span> options)</span>;</span><br><span class="line"><span class="comment">// 功能：指定回收pid号进程的资源</span></span><br><span class="line"><span class="comment">// 参数：</span></span><br><span class="line"><span class="comment">//     @pid:进程号</span></span><br><span class="line"><span class="comment">//        &lt; -1   回收pid绝对值同组的任意的子进程的资源</span></span><br><span class="line"><span class="comment">//        -1     回收任意子进程的资源</span></span><br><span class="line"><span class="comment">//        0      回收和调用进程同组的子进程的资源</span></span><br><span class="line"><span class="comment">//        &gt; 0    表示回收pid对应的子进程的资源</span></span><br><span class="line"><span class="comment">// 	@wstatus:收到调用的子进程退出的状态</span></span><br><span class="line"><span class="comment">// 	@options: </span></span><br><span class="line"><span class="comment">// 			0        :阻塞回收</span></span><br><span class="line"><span class="comment">// 			WNOHANG  :非阻塞回收</span></span><br><span class="line"><span class="comment">// 返回值：成功返回回收掉的子进程的pid</span></span><br><span class="line"><span class="comment">//        	如果是非阻塞，没有回收掉子进程返回0</span></span><br><span class="line"><span class="comment">//         如果失败返回-1置位错误码</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// wait(NULL)     === 等价于 == waitpid(-1,NULL,0)</span></span><br><span class="line"><span class="comment">// wait(&amp;wstatus) === 等价于 == waitpid(-1,&amp;wstatus,0)</span></span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;head.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">func</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;111111111\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;2222222222&quot;</span>);</span><br><span class="line">    <span class="comment">// while(1);</span></span><br><span class="line">    _exit(<span class="number">34</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;3333333333\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span>* argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">pid_t</span> pid;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 关注返回值可以让父子进程执行不同的代码区</span></span><br><span class="line">    pid = fork();</span><br><span class="line">    <span class="keyword">if</span> (pid == <span class="number">-1</span>) &#123;</span><br><span class="line">        PRINT_ERR(<span class="string">&quot;fork error&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (pid == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 子进程代码区</span></span><br><span class="line">        func();</span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 父进程代码区</span></span><br><span class="line">        <span class="type">int</span> wstatus;</span><br><span class="line">        <span class="type">pid_t</span> pid1;</span><br><span class="line">        <span class="keyword">if</span>((pid1 = wait(&amp;wstatus))==<span class="number">-1</span>)</span><br><span class="line">            PRINT_ERR(<span class="string">&quot;wait error&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;pid = %d,pid1 = %d\n&quot;</span>,pid,pid1);</span><br><span class="line">        <span class="keyword">if</span>(WIFEXITED(wstatus))&#123; <span class="comment">//如果为真是正常退出的 </span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;status = %d\n&quot;</span>,WEXITSTATUS(wstatus));<span class="comment">//获取wstatus中bit8-bit15</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(WIFSIGNALED(wstatus))&#123;<span class="comment">//信号导致子进程退出</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;signo = %d\n&quot;</span>, WTERMSIG(wstatus)); <span class="comment">//获取wstatus中bit0-bit6</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>waitpid函数实例</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;head.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">func</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;111111111\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;2222222222&quot;</span>);</span><br><span class="line">    sleep(<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;我是第一个子进程\n&quot;</span>);</span><br><span class="line">    <span class="comment">// while (1);</span></span><br><span class="line">    _exit(<span class="number">34</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;3333333333\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span>* argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">pid_t</span> pid;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 关注返回值可以让父子进程执行不同的代码区</span></span><br><span class="line">    pid = fork();</span><br><span class="line">    <span class="keyword">if</span> (pid == <span class="number">-1</span>) &#123;</span><br><span class="line">        PRINT_ERR(<span class="string">&quot;fork error&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (pid == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 子进程代码区</span></span><br><span class="line">        func();</span><br><span class="line">        <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">            ;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="type">pid_t</span> pid1;</span><br><span class="line">        <span class="keyword">if</span> ((pid1 = fork()) == <span class="number">-1</span>) &#123;</span><br><span class="line">            PRINT_ERR(<span class="string">&quot;fork error&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (pid1 == <span class="number">0</span>) &#123;</span><br><span class="line">            sleep(<span class="number">1</span>);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;我是第二个子进程\n&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 父进程代码区</span></span><br><span class="line">        <span class="type">int</span> wstatus;</span><br><span class="line">        <span class="type">pid_t</span> pid2;</span><br><span class="line">        <span class="keyword">if</span> ((pid2 = waitpid(<span class="number">-1</span>, &amp;wstatus, WNOHANG)) == <span class="number">-1</span>)</span><br><span class="line">            PRINT_ERR(<span class="string">&quot;wait error&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;pid = %d,pid2 = %d\n&quot;</span>, pid, pid2);</span><br><span class="line">        <span class="keyword">if</span> (WIFEXITED(wstatus)) &#123; <span class="comment">// 如果为真是正常退出的 ,bit8-bit15</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;status = %d\n&quot;</span>, WEXITSTATUS(wstatus));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (WIFSIGNALED(wstatus)) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;signo = %d\n&quot;</span>, WTERMSIG(wstatus)); <span class="comment">// bit0-bit6</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="进程间的通信"><a href="#进程间的通信" class="headerlink" title="进程间的通信"></a>进程间的通信</h1><h2 id="进程间通信方式简介"><a href="#进程间通信方式简介" class="headerlink" title="进程间通信方式简介"></a>进程间通信方式简介</h2><p>在linux系统上常用的进程间通信方式有如下7种：</p>
<ul>
<li>传统进程间通信<ul>
<li>无名管道</li>
<li>有名管道</li>
<li>信号</li>
</ul>
</li>
<li>System V IPC进程间通信<ul>
<li>消息队列</li>
<li>共享内存</li>
<li>信号量（信号灯集）</li>
</ul>
</li>
<li>BSD(伯克利分校)基于网络的进程间通信<ul>
<li><code>socket</code> 实现进程间通信</li>
</ul>
</li>
</ul>
<h2 id="无名管道"><a href="#无名管道" class="headerlink" title="无名管道"></a>无名管道</h2><h3 id="无名管道通信原理"><a href="#无名管道通信原理" class="headerlink" title="无名管道通信原理"></a>无名管道通信原理</h3><p>如果A和B进程想要通过无名管道通信，那就必须在内核空间创建一个无名管道 <strong>（64K）</strong>, A和B进程必须是亲缘关系的进程，A进程向管道的一端写数据，B进程可以从管道的另外一端读数据。在A进程和B进程进行数据传输的时候是不允许使用 <code>lseek</code> 函数的。无名管道是 <strong>半双工</strong> 的通信方式。<br>如果A进程一直向管道中写数据写满 <code>64K</code> 的时候A进程阻塞，直到B进程读一部分数据之后A才能继续写。<br>如果B进程在读数据的时候，无名管道是空的，B进程阻塞。</p>
<h3 id="无名管道的API"><a href="#无名管道的API" class="headerlink" title="无名管道的API"></a>无名管道的API</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">pipe</span><span class="params">(<span class="type">int</span> pipefd[<span class="number">2</span>])</span>; </span><br><span class="line"><span class="comment">// 功能：创建一个无名管道</span></span><br><span class="line"><span class="comment">// 参数：</span></span><br><span class="line"><span class="comment">//     @pipefd:返回管道的两端</span></span><br><span class="line"><span class="comment">//         	pipefd[1]:写端</span></span><br><span class="line"><span class="comment">//         	pipefd[0]:读端</span></span><br><span class="line"><span class="comment">// 返回值：成功返回0，失败返回-1置位错误码</span></span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;head.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span>* argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">pid_t</span> pid;</span><br><span class="line">    <span class="type">int</span> pipefd[<span class="number">2</span>];</span><br><span class="line">    <span class="type">char</span> s[<span class="number">128</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    <span class="comment">// 1.创建无名管道</span></span><br><span class="line">    <span class="keyword">if</span> (pipe(pipefd))</span><br><span class="line">        PRINT_ERR(<span class="string">&quot;pipe error&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2.创建父子进程</span></span><br><span class="line">    <span class="keyword">if</span> ((pid = fork()) == <span class="number">-1</span>) &#123;</span><br><span class="line">        PRINT_ERR(<span class="string">&quot;fork error&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (pid == <span class="number">0</span>) &#123;</span><br><span class="line">        close(pipefd[<span class="number">1</span>]); <span class="comment">// 关闭子进程的写端</span></span><br><span class="line">        <span class="comment">// 子进程</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="comment">// 清空s</span></span><br><span class="line">            <span class="built_in">memset</span>(s,<span class="number">0</span>,<span class="keyword">sizeof</span>(s));</span><br><span class="line">            <span class="comment">// 从管道向s中读数据</span></span><br><span class="line">            read(pipefd[<span class="number">0</span>], s, <span class="keyword">sizeof</span>(s));</span><br><span class="line">            <span class="comment">// 如果读到的是quit就退出</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">strcmp</span>(s, <span class="string">&quot;quit&quot;</span>) == <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="comment">// 将读取到的数据打印到终端上</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, s);</span><br><span class="line">        &#125;</span><br><span class="line">        close(pipefd[<span class="number">0</span>]);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_SUCCESS);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        close(pipefd[<span class="number">0</span>]); <span class="comment">// 关闭父进程的读端</span></span><br><span class="line">        <span class="comment">// 父进程</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="comment">// 从终端向s数组读取字符串</span></span><br><span class="line">            fgets(s, <span class="keyword">sizeof</span>(s), <span class="built_in">stdin</span>);</span><br><span class="line">            <span class="comment">// 清除换行符</span></span><br><span class="line">            <span class="keyword">if</span> (s[<span class="built_in">strlen</span>(s) - <span class="number">1</span>] == <span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">                s[<span class="built_in">strlen</span>(s) - <span class="number">1</span>] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">            <span class="comment">// 向管道中写数据</span></span><br><span class="line">            write(pipefd[<span class="number">1</span>], s, <span class="built_in">strlen</span>(s));</span><br><span class="line">            <span class="comment">// 如果输入的是quit让进程退出</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">strcmp</span>(s, <span class="string">&quot;quit&quot;</span>) == <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        close(pipefd[<span class="number">1</span>]);</span><br><span class="line">        <span class="comment">//等待回收子进程的资源</span></span><br><span class="line">        wait(<span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="无名管道通信特点"><a href="#无名管道通信特点" class="headerlink" title="无名管道通信特点"></a>无名管道通信特点</h3><p><strong>读端存在写管道</strong>：有多少写多少，直到写满（64K）为止，写阻塞</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;head.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span>* argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> pipefd[<span class="number">2</span>];</span><br><span class="line">    <span class="type">char</span> s[<span class="number">128</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1.创建无名管道</span></span><br><span class="line">    <span class="keyword">if</span> (pipe(pipefd))</span><br><span class="line">        PRINT_ERR(<span class="string">&quot;pipe error&quot;</span>);</span><br><span class="line">    <span class="comment">// 2.读端存在，但是没有读数据，写管道</span></span><br><span class="line">    <span class="comment">// 管道的大小是64K(65536),如果写65536个字节，写没有阻塞，printf(&quot;1111111...&quot;)会打印</span></span><br><span class="line">    <span class="comment">// 如果将循环的次数改为65537的时候，最后一次写，写阻塞，所以printf(&quot;11111...&quot;)不会打印</span></span><br><span class="line">    <span class="comment">// 说明写满了</span></span><br><span class="line">    <span class="type">char</span> ch=<span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">65537</span>;i++)&#123;</span><br><span class="line">        write(pipefd[<span class="number">1</span>],&amp;ch,<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;11111111111111111111111111\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>读端不存在写管道</strong>：管道破裂，进程收到SIGPIPE信号，进程退出</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;head.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span>* argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> pipefd[<span class="number">2</span>];</span><br><span class="line">    <span class="type">char</span> s[<span class="number">128</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1.创建无名管道</span></span><br><span class="line">    <span class="keyword">if</span> (pipe(pipefd))</span><br><span class="line">        PRINT_ERR(<span class="string">&quot;pipe error&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    close(pipefd[<span class="number">0</span>]); <span class="comment">//关闭读端</span></span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> ch=<span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">    <span class="comment">//关闭读端，写管道，管道破裂，操作系统给当前进程发送SIGPIPE，</span></span><br><span class="line">    <span class="comment">// 将当前进程杀死</span></span><br><span class="line">    write(pipefd[<span class="number">1</span>],&amp;ch,<span class="number">1</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>写端存在读管道</strong>：管道中有多少字节的数据就能读多少数据，如果没有数据的时候，读阻塞</p>
<p><strong>写端不存在端管道</strong>：管道中有多少字节的数据就能读多少数据，如果没有数据的时候，读立即返回</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;head.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span>* argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> pipefd[<span class="number">2</span>];</span><br><span class="line">    <span class="type">char</span> s[<span class="number">128</span>] = <span class="string">&quot;i am test pipe func...\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1.创建无名管道</span></span><br><span class="line">    <span class="keyword">if</span> (pipe(pipefd))</span><br><span class="line">        PRINT_ERR(<span class="string">&quot;pipe error&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    write(pipefd[<span class="number">1</span>],s,<span class="built_in">strlen</span>(s));</span><br><span class="line"></span><br><span class="line">    close(pipefd[<span class="number">1</span>]); <span class="comment">//关闭写端</span></span><br><span class="line">    </span><br><span class="line">    <span class="type">char</span> ch;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        read(pipefd[<span class="number">0</span>],&amp;ch,<span class="number">1</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;ch = %c\n&quot;</span>,ch);</span><br><span class="line">        usleep(<span class="number">100000</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>总结</strong>: </p>
<ul>
<li><strong>读端存在写管道</strong>：有多少写多少，直到写满（64K）为止，写阻塞</li>
<li><strong>读端不存在写管道</strong>：管道破裂，进程收到SIGPIPE信号，进程退出</li>
<li><strong>写端存在读管道</strong>：管道中有多少字节的数据就能读多少数据，如果没有数据的时候，读阻塞</li>
<li><strong>写端不存在读管道</strong>：管道中有多少字节的数据就能读多少数据，如果没有数据的时候，读立即返回</li>
</ul>
<h2 id="有名管道"><a href="#有名管道" class="headerlink" title="有名管道"></a>有名管道</h2><h3 id="有名管道通信原理"><a href="#有名管道通信原理" class="headerlink" title="有名管道通信原理"></a>有名管道通信原理</h3><p>有名管道可以实现任意进程间的通信，有名管道的大小也是 <code>64K</code>，有名管道也是不支持 <code>lseek</code>,有名管道也是 <strong>半双工</strong> 的通信方式。有名管道创建之后会在 <strong>用户空间产生一个管道文件</strong>，这个管道文件是在内存上存储的。<br>如果A和B两个进程想要通过有名管道通信，就打开管道文件，向管道中写向管道中读就可</p>
<h3 id="有名管道的API"><a href="#有名管道的API" class="headerlink" title="有名管道的API"></a>有名管道的API</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">mkfifo</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *pathname, <span class="type">mode_t</span> mode)</span>;</span><br><span class="line"><span class="comment">// 功能：创建有名管道</span></span><br><span class="line"><span class="comment">// 参数：</span></span><br><span class="line"><span class="comment">//     @pathname:管道文件的路径及名字</span></span><br><span class="line"><span class="comment">// 	@mode:管道文件的操作权限(mode &amp; ~umask)</span></span><br><span class="line"><span class="comment">// 返回值：成功返回0，失败返回-1置位错误码</span></span><br></pre></td></tr></table></figure>
<p>01mkfifo.c</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;head.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FIFO_NAME <span class="string">&quot;./myfifo&quot;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc,<span class="type">const</span> <span class="type">char</span> * argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 1.创建管道</span></span><br><span class="line">    <span class="keyword">if</span>(mkfifo(FIFO_NAME,<span class="number">0666</span>))</span><br><span class="line">        PRINT_ERR(<span class="string">&quot;mkfifo error&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2.等待用户使用</span></span><br><span class="line">    getchar();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3.销毁管道</span></span><br><span class="line">    <span class="type">char</span> s[<span class="number">50</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="built_in">snprintf</span>(s,<span class="keyword">sizeof</span>(s),<span class="string">&quot;rm -rf %s&quot;</span>,FIFO_NAME);</span><br><span class="line">    system(s);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>02write.c</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;head.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FIFO_NAME <span class="string">&quot;./myfifo&quot;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span>* argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> fd;</span><br><span class="line">    <span class="type">char</span> s[<span class="number">128</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    <span class="keyword">if</span> ((fd = open(FIFO_NAME, O_WRONLY)) == <span class="number">-1</span>)</span><br><span class="line">        PRINT_ERR(<span class="string">&quot;open error&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;input &gt; &quot;</span>);</span><br><span class="line">        <span class="comment">// 从终端向s数组读取字符串</span></span><br><span class="line">        fgets(s, <span class="keyword">sizeof</span>(s), <span class="built_in">stdin</span>);</span><br><span class="line">        <span class="comment">// 清除换行符</span></span><br><span class="line">        <span class="keyword">if</span> (s[<span class="built_in">strlen</span>(s) - <span class="number">1</span>] == <span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">            s[<span class="built_in">strlen</span>(s) - <span class="number">1</span>] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">        <span class="comment">// 向管道中写数据</span></span><br><span class="line">        write(fd, s, <span class="built_in">strlen</span>(s));</span><br><span class="line">        <span class="comment">// 如果输入的是quit让进程退出</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">strcmp</span>(s, <span class="string">&quot;quit&quot;</span>) == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    close(fd);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>03read.c</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;head.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FIFO_NAME <span class="string">&quot;./myfifo&quot;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span>* argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> fd;</span><br><span class="line">    <span class="type">char</span> s[<span class="number">128</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    <span class="keyword">if</span> ((fd = open(FIFO_NAME, O_RDONLY)) == <span class="number">-1</span>)</span><br><span class="line">        PRINT_ERR(<span class="string">&quot;open error&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="built_in">memset</span>(s, <span class="number">0</span>, <span class="keyword">sizeof</span>(s));</span><br><span class="line">        read(fd, s, <span class="keyword">sizeof</span>(s));</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;s = %s\n&quot;</span>, s);</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">strcmp</span>(s, <span class="string">&quot;quit&quot;</span>) == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    close(fd);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="有名管道的练习"><a href="#有名管道的练习" class="headerlink" title="有名管道的练习"></a>有名管道的练习</h3><p>使用有名管道传输文件，<br>A进程读文件，将文件中的内容写入到管道中<br>B进程读取管道，将管道中的数据写入到新文件中。</p>
<p>01mkfifo.c</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;head.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FIFO_NAME <span class="string">&quot;./myfifo&quot;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc,<span class="type">const</span> <span class="type">char</span> * argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 1.创建管道</span></span><br><span class="line">    <span class="keyword">if</span>(mkfifo(FIFO_NAME,<span class="number">0666</span>))</span><br><span class="line">        PRINT_ERR(<span class="string">&quot;mkfifo error&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2.等待用户使用</span></span><br><span class="line">    getchar();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3.销毁管道</span></span><br><span class="line">    <span class="type">char</span> s[<span class="number">50</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="built_in">snprintf</span>(s,<span class="keyword">sizeof</span>(s),<span class="string">&quot;rm -rf %s&quot;</span>,FIFO_NAME);</span><br><span class="line">    system(s);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>02write.c</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;head.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FIFO_NAME <span class="string">&quot;./myfifo&quot;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span>* argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> fd1, fd2, ret;</span><br><span class="line">    <span class="type">char</span> s[<span class="number">128</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    <span class="comment">// 校验参数</span></span><br><span class="line">    <span class="keyword">if</span> (argc != <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;input error,try again\n&quot;</span>);</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;usgage: ./a.out srcfile\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 打开源文件</span></span><br><span class="line">    <span class="keyword">if</span> ((fd1 = open(argv[<span class="number">1</span>], O_RDONLY)) == <span class="number">-1</span>)</span><br><span class="line">        PRINT_ERR(<span class="string">&quot;open error&quot;</span>);</span><br><span class="line">    <span class="comment">// 打开管道文件</span></span><br><span class="line">    <span class="keyword">if</span> ((fd2 = open(FIFO_NAME, O_WRONLY)) == <span class="number">-1</span>)</span><br><span class="line">        PRINT_ERR(<span class="string">&quot;open error&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 循环读写（从源文件读，向管道写）</span></span><br><span class="line">    <span class="keyword">while</span> ((ret = read(fd1, s, <span class="keyword">sizeof</span>(s))) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        write(fd2,s,ret);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    close(fd1);</span><br><span class="line">    close(fd2);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>03read.c</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;head.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FIFO_NAME <span class="string">&quot;./myfifo&quot;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span>* argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> fd1, fd2, ret;</span><br><span class="line">    <span class="type">char</span> s[<span class="number">128</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    <span class="comment">// 校验参数</span></span><br><span class="line">    <span class="keyword">if</span> (argc != <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;input error,try again\n&quot;</span>);</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;usgage: ./a.out destfile\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 打开目标文件</span></span><br><span class="line">    <span class="keyword">if</span> ((fd1 = open(argv[<span class="number">1</span>], O_WRONLY|O_CREAT|O_TRUNC,<span class="number">0666</span>)) == <span class="number">-1</span>)</span><br><span class="line">        PRINT_ERR(<span class="string">&quot;open error&quot;</span>);</span><br><span class="line">    <span class="comment">// 打开管道文件</span></span><br><span class="line">    <span class="keyword">if</span> ((fd2 = open(FIFO_NAME, O_RDONLY)) == <span class="number">-1</span>)</span><br><span class="line">        PRINT_ERR(<span class="string">&quot;open error&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 循环读写（从源文件读，向管道写）</span></span><br><span class="line">    <span class="keyword">while</span> ((ret = read(fd2, s, <span class="keyword">sizeof</span>(s))) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        write(fd1,s,ret);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    close(fd1);</span><br><span class="line">    close(fd2);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="有名管道读写的特点"><a href="#有名管道读写的特点" class="headerlink" title="有名管道读写的特点"></a>有名管道读写的特点</h3><ul>
<li><p><strong>读端存在写管道</strong>：<em>有多少写多少，直到写满为止（64K），写阻塞</em></p>
</li>
<li><p><strong>读端没有打开过，写管道</strong>：<em>写端在open位置阻塞</em></p>
</li>
<li><p><strong>读端先打开后关闭，写管道</strong>：<em>管道破裂，收到SIGPIPE信号，进程结束</em></p>
</li>
<li><p><strong>写端存在读管道</strong>：<em>有多少读多少，没数据读的时候读阻塞</em></p>
</li>
<li><p><strong>写端没有打开过，读管道</strong>：<em>读端在open的位置阻塞</em></p>
</li>
<li><p><strong>写端先打开后关闭，读管道</strong>：<em>有多少读多少，没数据的时候读立即返回（读返回值是0）</em></p>
</li>
</ul>
<h2 id="信号"><a href="#信号" class="headerlink" title="信号"></a>信号</h2><h3 id="信号简介"><a href="#信号简介" class="headerlink" title="信号简介"></a>信号简介</h3><p>用户可以通过 <code>kill</code> 命令给进程发信号，操作系统也可以给进程发送信号。进程对信号的响应方式有三种：<strong>忽略，默认，捕捉</strong></p>
<h3 id="发信号的命令"><a href="#发信号的命令" class="headerlink" title="发信号的命令"></a>发信号的命令</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">kill</span> -信号号  PID</span><br></pre></td></tr></table></figure>

<h3 id="信号的查看方式"><a href="#信号的查看方式" class="headerlink" title="信号的查看方式"></a>信号的查看方式</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">kill</span> -l</span><br></pre></td></tr></table></figure>
<h3 id="常用的信号"><a href="#常用的信号" class="headerlink" title="常用的信号"></a>常用的信号</h3><table>
<thead>
<tr>
<th align="center">信号名</th>
<th align="center">默认操作</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>SIGHUP</code></td>
<td align="center"><code>终止</code></td>
<td align="left">该信号在用户终端关闭时产生，通常是发给和该终端关联的会话内的所有进程</td>
</tr>
<tr>
<td align="center"><code>SIGINT</code></td>
<td align="center"><code>终止</code></td>
<td align="left">该信号在用户键入 INTR 字符 <code>ctrl + c</code> 时产生，内核发送此信号发送到当前终端的所有前台进程</td>
</tr>
<tr>
<td align="center"><code>SIGQUIT</code></td>
<td align="center"><code>终止</code></td>
<td align="left">该信号和 <code>SIGINT</code> 类似，但由 UIT 字符 <code>Ctrl + \</code></td>
</tr>
<tr>
<td align="center"><code>SIGILL</code></td>
<td align="center"><code>终止</code></td>
<td align="left">该信号在一个进程企图执行一条非法指令时产生</td>
</tr>
<tr>
<td align="center"><code>SIGSEV</code></td>
<td align="center"><code>终止</code></td>
<td align="left">该信号在非法访问内存时产生，如野指针、缓冲区溢出</td>
</tr>
<tr>
<td align="center"><code>SIGPIPR</code></td>
<td align="center"><code>终止</code></td>
<td align="left">当进程往一个没有读端的管道中写入时产生，代表 <strong>管道破裂</strong></td>
</tr>
<tr>
<td align="center"><code>SIGKILL</code></td>
<td align="center"><code>终止</code></td>
<td align="left">该信号用于立即结束程序的运行，不能被捕捉或忽略</td>
</tr>
<tr>
<td align="center"><code>SIGSTOP</code></td>
<td align="center"><code>暂停进程</code></td>
<td align="left">该信号用于立即暂停程序的运行，不能被捕捉或忽略</td>
</tr>
<tr>
<td align="center"><code>SIGTSTP</code></td>
<td align="center"><code>暂停进程</code></td>
<td align="left">该信号用于暂停进程，在用户键入 SUSP 字符 <code>Ctrl + z</code> 时产生</td>
</tr>
<tr>
<td align="center"><code>SIGCONT</code></td>
<td align="center"><code>继续运行</code></td>
<td align="left">该信号用于继续运行进程</td>
</tr>
<tr>
<td align="center"><code>SIGALRM</code></td>
<td align="center"><code>终止</code></td>
<td align="left">该信号在调用 <code>alarm</code> 函数设置的定时器超时时产生</td>
</tr>
<tr>
<td align="center"><code>SIGUSR1/2</code></td>
<td align="center"><code>终止</code></td>
<td align="left">该信号由用户使用</td>
</tr>
</tbody></table>
<p><strong><code>SIGCHLD</code> : 当子进程退出的时候，父进程会收到这个信号</strong></p>
<blockquote>
<p>  注：在所有的信号中，只有SIGKILL&#x2F;SIGSTOP两个信号不能被捕捉，也不能被忽略。只能执行默认的动作。</p>
</blockquote>
<h3 id="signal-函数"><a href="#signal-函数" class="headerlink" title="signal 函数"></a><code>signal</code> 函数</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="title function_">void</span> <span class="params">(*<span class="type">sighandler_t</span>)</span><span class="params">(<span class="type">int</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">sighandler_t</span> <span class="title function_">signal</span><span class="params">(<span class="type">int</span> signum, <span class="type">sighandler_t</span> handler)</span>;</span><br><span class="line"><span class="comment">// 功能：给进程对信号指定处理方式</span></span><br><span class="line"><span class="comment">// 参数：</span></span><br><span class="line"><span class="comment">//     @signum:信号号</span></span><br><span class="line"><span class="comment">// 	@handler:处理方式</span></span><br><span class="line"><span class="comment">//         SIG_IGN：忽略</span></span><br><span class="line"><span class="comment">//         SIG_DFL：默认</span></span><br><span class="line"><span class="comment">//         handle:捕捉</span></span><br><span class="line"><span class="comment">//         void handle(int signo)</span></span><br><span class="line"><span class="comment">//         &#123;</span></span><br><span class="line"><span class="comment">//             </span></span><br><span class="line"><span class="comment">//         &#125;</span></span><br><span class="line"><span class="comment">// 返回值：成功返回handler,失败返回SIG_ERR，置位错误码</span></span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;head.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">signal_handle</span><span class="params">(<span class="type">int</span> signo)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(signo == SIGINT)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;我收到了一个ctrl+c信号\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span>* argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 1.对SIGINT忽略</span></span><br><span class="line">    <span class="comment">// if(SIG_ERR == signal(SIGINT,SIG_IGN))</span></span><br><span class="line">    <span class="comment">//     PRINT_ERR(&quot;signal error&quot;);</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2.对SIGINT默认</span></span><br><span class="line">    <span class="comment">// if(SIG_ERR == signal(SIGINT,SIG_DFL))</span></span><br><span class="line">    <span class="comment">//     PRINT_ERR(&quot;signal error&quot;);</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3.对SIGINT捕捉</span></span><br><span class="line">    <span class="keyword">if</span> (SIG_ERR == signal(SIGINT, signal_handle))</span><br><span class="line">        PRINT_ERR(<span class="string">&quot;signal error&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h3><p>使用signal捕捉管道破裂信号</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;head.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">handle</span><span class="params">(<span class="type">int</span> signo)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">switch</span> (signo) &#123;</span><br><span class="line">    <span class="keyword">case</span> SIGPIPE:</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;我捕捉到了一个管道破裂信号\n&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> SIGINT:</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;我捕捉到了一个ctrl+c信号\n&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span>* argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> pipefd[<span class="number">2</span>];</span><br><span class="line">    <span class="type">char</span> s[<span class="number">128</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((SIG_ERR == signal(SIGINT, handle)))</span><br><span class="line">        PRINT_ERR(<span class="string">&quot;signal error&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((SIG_ERR == signal(SIGPIPE, handle)))</span><br><span class="line">        PRINT_ERR(<span class="string">&quot;signal error&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (pipe(pipefd))</span><br><span class="line">        PRINT_ERR(<span class="string">&quot;pipe error&quot;</span>);</span><br><span class="line"></span><br><span class="line">    close(pipefd[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> ch = <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        write(pipefd[<span class="number">1</span>], &amp;ch, <span class="number">1</span>);</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>尝试使用非阻塞方式回收子进程资源, 记得要 <strong>回收掉子进程资源</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;head.h&gt;</span></span></span><br><span class="line"><span class="type">char</span> cmd[<span class="number">128</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="type">void</span> <span class="title function_">handle</span><span class="params">(<span class="type">int</span> signo)</span></span><br><span class="line">&#123;</span><br><span class="line">    waitpid(<span class="number">-1</span>,<span class="literal">NULL</span>,WNOHANG);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;我是父进程，我以非阻塞方式回收掉了子进程的资源\n&quot;</span>);</span><br><span class="line">    <span class="built_in">snprintf</span>(cmd,<span class="keyword">sizeof</span>(cmd),<span class="string">&quot;kill -%d %d&quot;</span>,SIGUSR1,getpid());</span><br><span class="line">    system(cmd);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span>* argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">pid_t</span> pid;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((pid = fork()) == <span class="number">-1</span>) &#123;</span><br><span class="line">        PRINT_ERR(<span class="string">&quot;fork error&quot;</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(pid == <span class="number">0</span>)&#123;</span><br><span class="line">        sleep(<span class="number">7</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;我是子进程，我执行了7s，我现在要退出...\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_SUCCESS);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(SIG_ERR == signal(SIGCHLD,handle))</span><br><span class="line">            PRINT_ERR(<span class="string">&quot;signal error&quot;</span>);</span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="发信号相关函数"><a href="#发信号相关函数" class="headerlink" title="发信号相关函数"></a>发信号相关函数</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">raise</span><span class="params">(<span class="type">int</span> sig)</span>;</span><br><span class="line"><span class="comment">// 功能：给自己发信号</span></span><br><span class="line"><span class="comment">// 参数：</span></span><br><span class="line"><span class="comment">//     @sig:信号号</span></span><br><span class="line"><span class="comment">// 返回值：成功返回0，失败返回非0</span></span><br><span class="line">        </span><br><span class="line"><span class="type">int</span> <span class="title function_">kill</span><span class="params">(<span class="type">pid_t</span> pid, <span class="type">int</span> sig)</span>;</span><br><span class="line"><span class="comment">// 功能：给指定pid的进程发送信号</span></span><br><span class="line"><span class="comment">// 参数：</span></span><br><span class="line"><span class="comment">//     @pid:进程号</span></span><br><span class="line"><span class="comment">//         pid &gt; 0 :给pid号的进程发信号</span></span><br><span class="line"><span class="comment">// 		pid = 0 :给同组的进程发送信号</span></span><br><span class="line"><span class="comment">// 		pid = -1:给所有有权限的进程发送信号</span></span><br><span class="line"><span class="comment">// 		pid &lt;-1:首先会对pid取绝对值，给和这个绝对值相同的组的进程发送信号</span></span><br><span class="line"><span class="comment">//     @信号号</span></span><br><span class="line"><span class="comment">// 返回值：成功返回0，失败返回-1置位错误码</span></span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> <span class="title function_">alarm</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> seconds)</span>;</span><br><span class="line"><span class="comment">// 功能：当seconds倒计时为0的时候发送SIGALRM信号</span></span><br><span class="line"><span class="comment">// 参数：</span></span><br><span class="line"><span class="comment">//     @seconds:秒钟数，如果填写为0，取消挂起的信号</span></span><br><span class="line"><span class="comment">// 返回值：如果alarm是第一次调用，返回0.</span></span><br><span class="line"><span class="comment">//         如果alarm不是第一次调用，返回上一次调用的剩余秒钟数</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//  alarm(5);  //返回值是0</span></span><br><span class="line"><span class="comment">//  sleep(2);  //延时2s</span></span><br><span class="line"><span class="comment">// 	alarm(5);  //返回值是3</span></span><br></pre></td></tr></table></figure>
<p><code>raise</code> &#x2F; <code>kill</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;head.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">handle</span><span class="params">(<span class="type">int</span> signo)</span></span><br><span class="line">&#123;</span><br><span class="line">    waitpid(<span class="number">-1</span>,<span class="literal">NULL</span>,WNOHANG);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;我是父进程，我以非阻塞方式回收掉了子进程的资源\n&quot;</span>);</span><br><span class="line">    <span class="comment">//raise(SIGUSR1);</span></span><br><span class="line">    kill(getpid(),SIGUSR1);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span>* argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">pid_t</span> pid;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((pid = fork()) == <span class="number">-1</span>) &#123;</span><br><span class="line">        PRINT_ERR(<span class="string">&quot;fork error&quot;</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(pid == <span class="number">0</span>)&#123;</span><br><span class="line">        sleep(<span class="number">7</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;我是子进程，我执行了7s，我现在要退出...\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_SUCCESS);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(SIG_ERR == signal(SIGCHLD,handle))</span><br><span class="line">            PRINT_ERR(<span class="string">&quot;signal error&quot;</span>);</span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>alarm</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;head.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">handle</span><span class="params">(<span class="type">int</span> signo)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;我收到了闹钟信号\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc,<span class="type">const</span> <span class="type">char</span> * argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(SIG_ERR == signal(SIGALRM,handle))</span><br><span class="line">        PRINT_ERR(<span class="string">&quot;signal error&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;第一次 = %d\n&quot;</span>,alarm(<span class="number">5</span>));</span><br><span class="line">    sleep(<span class="number">2</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;第二次 = %d\n&quot;</span>,alarm(<span class="number">5</span>));  <span class="comment">//SIGALRM</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>alarm</code> 2</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;head.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">handle</span><span class="params">(<span class="type">int</span> signo)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;系统自动出牌了\n&quot;</span>);</span><br><span class="line">    alarm(<span class="number">4</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc,<span class="type">const</span> <span class="type">char</span> * argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(SIG_ERR == signal(SIGALRM,handle))</span><br><span class="line">        PRINT_ERR(<span class="string">&quot;signal error&quot;</span>);</span><br><span class="line"></span><br><span class="line">    alarm(<span class="number">4</span>); </span><br><span class="line">    <span class="type">char</span> ch;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        ch = getchar();</span><br><span class="line">        getchar(); <span class="comment">//吃&#x27;\n&#x27;</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;用户出牌 = %c\n&quot;</span>,ch);</span><br><span class="line">        alarm(<span class="number">4</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="IPC进程间通信相关命令"><a href="#IPC进程间通信相关命令" class="headerlink" title="IPC进程间通信相关命令"></a>IPC进程间通信相关命令</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ipcs -q     <span class="comment">#查看消息队列</span></span><br><span class="line">ipcs -m     <span class="comment">#查看共享内存</span></span><br><span class="line">ipcs -s     <span class="comment">#查看信号灯集</span></span><br><span class="line">ipcrm -q msqid     <span class="comment">#删除消息队列</span></span><br><span class="line">ipcrm -m shmid     <span class="comment">#删除共享内存</span></span><br><span class="line">ipcrm -s semid     <span class="comment">#删除信号灯集</span></span><br></pre></td></tr></table></figure>

<h2 id="IPC进程间通信键值获取及组成"><a href="#IPC进程间通信键值获取及组成" class="headerlink" title="IPC进程间通信键值获取及组成"></a>IPC进程间通信键值获取及组成</h2><p>在使用IPC进程间通信的时候，首先需要获取一个key，只有当两个进程拿到相同的键的之后才能找到同一个IPC。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/ipc.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">key_t</span> <span class="title function_">ftok</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *pathname, <span class="type">int</span> proj_id)</span>;</span><br><span class="line"><span class="comment">// 功能：获取一个键值（键不是唯一的）</span></span><br><span class="line"><span class="comment">// 参数：</span></span><br><span class="line"><span class="comment">//     @pathname:路径及名字</span></span><br><span class="line"><span class="comment">// 	@proj_id:只有低8bit有效</span></span><br><span class="line"><span class="comment">// 返回值：成功返回键值，失败返回-1置位错误码</span></span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;head.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span>* argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">key_t</span> key;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">stat</span> <span class="title">st</span>;</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> ((key = ftok(<span class="string">&quot;/home/linux&quot;</span>, <span class="string">&#x27;t&#x27;</span>)) == <span class="number">-1</span>)</span><br><span class="line">        PRINT_ERR(<span class="string">&quot;ftok error&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;key = %#x\n&quot;</span>, key);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (stat(<span class="string">&quot;/home/linux&quot;</span>, &amp;st))</span><br><span class="line">        PRINT_ERR(<span class="string">&quot;stat error&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;inode = %#lx,devno = %#lx,proj_id = %#x\n&quot;</span>,st.st_ino,st.st_dev,<span class="string">&#x27;t&#x27;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="消息队列"><a href="#消息队列" class="headerlink" title="消息队列"></a>消息队列</h2><h3 id="消息队列通信原理"><a href="#消息队列通信原理" class="headerlink" title="消息队列通信原理"></a>消息队列通信原理</h3><p>如果想要使用消息队列实现进程间通信，就必须在内核空间创建出来消息队列，消息队列默认大小是 <code>16384（16K）</code>,当创建好消息队列之后A进程可以向消息队列中发消息，消息的格式是 <code>类型 + 正文</code>。当消息队列满的时候A进程如果还想往消息队列中发消息A进程休眠。B进程可以通过消息的类型从消息队列中取消息，取出的消息从队列中移除。<br>如果B进程想要获取的消息类型在队列中不存在B进程休眠等。</p>
<p>A进程向消息队列中发消息的时候可以采用：阻塞，非阻塞方式<br>B进程从消息队列中收消息的时候可以采用：阻塞，非阻塞方式</p>
<h3 id="msgget-msgsnd-msgrcv-msgctl"><a href="#msgget-msgsnd-msgrcv-msgctl" class="headerlink" title="msgget msgsnd msgrcv msgctl"></a><code>msgget</code> <code>msgsnd</code> <code>msgrcv</code> <code>msgctl</code></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/ipc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/msg.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">msgget</span><span class="params">(<span class="type">key_t</span> key, <span class="type">int</span> msgflg)</span>;</span><br><span class="line"><span class="comment">// 功能：创建消息队列</span></span><br><span class="line"><span class="comment">// 参数：</span></span><br><span class="line"><span class="comment">//     @key：键值</span></span><br><span class="line"><span class="comment">//         key:通过ftok获取</span></span><br><span class="line"><span class="comment">//         IPC_PRIVATE：只能用于亲缘间进程的通信</span></span><br><span class="line"><span class="comment">//     @msgflag：消息队列的标志位</span></span><br><span class="line"><span class="comment">//         IPC_CREAT|0666  或   IPC_CREAT|IPC_EXCL|0666</span></span><br><span class="line"><span class="comment">// 返回值：成功返回消息队列号，失败返回-1置位错误码</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">msgsnd</span><span class="params">(<span class="type">int</span> msqid, <span class="type">const</span> <span class="type">void</span> *msgp, <span class="type">size_t</span> msgsz, <span class="type">int</span> msgflg)</span>;</span><br><span class="line"><span class="comment">// 功能：向消息队列中发消息</span></span><br><span class="line"><span class="comment">// 参数：</span></span><br><span class="line"><span class="comment">//     @msqid:消息队列号</span></span><br><span class="line"><span class="comment">//     @msgp:消息的首地址</span></span><br><span class="line"><span class="comment">//           struct msgbuf &#123;</span></span><br><span class="line"><span class="comment">//                long mtype;     //消息的类型，必须大于0</span></span><br><span class="line"><span class="comment">//                char mtext[255];  //消息的正文</span></span><br><span class="line"><span class="comment">//            &#125;;</span></span><br><span class="line"><span class="comment">// 	@msgsz:消息正文的大小</span></span><br><span class="line"><span class="comment">// 	@msgflg:消息的标志</span></span><br><span class="line"><span class="comment">//         0：阻塞发送</span></span><br><span class="line"><span class="comment">//         IPC_NOWAIT：非阻塞发送</span></span><br><span class="line"><span class="comment">// 返回值：成功返回0，失败返回-1置位错误码</span></span><br><span class="line"></span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">msgrcv</span><span class="params">(<span class="type">int</span> msqid, <span class="type">void</span> *msgp, <span class="type">size_t</span> msgsz, <span class="type">long</span> msgtyp,<span class="type">int</span> msgflg)</span>;</span><br><span class="line"><span class="comment">// 功能：从消息队列获取消息</span></span><br><span class="line"><span class="comment">// 参数：</span></span><br><span class="line"><span class="comment">//     @msqid：消息队列号</span></span><br><span class="line"><span class="comment">//     @msgp：消息的首地址</span></span><br><span class="line"><span class="comment">//     @msgsz：消息正文的大小</span></span><br><span class="line"><span class="comment">//     @msgtyp：消息的类型</span></span><br><span class="line"><span class="comment">//         	如果=0，接收消息队列中的第一个消息</span></span><br><span class="line"><span class="comment">//         	如果&gt;0 ,接收msgtyp指定的消息类型</span></span><br><span class="line"><span class="comment">//         	如果&lt;0，那么将读取队列中第一个最小类型小于或等于msgtyp绝对值的消息。</span></span><br><span class="line"><span class="comment">//             2-3-100-500-30-2000</span></span><br><span class="line"><span class="comment">//                 -100===&gt;100</span></span><br><span class="line"><span class="comment">//             2-3-100-30</span></span><br><span class="line"><span class="comment">//     @msgflg：消息的标志</span></span><br><span class="line"><span class="comment">//         0：阻塞接收</span></span><br><span class="line"><span class="comment">//         IPC_NOWAIT：非阻塞接收</span></span><br><span class="line"><span class="comment">// 返回值：失败返回-1置位错误码。成功返回接收接收的字节的个数</span></span><br></pre></td></tr></table></figure>
<p>01snd.c</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;head.h&gt;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="type">long</span> mtype;</span><br><span class="line">    <span class="type">char</span> name[<span class="number">19</span>];</span><br><span class="line">    <span class="type">char</span> sex;</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">&#125; <span class="type">msg_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MSGSIZE  (sizeof(msg_t)-sizeof(long))</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span>* argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">key_t</span> key;</span><br><span class="line">    <span class="type">int</span> msgqid;</span><br><span class="line">    <span class="comment">// 1.获取键值</span></span><br><span class="line">    <span class="keyword">if</span> ((key = ftok(<span class="string">&quot;/home/linux/&quot;</span>, <span class="string">&#x27;p&#x27;</span>)) == <span class="number">-1</span>)</span><br><span class="line">        PRINT_ERR(<span class="string">&quot;ftok error&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2.创建消息队列</span></span><br><span class="line">    <span class="keyword">if</span> ((msgqid = msgget(key, IPC_CREAT | <span class="number">0666</span>)) == <span class="number">-1</span>)</span><br><span class="line">        PRINT_ERR(<span class="string">&quot;msgget error&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3.向消息队列中发消息</span></span><br><span class="line">    <span class="type">int</span> ret;</span><br><span class="line">    <span class="type">msg_t</span> msg;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">    retry:</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;input (type name sex age) &gt; &quot;</span>);</span><br><span class="line">        ret = <span class="built_in">scanf</span>(<span class="string">&quot;%ld %s %c %d&quot;</span>, &amp;msg.mtype, msg.name, &amp;msg.sex, &amp;msg.age);</span><br><span class="line">        <span class="keyword">if</span> (ret != <span class="number">4</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;input error,try again\n&quot;</span>);</span><br><span class="line">            <span class="keyword">while</span> (getchar() != <span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line">            <span class="keyword">goto</span> retry;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(msgsnd(msgqid, &amp;msg,MSGSIZE, <span class="number">0</span>))</span><br><span class="line">            PRINT_ERR(<span class="string">&quot;msgsnd error&quot;</span>);</span><br><span class="line">            </span><br><span class="line">        <span class="keyword">if</span>(msg.mtype == <span class="number">1000</span>) <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>02rcv.c</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;head.h&gt;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="type">long</span> mtype;</span><br><span class="line">    <span class="type">char</span> name[<span class="number">19</span>];</span><br><span class="line">    <span class="type">char</span> sex;</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">&#125; <span class="type">msg_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MSGSIZE  (sizeof(msg_t)-sizeof(long))</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span>* argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">key_t</span> key;</span><br><span class="line">    <span class="type">int</span> msgqid;</span><br><span class="line">    <span class="comment">// 1.获取键值</span></span><br><span class="line">    <span class="keyword">if</span> ((key = ftok(<span class="string">&quot;/home/linux/&quot;</span>, <span class="string">&#x27;p&#x27;</span>)) == <span class="number">-1</span>)</span><br><span class="line">        PRINT_ERR(<span class="string">&quot;ftok error&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2.创建消息队列</span></span><br><span class="line">    <span class="keyword">if</span>((msgqid = msgget(key,IPC_CREAT|<span class="number">0666</span>))==<span class="number">-1</span>)</span><br><span class="line">        PRINT_ERR(<span class="string">&quot;msgget error&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 3.接收消息</span></span><br><span class="line">    <span class="type">long</span> type;</span><br><span class="line">    <span class="type">msg_t</span> msg;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;input (type) &gt; &quot;</span>);</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%ld&quot;</span>,&amp;type);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(msgrcv(msgqid,&amp;msg,MSGSIZE,type,<span class="number">0</span>)==<span class="number">-1</span>)</span><br><span class="line">            PRINT_ERR(<span class="string">&quot;msgrcv error&quot;</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;type=%ld,name=%s,sex=%c,age=%d\n&quot;</span>,msg.mtype,msg.name,msg.sex,msg.age);</span><br><span class="line">        <span class="keyword">if</span>(msg.mtype == <span class="number">1000</span>) <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(msgctl(msgqid,IPC_RMID,<span class="literal">NULL</span>)) <span class="comment">//删除消息队列</span></span><br><span class="line">        PRINT_ERR(<span class="string">&quot;msgctl error&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="msgctl-函数详解"><a href="#msgctl-函数详解" class="headerlink" title="msgctl 函数详解"></a><code>msgctl</code> 函数详解</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">msgctl</span><span class="params">(<span class="type">int</span> msqid, <span class="type">int</span> cmd, <span class="keyword">struct</span> msqid_ds *buf)</span>;</span><br><span class="line"><span class="comment">// 功能：消息队列的控制</span></span><br><span class="line"><span class="comment">// 参数：</span></span><br><span class="line"><span class="comment">//     @msqid：消息队列号</span></span><br><span class="line"><span class="comment">//     @cmd：命令码</span></span><br><span class="line"><span class="comment">//          IPC_STAT：获取消息队列的属性(ipcs -q msqid)</span></span><br><span class="line"><span class="comment">//          IPC_SET：设置消息队列的属性(如设置消息队列大小)</span></span><br><span class="line"><span class="comment">//          IPC_RMID:立即删除消息队列，唤醒所有等待的读取器和写入（ipcrm -q msqid）</span></span><br><span class="line"><span class="comment">//             器进程(返回一个错误并将errno设置为EIDRM)。调用进程</span></span><br><span class="line"><span class="comment">//             必须具有适当的特权，或者它的有效用户ID必须是消息队</span></span><br><span class="line"><span class="comment">//             列的创建者或所有者的ID。在这种情况下，msgctl()的/*第</span></span><br><span class="line"><span class="comment">//             三个参数将被忽略*/。</span></span><br><span class="line"><span class="comment">//     @buf：msqid_ds消息队列属性结构体</span></span><br><span class="line"><span class="comment">// 返回值：成功返回0，失败返回-1，置位错误码</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// eg1:使用msgctl删除消息队列</span></span><br><span class="line">msgctl(msqid,IPC_RMID,<span class="literal">NULL</span>);</span><br><span class="line"><span class="comment">// eg2:获取消息队列属性</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">msqid_ds</span> <span class="title">msqds</span>;</span> </span><br><span class="line">msgctl(msqid, IPC_STAT, &amp;msqds); <span class="comment">//获取到的属性在msqds结构体中存放</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//以下是对msqid_ds结构体的详解</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">msqid_ds</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ipc_perm</span> <span class="title">msg_perm</span>;</span>	<span class="comment">//权限结构体</span></span><br><span class="line">    <span class="type">__time_t</span> msg_stime;		<span class="comment">//最后一次发送消息的时间</span></span><br><span class="line">    <span class="type">__time_t</span> msg_rtime;		<span class="comment">//最后一次接收消息的时间</span></span><br><span class="line">    <span class="type">__syscall_ulong_t</span> __msg_cbytes; <span class="comment">//当前消息队列中字节数</span></span><br><span class="line">    <span class="type">msgqnum_t</span> msg_qnum;		<span class="comment">//当前消息队列中消息的个数</span></span><br><span class="line">    <span class="type">msglen_t</span> msg_qbytes;	<span class="comment">//消息队列中能够容纳的字节数（16384）</span></span><br><span class="line">    <span class="type">__pid_t</span> msg_lspid;		<span class="comment">//最后一次发送消息的进程号</span></span><br><span class="line">    <span class="type">__pid_t</span> msg_lrpid;		<span class="comment">//最后一次接收消息的进程号</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ipc_perm</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">__key_t</span> __key;			<span class="comment">//键值</span></span><br><span class="line">    <span class="type">__uid_t</span> uid;			<span class="comment">//消息队列所属的uid</span></span><br><span class="line">    <span class="type">__gid_t</span> gid;			<span class="comment">//消息队列所属的gid</span></span><br><span class="line">    <span class="type">__uid_t</span> cuid;			<span class="comment">//创建消息队列的uid</span></span><br><span class="line">    <span class="type">__gid_t</span> cgid;			<span class="comment">//创建消息队列的gid</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">short</span> <span class="type">int</span> mode;	<span class="comment">//消息队列的读写权限</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;head.h&gt;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="type">long</span> mtype;</span><br><span class="line">    <span class="type">char</span> name[<span class="number">19</span>];</span><br><span class="line">    <span class="type">char</span> sex;</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">&#125; <span class="type">msg_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MSGSIZE (sizeof(msg_t) - sizeof(long))</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span>* argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">key_t</span> key;</span><br><span class="line">    <span class="type">int</span> msgqid;</span><br><span class="line">    <span class="comment">// 1.获取键值</span></span><br><span class="line">    <span class="keyword">if</span> ((key = ftok(<span class="string">&quot;/home/linux/&quot;</span>, <span class="string">&#x27;p&#x27;</span>)) == <span class="number">-1</span>)</span><br><span class="line">        PRINT_ERR(<span class="string">&quot;ftok error&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2.创建消息队列</span></span><br><span class="line">    <span class="keyword">if</span> ((msgqid = msgget(key, IPC_CREAT | <span class="number">0666</span>)) == <span class="number">-1</span>)</span><br><span class="line">        PRINT_ERR(<span class="string">&quot;msgget error&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3.向消息队列中发消息</span></span><br><span class="line">    <span class="type">int</span> ret;</span><br><span class="line">    <span class="type">msg_t</span> msg;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">    retry:</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;input (type name sex age) &gt; &quot;</span>);</span><br><span class="line">        ret = <span class="built_in">scanf</span>(<span class="string">&quot;%ld %s %c %d&quot;</span>, &amp;msg.mtype, msg.name, &amp;msg.sex, &amp;msg.age);</span><br><span class="line">        <span class="keyword">if</span> (ret != <span class="number">4</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;input error,try again\n&quot;</span>);</span><br><span class="line">            <span class="keyword">while</span> (getchar() != <span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">                ;</span><br><span class="line">            <span class="keyword">goto</span> retry;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (msgsnd(msgqid, &amp;msg, MSGSIZE, <span class="number">0</span>))</span><br><span class="line">            PRINT_ERR(<span class="string">&quot;msgsnd error&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (msg.mtype == <span class="number">1000</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4.获取消息队列属性</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">msqid_ds</span> <span class="title">msqds</span>;</span></span><br><span class="line">    <span class="keyword">if</span> (msgctl(msgqid, IPC_STAT, &amp;msqds))</span><br><span class="line">        PRINT_ERR(<span class="string">&quot;msgctl error&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;key=%#x,uid=%d,gid=%d,mode=%#o,nq=%ld,nb=%ld,mb=%ld\n&quot;</span>,</span><br><span class="line">        msqds.msg_perm.__key, msqds.msg_perm.uid, msqds.msg_perm.gid,</span><br><span class="line">        msqds.msg_perm.mode, msqds.msg_qnum, msqds.__msg_cbytes, msqds.msg_qbytes);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 5.设置消息队列属性</span></span><br><span class="line">    msqds.msg_qbytes = <span class="number">32768</span>;</span><br><span class="line">    <span class="keyword">if</span> (msgctl(msgqid, IPC_SET, &amp;msqds))</span><br><span class="line">        PRINT_ERR(<span class="string">&quot;msgctl error&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 6.再次获取消息队列属性</span></span><br><span class="line">    <span class="built_in">memset</span>(&amp;msqds, <span class="number">0</span>, <span class="keyword">sizeof</span>(msqds));</span><br><span class="line">    <span class="keyword">if</span> (msgctl(msgqid, IPC_STAT, &amp;msqds))</span><br><span class="line">        PRINT_ERR(<span class="string">&quot;msgctl error&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;key=%#x,uid=%d,gid=%d,mode=%#o,nq=%ld,nb=%ld,mb=%ld\n&quot;</span>,</span><br><span class="line">        msqds.msg_perm.__key, msqds.msg_perm.uid, msqds.msg_perm.gid,</span><br><span class="line">        msqds.msg_perm.mode, msqds.msg_qnum, msqds.__msg_cbytes, msqds.msg_qbytes);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 7.删除消息队列</span></span><br><span class="line">    <span class="keyword">if</span> (msgctl(msgqid, IPC_RMID, <span class="literal">NULL</span>))</span><br><span class="line">        PRINT_ERR(<span class="string">&quot;msgctl error&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="共享内存"><a href="#共享内存" class="headerlink" title="共享内存"></a>共享内存</h2><h3 id="共享内存的工作原理"><a href="#共享内存的工作原理" class="headerlink" title="共享内存的工作原理"></a>共享内存的工作原理</h3><p>共享内存是所有进程间通信方式中效率最高的一个，因为当创建共享内存之后，需要通信的A和B进程可以直接操作这块物理内存空间 ，省去了向内核拷贝数据的过程。共享内存的大小是 <code>4K</code> 的整数倍。</p>
<h3 id="shmget-shmat-shmdt-shmctl"><a href="#shmget-shmat-shmdt-shmctl" class="headerlink" title="shmget shmat shmdt shmctl"></a><code>shmget</code> <code>shmat</code> <code>shmdt</code> <code>shmctl</code></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/shm.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">shmget</span><span class="params">(<span class="type">key_t</span> key, <span class="type">size_t</span> size, <span class="type">int</span> shmflg)</span>;</span><br><span class="line"><span class="comment">// 功能：创建共享内存</span></span><br><span class="line"><span class="comment">// 参数：</span></span><br><span class="line"><span class="comment">//     @key:键值</span></span><br><span class="line"><span class="comment">//         key:通过ftok获取</span></span><br><span class="line"><span class="comment">//         IPC_PRIVATE：只能用于亲缘间进程的通信</span></span><br><span class="line"><span class="comment">// 	@size:共享内存的大小 4k整数倍</span></span><br><span class="line"><span class="comment">//     @msgflag:共享的标志位</span></span><br><span class="line"><span class="comment">//         IPC_CREAT|0666  或   IPC_CREAT|IPC_EXCL|0666</span></span><br><span class="line"><span class="comment">// 返回值：成功返回共享内存编号，失败返回-1置位错误码</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> *<span class="title function_">shmat</span><span class="params">(<span class="type">int</span> shmid, <span class="type">const</span> <span class="type">void</span> *shmaddr, <span class="type">int</span> shmflg)</span>;</span><br><span class="line"><span class="comment">// 功能：映射共享内存到当前的进程空间</span></span><br><span class="line"><span class="comment">// 参数：</span></span><br><span class="line"><span class="comment">//     @shmid:共享内存的编号</span></span><br><span class="line"><span class="comment">//     @shmaddr:NULL，让系统自动分配</span></span><br><span class="line"><span class="comment">//     @shmflg:共享内存的操作方式</span></span><br><span class="line"><span class="comment">//          0：读写</span></span><br><span class="line"><span class="comment">//          SHM_RDONLY：只读</span></span><br><span class="line"><span class="comment">// 返回值：成功返回共享内存的首地址，失败返回（void *）-1,并置位错误码</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">shmdt</span><span class="params">(<span class="type">const</span> <span class="type">void</span> *shmaddr)</span>;</span><br><span class="line"><span class="comment">// 功能：取消地址映射</span></span><br><span class="line"><span class="comment">// 参数：</span></span><br><span class="line"><span class="comment">//     @shmaddr:指向共享内存的指针</span></span><br><span class="line"><span class="comment">// 返回值：成功返回0，失败返回-1置位错误码</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">shmctl</span><span class="params">(<span class="type">int</span> shmid, <span class="type">int</span> cmd, <span class="keyword">struct</span> shmid_ds *buf)</span>;</span><br><span class="line"><span class="comment">// 功能：共享内存控制的函数</span></span><br><span class="line"><span class="comment">// 参数：</span></span><br><span class="line"><span class="comment">//     @shmid:共享内存的编号</span></span><br><span class="line"><span class="comment">//     @cmd:操作的命令码</span></span><br><span class="line"><span class="comment">//          IPC_STAT ：获取</span></span><br><span class="line"><span class="comment">//          IPC_SET：设置</span></span><br><span class="line"><span class="comment">// 		 IPC_RMID：删除共享内存</span></span><br><span class="line"><span class="comment">//         	标记要销毁的段。实际上，只有在最后一个进程将其分离之后</span></span><br><span class="line"><span class="comment">//         	(也就是说，关联结构shmid_ds的shm_nattch成员为零时)，</span></span><br><span class="line"><span class="comment">//         	段才会被销毁。调用者必须是段的所有者或创建者，或具有特权。buf参数被忽略。</span></span><br><span class="line"><span class="comment">// 	@buf:共享内存属性结构体指针</span></span><br><span class="line"><span class="comment">// 返回值:成功返回0，失败返回-1置位错误码</span></span><br></pre></td></tr></table></figure>
<p>01write.c</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;head.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SHMSIZE (4096)</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span>* argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">key_t</span> key;</span><br><span class="line">    <span class="type">int</span> shmid;</span><br><span class="line">    <span class="type">char</span>* waddr;</span><br><span class="line">    <span class="comment">// 1.获取键值 ftok</span></span><br><span class="line">    <span class="keyword">if</span> ((key = ftok(<span class="string">&quot;/home&quot;</span>, <span class="string">&#x27;g&#x27;</span>)) == <span class="number">-1</span>)</span><br><span class="line">        PRINT_ERR(<span class="string">&quot;ftok error&quot;</span>);</span><br><span class="line">    <span class="comment">// 2.创建共享内存 shmget</span></span><br><span class="line">    <span class="keyword">if</span> ((shmid = shmget(key, SHMSIZE, IPC_CREAT | <span class="number">0666</span>)) == <span class="number">-1</span>)</span><br><span class="line">        PRINT_ERR(<span class="string">&quot;shmget error&quot;</span>);</span><br><span class="line">    <span class="comment">// 3.将共享内存映射到用户空间 shmat</span></span><br><span class="line">    <span class="keyword">if</span> ((waddr = shmat(shmid, <span class="literal">NULL</span>, <span class="number">0</span>)) == (<span class="type">void</span>*)<span class="number">-1</span>)</span><br><span class="line">        PRINT_ERR(<span class="string">&quot;shmat error&quot;</span>);</span><br><span class="line">    <span class="comment">// 4.共享内存操作（写）</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;input &gt; &quot;</span>);</span><br><span class="line">        fgets(waddr, SHMSIZE, <span class="built_in">stdin</span>);</span><br><span class="line">        <span class="keyword">if</span> (waddr[<span class="built_in">strlen</span>(waddr) - <span class="number">1</span>] == <span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">            waddr[<span class="built_in">strlen</span>(waddr) - <span class="number">1</span>] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">strcmp</span>(waddr, <span class="string">&quot;quit&quot;</span>) == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 5.取消映射 shmdt</span></span><br><span class="line">    <span class="keyword">if</span>(shmdt(waddr))</span><br><span class="line">        PRINT_ERR(<span class="string">&quot;shmdt error&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>02read.c</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;head.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SHMSIZE (4096)</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span>* argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">key_t</span> key;</span><br><span class="line">    <span class="type">int</span> shmid;</span><br><span class="line">    <span class="type">char</span>* raddr;</span><br><span class="line">    <span class="comment">// 1.获取键值 ftok</span></span><br><span class="line">    <span class="keyword">if</span> ((key = ftok(<span class="string">&quot;/home&quot;</span>, <span class="string">&#x27;g&#x27;</span>)) == <span class="number">-1</span>)</span><br><span class="line">        PRINT_ERR(<span class="string">&quot;ftok error&quot;</span>);</span><br><span class="line">    <span class="comment">// 2.创建共享内存 shmget</span></span><br><span class="line">    <span class="keyword">if</span> ((shmid = shmget(key, SHMSIZE, IPC_CREAT | <span class="number">0666</span>)) == <span class="number">-1</span>)</span><br><span class="line">        PRINT_ERR(<span class="string">&quot;shmget error&quot;</span>);</span><br><span class="line">    <span class="comment">// 3.将共享内存映射到用户空间 shmat</span></span><br><span class="line">    <span class="keyword">if</span> ((raddr = shmat(shmid, <span class="literal">NULL</span>, <span class="number">0</span>)) == (<span class="type">void</span>*)<span class="number">-1</span>)</span><br><span class="line">        PRINT_ERR(<span class="string">&quot;shmat error&quot;</span>);</span><br><span class="line">    <span class="comment">// 4.从共享内存中数数据</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        getchar(); <span class="comment">// 敲回车读一次数据，如果不写这句话会疯狂刷屏</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;read:%s\n&quot;</span>, raddr);</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">strncmp</span>(raddr, <span class="string">&quot;quit&quot;</span>, <span class="number">4</span>) == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 5.取消映射 shmdt</span></span><br><span class="line">    <span class="keyword">if</span> (shmdt(raddr))</span><br><span class="line">        PRINT_ERR(<span class="string">&quot;shmdt error&quot;</span>);</span><br><span class="line">    <span class="comment">// 6.删除共享内存 shmctl</span></span><br><span class="line">    <span class="keyword">if</span> (shmctl(shmid, IPC_RMID, <span class="literal">NULL</span>))</span><br><span class="line">        PRINT_ERR(<span class="string">&quot;shmctl error&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="shmctl-函数详解"><a href="#shmctl-函数详解" class="headerlink" title="shmctl 函数详解"></a><code>shmctl</code> 函数详解</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">shmctl</span><span class="params">(<span class="type">int</span> shmid, <span class="type">int</span> cmd, <span class="keyword">struct</span> shmid_ds *buf)</span>;</span><br><span class="line"><span class="comment">// 功能：共享内存控制的函数</span></span><br><span class="line"><span class="comment">// 参数：</span></span><br><span class="line"><span class="comment">//     @shmid:共享内存的编号</span></span><br><span class="line"><span class="comment">//     @cmd:操作的命令码</span></span><br><span class="line"><span class="comment">//          IPC_STAT ：获取  (ipcs -m)</span></span><br><span class="line"><span class="comment">//          IPC_SET：设置</span></span><br><span class="line"><span class="comment">// 		 IPC_RMID：删除共享内存 （ipcrm -m shmid）</span></span><br><span class="line"><span class="comment">//         	标记要销毁的段。实际上，只有在最后一个进程将其分离之后</span></span><br><span class="line"><span class="comment">//         	(也就是说，关联结构shmid_ds的shm_nattch成员为零时)，</span></span><br><span class="line"><span class="comment">//         	段才会被销毁。调用者必须是段的所有者或创建者，或具有特权。buf参数被忽略。</span></span><br><span class="line"><span class="comment">// 	@buf:共享内存属性结构体指针</span></span><br><span class="line"><span class="comment">// 返回值:成功返回0，失败返回-1置位错误码</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// eg1:</span></span><br><span class="line">shmctl(shmid,IPC_RMID,<span class="literal">NULL</span>); <span class="comment">//删除共享内存 </span></span><br><span class="line"><span class="comment">// eg2：</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">shmid_ds</span> <span class="title">buf</span>;</span></span><br><span class="line">shmctl(shmid,IPC_STAT,&amp;buf); <span class="comment">//获取消息队列的属性</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//以下是shmid_ds结果的详解</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">shmid_ds</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ipc_perm</span> <span class="title">shm_perm</span>;</span> <span class="comment">//权限结构体</span></span><br><span class="line">    <span class="type">size_t</span> shm_segsz;		  <span class="comment">//共享内存的大小，单位是字节</span></span><br><span class="line">    <span class="type">__time_t</span> shm_atime;		  <span class="comment">//最后一次调用shmat的时间</span></span><br><span class="line">    <span class="type">__time_t</span> shm_dtime;		  <span class="comment">//最后一次调用shmdt的时间</span></span><br><span class="line">    <span class="type">__time_t</span> shm_ctime;		  <span class="comment">//最后一次调用shmctl改变属性的时间</span></span><br><span class="line">    <span class="type">__pid_t</span> shm_cpid;		  <span class="comment">//创建共享内存的PID</span></span><br><span class="line">    <span class="type">__pid_t</span> shm_lpid;		  <span class="comment">//最后一次操作共享内存的PID</span></span><br><span class="line">    <span class="type">shmatt_t</span> shm_nattch;	  <span class="comment">//当前多少个进程关联共享内存</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ipc_perm</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">__key_t</span> __key;			<span class="comment">//键值</span></span><br><span class="line">    <span class="type">__uid_t</span> uid;			<span class="comment">//消息队列所属的uid</span></span><br><span class="line">    <span class="type">__gid_t</span> gid;			<span class="comment">//消息队列所属的gid</span></span><br><span class="line">    <span class="type">__uid_t</span> cuid;			<span class="comment">//创建消息队列的uid</span></span><br><span class="line">    <span class="type">__gid_t</span> cgid;			<span class="comment">//创建消息队列的gid</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">short</span> <span class="type">int</span> mode;	<span class="comment">//消息队列的读写权限</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="信号灯集"><a href="#信号灯集" class="headerlink" title="信号灯集"></a>信号灯集</h2><h3 id="信号灯集工作原理"><a href="#信号灯集工作原理" class="headerlink" title="信号灯集工作原理"></a>信号灯集工作原理</h3><p>信号量（信号灯集）是实现 <strong>进程同步</strong> 的机制，在一个信号灯集中可以有很多个信号灯。在信号灯集内信号灯相互独立，每个灯的值的改变不会影响其他的信号灯，信号灯的值一般设置为二值量（ <code>1</code> 或者 <code>0</code> ，<code>1</code> 代表有资源，<code>0</code> 代表没有资源）。</p>
<h3 id="semget-semctl-semop"><a href="#semget-semctl-semop" class="headerlink" title="semget semctl semop"></a><code>semget</code> <code>semctl</code> <code>semop</code></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/sem.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">semget</span><span class="params">(<span class="type">key_t</span> key, <span class="type">int</span> nsems, <span class="type">int</span> semflg)</span>;</span><br><span class="line"><span class="comment">// 功能：创建一个信号灯集</span></span><br><span class="line"><span class="comment">// 参数：</span></span><br><span class="line"><span class="comment">//     @key:键值</span></span><br><span class="line"><span class="comment">//          IPC_PRIVATE </span></span><br><span class="line"><span class="comment">//          key</span></span><br><span class="line"><span class="comment">//     @nsems:信号灯集合中信号灯的个数</span></span><br><span class="line"><span class="comment">//     @semflag:创建的标志位</span></span><br><span class="line"><span class="comment">//         IPC_CREAT|0666  或  IPC_CREAT|IPC_EXCL|0666</span></span><br><span class="line"><span class="comment">// 返回值：成功返回semid,失败返回-1置位错误码</span></span><br><span class="line">             </span><br><span class="line"><span class="type">int</span> <span class="title function_">semctl</span><span class="params">(<span class="type">int</span> semid, <span class="type">int</span> semnum, <span class="type">int</span> cmd, ...)</span>;</span><br><span class="line"><span class="comment">// 功能：信号灯集的控制函数</span></span><br><span class="line"><span class="comment">// 参数：</span></span><br><span class="line"><span class="comment">//     @semid信号灯集的ID</span></span><br><span class="line"><span class="comment">//     @senum:信号灯的编号</span></span><br><span class="line"><span class="comment">//     @cmd:命令码</span></span><br><span class="line"><span class="comment">//         SETVAL：设置信号灯的值 ---&gt;第四个参数val选项</span></span><br><span class="line"><span class="comment">//         GETVAL：获取信号灯的值 ---&gt;不需要第四个参数</span></span><br><span class="line"><span class="comment">// 		IPC_STAT：获取信号灯集的属性---&gt;第二个参数被忽略，第四个参数buf选项</span></span><br><span class="line"><span class="comment">//         IPC_SET ：设置信号灯集的属性---&gt;第四个参数buf选项</span></span><br><span class="line"><span class="comment">// 		IPC_RMID:第二参数被忽略，第4个参数不用填写</span></span><br><span class="line"><span class="comment">// 	@...:</span></span><br><span class="line"><span class="comment">// 		  union semun &#123;</span></span><br><span class="line"><span class="comment">//                int              val;    /* Value for SETVAL */</span></span><br><span class="line"><span class="comment">//                struct semid_ds *buf;    /* Buffer for IPC_STAT, IPC_SET */</span></span><br><span class="line"><span class="comment">//            &#125;;</span></span><br><span class="line"><span class="comment">// 返回值：失败返回-1置位错误码</span></span><br><span class="line"><span class="comment">//     	成功：</span></span><br><span class="line"><span class="comment">//     		GETVAL:成功返回信号灯的值</span></span><br><span class="line"><span class="comment">//             其余的命令码成功返回0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// eg:设置灯的值</span></span><br><span class="line"><span class="class"><span class="keyword">union</span> <span class="title">semun</span> <span class="title">sem</span> =</span> &#123;</span><br><span class="line">	.val = <span class="number">1</span>,</span><br><span class="line">&#125;</span><br><span class="line">semctl(semid,<span class="number">0</span>,SETVAL,sem); <span class="comment">//将0号灯初始值设置为1</span></span><br><span class="line"><span class="class"><span class="keyword">union</span> <span class="title">semun</span> <span class="title">sem</span> =</span> &#123;</span><br><span class="line">	.val = <span class="number">0</span>,</span><br><span class="line">&#125;</span><br><span class="line">semctl(semid,<span class="number">1</span>,SETVAL,sem); <span class="comment">//将1号灯初始值设置为0</span></span><br><span class="line"><span class="comment">// eg:获取信号灯的值</span></span><br><span class="line">val = semctl(semid,<span class="number">0</span>,GETVAL); <span class="comment">//获取0号灯的值</span></span><br><span class="line"><span class="comment">// eg:获取信号灯集的属性</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">semid_ds</span> <span class="title">buf</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">union</span> <span class="title">semun</span> <span class="title">sem</span> =</span> &#123;</span><br><span class="line">  	.buf = &amp;buf,</span><br><span class="line">&#125;</span><br><span class="line">semctl(semid,<span class="number">0</span>，IPC_STAT,sem); <span class="comment">//获取信号灯集的属性，第二参数被忽略</span></span><br><span class="line"><span class="comment">// eg:删除信号等集</span></span><br><span class="line">semctl(semid,<span class="number">0</span>,IPC_RMID); <span class="comment">//删除信号等集</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">semop</span><span class="params">(<span class="type">int</span> semid, <span class="keyword">struct</span> sembuf *sops, <span class="type">size_t</span> nsops)</span>;</span><br><span class="line"><span class="comment">// 功能：信号灯集中信号灯的操作函数</span></span><br><span class="line"><span class="comment">// 参数：</span></span><br><span class="line"><span class="comment">//     @semid:信号灯集的编号</span></span><br><span class="line"><span class="comment">//     @sops:操作方式</span></span><br><span class="line"><span class="comment">//         struct sembuf&#123;</span></span><br><span class="line"><span class="comment">//            unsigned short sem_num;  //信号灯的编号</span></span><br><span class="line"><span class="comment">//            short sem_op;   //操作方式（PV）</span></span><br><span class="line"><span class="comment">//             					-1:P操作，申请资源</span></span><br><span class="line"><span class="comment">//                              1:V操作，释放资源</span></span><br><span class="line"><span class="comment">//            short sem_flg;  //操作的标志位</span></span><br><span class="line"><span class="comment">//             				    0：阻塞</span></span><br><span class="line"><span class="comment">//                              IPC_NOWAIT：非阻塞方式操作</span></span><br><span class="line"><span class="comment">//         &#125;</span></span><br><span class="line"><span class="comment">// 	   @nsops:本次操作信号灯的个数</span></span><br><span class="line"><span class="comment">// 返回值：成功返回0，失败返回-1置位错误码</span></span><br></pre></td></tr></table></figure>
<p>01write.c</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;head.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SHMSIZE (4096)</span></span><br><span class="line"><span class="class"><span class="keyword">union</span> <span class="title">semun</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> val; <span class="comment">/* Value for SETVAL */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">semid_ds</span>* <span class="title">buf</span>;</span> <span class="comment">/* Buffer for IPC_STAT, IPC_SET */</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">int</span> <span class="title function_">mysem_init</span><span class="params">(<span class="type">int</span> semid, <span class="type">int</span> which, <span class="type">int</span> value)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">union</span> <span class="title">semun</span> <span class="title">sem</span> =</span> &#123;</span><br><span class="line">        .val = value,</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">if</span> (semctl(semid, which, SETVAL, sem) == <span class="number">-1</span>)</span><br><span class="line">        PRINT_ERR(<span class="string">&quot;semctl error&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">P</span><span class="params">(<span class="type">int</span> semid, <span class="type">int</span> which)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sembuf</span> <span class="title">op</span> =</span> &#123;</span><br><span class="line">        .sem_num = which, <span class="comment">// 那个灯</span></span><br><span class="line">        .sem_op = <span class="number">-1</span>, <span class="comment">// -1 P申请   1 V释放</span></span><br><span class="line">        .sem_flg = <span class="number">0</span>, <span class="comment">// 阻塞</span></span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">if</span> (semop(semid, &amp;op, <span class="number">1</span>))</span><br><span class="line">        PRINT_ERR(<span class="string">&quot;semop P error&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">V</span><span class="params">(<span class="type">int</span> semid, <span class="type">int</span> which)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sembuf</span> <span class="title">op</span> =</span> &#123;</span><br><span class="line">        .sem_num = which, <span class="comment">// 那个灯</span></span><br><span class="line">        .sem_op = <span class="number">1</span>, <span class="comment">// -1 P申请   1 V释放</span></span><br><span class="line">        .sem_flg = <span class="number">0</span>, <span class="comment">// 阻塞</span></span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">if</span> (semop(semid, &amp;op, <span class="number">1</span>))</span><br><span class="line">        PRINT_ERR(<span class="string">&quot;semop V error&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span>* argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">key_t</span> key;</span><br><span class="line">    <span class="type">int</span> shmid, semid;</span><br><span class="line">    <span class="type">char</span>* waddr;</span><br><span class="line">    <span class="comment">// 1.获取键值 ftok</span></span><br><span class="line">    <span class="keyword">if</span> ((key = ftok(<span class="string">&quot;/home&quot;</span>, <span class="string">&#x27;g&#x27;</span>)) == <span class="number">-1</span>)</span><br><span class="line">        PRINT_ERR(<span class="string">&quot;ftok error&quot;</span>);</span><br><span class="line">    <span class="comment">// 2.创建共享内存 shmget</span></span><br><span class="line">    <span class="keyword">if</span> ((shmid = shmget(key, SHMSIZE, IPC_CREAT | <span class="number">0666</span>)) == <span class="number">-1</span>)</span><br><span class="line">        PRINT_ERR(<span class="string">&quot;shmget error&quot;</span>);</span><br><span class="line">    <span class="comment">// 3.将共享内存映射到用户空间 shmat</span></span><br><span class="line">    <span class="keyword">if</span> ((waddr = shmat(shmid, <span class="literal">NULL</span>, <span class="number">0</span>)) == (<span class="type">void</span>*)<span class="number">-1</span>)</span><br><span class="line">        PRINT_ERR(<span class="string">&quot;shmat error&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4.创建信号灯集，并初始化信号灯</span></span><br><span class="line">    <span class="keyword">if</span> ((semid = semget(key, <span class="number">2</span>, IPC_CREAT | IPC_EXCL | <span class="number">0666</span>)) == <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (errno = EEXIST) &#123;</span><br><span class="line">            semid = semget(key, <span class="number">2</span>, IPC_CREAT|<span class="number">0666</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            PRINT_ERR(<span class="string">&quot;semget error&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        mysem_init(semid, <span class="number">0</span>, <span class="number">1</span>); <span class="comment">// 将0号灯设置为1</span></span><br><span class="line">        mysem_init(semid, <span class="number">1</span>, <span class="number">0</span>); <span class="comment">// 将1号灯设置为0</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 5.共享内存操作（写）</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        P(semid, <span class="number">0</span>); <span class="comment">// 申请0号灯资源</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;input &gt; &quot;</span>);</span><br><span class="line">        fgets(waddr, SHMSIZE, <span class="built_in">stdin</span>);</span><br><span class="line">        <span class="keyword">if</span> (waddr[<span class="built_in">strlen</span>(waddr) - <span class="number">1</span>] == <span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">            waddr[<span class="built_in">strlen</span>(waddr) - <span class="number">1</span>] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">        V(semid, <span class="number">1</span>); <span class="comment">// 释放1号灯资源</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">strcmp</span>(waddr, <span class="string">&quot;quit&quot;</span>) == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 6.取消映射 shmdt</span></span><br><span class="line">    <span class="keyword">if</span> (shmdt(waddr))</span><br><span class="line">        PRINT_ERR(<span class="string">&quot;shmdt error&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>02read.c</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;head.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SHMSIZE (4096)</span></span><br><span class="line"><span class="class"><span class="keyword">union</span> <span class="title">semun</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> val; <span class="comment">/* Value for SETVAL */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">semid_ds</span>* <span class="title">buf</span>;</span> <span class="comment">/* Buffer for IPC_STAT, IPC_SET */</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">int</span> <span class="title function_">mysem_init</span><span class="params">(<span class="type">int</span> semid, <span class="type">int</span> which, <span class="type">int</span> value)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">union</span> <span class="title">semun</span> <span class="title">sem</span> =</span> &#123;</span><br><span class="line">        .val = value,</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">if</span> (semctl(semid, which, SETVAL, sem) == <span class="number">-1</span>)</span><br><span class="line">        PRINT_ERR(<span class="string">&quot;semctl error&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">P</span><span class="params">(<span class="type">int</span> semid, <span class="type">int</span> which)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sembuf</span> <span class="title">op</span> =</span> &#123;</span><br><span class="line">        .sem_num = which, <span class="comment">// 那个灯</span></span><br><span class="line">        .sem_op = <span class="number">-1</span>, <span class="comment">// -1 P申请   1 V释放</span></span><br><span class="line">        .sem_flg = <span class="number">0</span>, <span class="comment">// 阻塞</span></span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">if</span> (semop(semid, &amp;op, <span class="number">1</span>))</span><br><span class="line">        PRINT_ERR(<span class="string">&quot;semop P error&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">V</span><span class="params">(<span class="type">int</span> semid, <span class="type">int</span> which)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sembuf</span> <span class="title">op</span> =</span> &#123;</span><br><span class="line">        .sem_num = which, <span class="comment">// 那个灯</span></span><br><span class="line">        .sem_op = <span class="number">1</span>, <span class="comment">// -1 P申请   1 V释放</span></span><br><span class="line">        .sem_flg = <span class="number">0</span>, <span class="comment">// 阻塞</span></span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">if</span> (semop(semid, &amp;op, <span class="number">1</span>))</span><br><span class="line">        PRINT_ERR(<span class="string">&quot;semop V error&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span>* argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">key_t</span> key;</span><br><span class="line">    <span class="type">int</span> shmid, semid;</span><br><span class="line">    <span class="type">char</span>* raddr;</span><br><span class="line">    <span class="comment">// 1.获取键值 ftok</span></span><br><span class="line">    <span class="keyword">if</span> ((key = ftok(<span class="string">&quot;/home&quot;</span>, <span class="string">&#x27;g&#x27;</span>)) == <span class="number">-1</span>)</span><br><span class="line">        PRINT_ERR(<span class="string">&quot;ftok error&quot;</span>);</span><br><span class="line">    <span class="comment">// 2.创建共享内存 shmget</span></span><br><span class="line">    <span class="keyword">if</span> ((shmid = shmget(key, SHMSIZE, IPC_CREAT | <span class="number">0666</span>)) == <span class="number">-1</span>)</span><br><span class="line">        PRINT_ERR(<span class="string">&quot;shmget error&quot;</span>);</span><br><span class="line">    <span class="comment">// 3.将共享内存映射到用户空间 shmat</span></span><br><span class="line">    <span class="keyword">if</span> ((raddr = shmat(shmid, <span class="literal">NULL</span>, <span class="number">0</span>)) == (<span class="type">void</span>*)<span class="number">-1</span>)</span><br><span class="line">        PRINT_ERR(<span class="string">&quot;shmat error&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4.创建信号灯集，并初始化信号灯</span></span><br><span class="line">    <span class="keyword">if</span> ((semid = semget(key, <span class="number">2</span>, IPC_CREAT | IPC_EXCL | <span class="number">0666</span>)) == <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (errno = EEXIST) &#123;</span><br><span class="line">            semid = semget(key, <span class="number">2</span>, IPC_CREAT | <span class="number">0666</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            PRINT_ERR(<span class="string">&quot;semget error&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        mysem_init(semid, <span class="number">0</span>, <span class="number">1</span>); <span class="comment">// 将0号灯设置为1</span></span><br><span class="line">        mysem_init(semid, <span class="number">1</span>, <span class="number">0</span>); <span class="comment">// 将1号灯设置为0</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 5.从共享内存中数数据</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        P(semid, <span class="number">1</span>); <span class="comment">// 申请1号灯资源</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;read:%s\n&quot;</span>, raddr);</span><br><span class="line">        V(semid, <span class="number">0</span>); <span class="comment">// 释放0号灯资源</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">strncmp</span>(raddr, <span class="string">&quot;quit&quot;</span>, <span class="number">4</span>) == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 6.取消映射 shmdt</span></span><br><span class="line">    <span class="keyword">if</span> (shmdt(raddr))</span><br><span class="line">        PRINT_ERR(<span class="string">&quot;shmdt error&quot;</span>);</span><br><span class="line">    <span class="comment">// 7.删除共享内存 shmctl</span></span><br><span class="line">    <span class="keyword">if</span> (shmctl(shmid, IPC_RMID, <span class="literal">NULL</span>))</span><br><span class="line">        PRINT_ERR(<span class="string">&quot;shmctl error&quot;</span>);</span><br><span class="line">    <span class="comment">// 8.删除信号灯集</span></span><br><span class="line">    <span class="keyword">if</span> (semctl(semid, <span class="number">0</span>, IPC_RMID))</span><br><span class="line">        PRINT_ERR(<span class="string">&quot;semctl error&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h1 id="守护进程"><a href="#守护进程" class="headerlink" title="守护进程"></a>守护进程</h1><p>守护进程是后台运行的进程，它会随着系统的启动而启动，会随着系统的终止而终止，类似于 windows 上的各种服务。<br>例如 windows 上的网络管理的服务，ubuntu 上的 <code>sshd</code> 的服务，ubuntu 上的 <strong>资源管理</strong> 的进程</p>
<h2 id="守护进程创建的流程"><a href="#守护进程创建的流程" class="headerlink" title="守护进程创建的流程"></a>守护进程创建的流程</h2><ol>
<li><p>创建孤儿进程</p>
</li>
<li><p>设置孤儿进程的会话id和组id</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">pid_t</span> <span class="title function_">setsid</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="comment">// 功能：设置会话id</span></span><br><span class="line"><span class="comment">// 参数：</span></span><br><span class="line"><span class="comment">//     @无</span></span><br><span class="line"><span class="comment">// 返回值：成功返回新的会话id，失败返回-1，置位错误码</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>切换目录到&#x2F;var&#x2F;log目录下</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">chdir</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *path)</span>;</span><br><span class="line"><span class="comment">// 功能：切换目录</span></span><br><span class="line"><span class="comment">// 参数：</span></span><br><span class="line"><span class="comment">//     @path:路径</span></span><br><span class="line"><span class="comment">// 返回值：成功返回0，失败返回-1置位错误码</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>设置umask的值0</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">mode_t</span> <span class="title function_">umask</span><span class="params">(<span class="type">mode_t</span> mask)</span>;</span><br><span class="line"><span class="comment">// 功能：设置文件的掩码</span></span><br><span class="line"><span class="comment">// 参数：</span></span><br><span class="line"><span class="comment">//     @mask:掩码值</span></span><br><span class="line"><span class="comment">// 返回值：返回设置前的掩码值，总是会成功</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>创建日志文件</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> fd;</span><br><span class="line"><span class="keyword">if</span>((fd = open(<span class="string">&quot;./daemon.log&quot;</span>,O_RDWR|O_CREAT|O_APPEND,<span class="number">0666</span>))==<span class="number">-1</span>)</span><br><span class="line">    PRINT_ERR(<span class="string">&quot;open error&quot;</span>);</span><br></pre></td></tr></table></figure>
</li>
<li><p>文件描述符重定向工作</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dup2(fd,<span class="number">0</span>);</span><br><span class="line">dup2(fd,<span class="number">1</span>);</span><br><span class="line">dup2(fd,<span class="number">2</span>);</span><br></pre></td></tr></table></figure>
</li>
<li><p>开启自己的服务</p>
</li>
</ol>
<h2 id="文件描述符重定向"><a href="#文件描述符重定向" class="headerlink" title="文件描述符重定向"></a>文件描述符重定向</h2><h3 id="dup-dup2-函数"><a href="#dup-dup2-函数" class="headerlink" title="dup dup2 函数"></a><code>dup</code> <code>dup2</code> 函数</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">dup</span><span class="params">(<span class="type">int</span> oldfd)</span>;</span><br><span class="line"><span class="comment">// 功能：将使用oldfd生成newfd,newfd采用文件描述符最小未使用的原则分配的。</span></span><br><span class="line"><span class="comment">//     oldfd和newfd都能操作文件，两者共用光标。</span></span><br><span class="line"><span class="comment">// 参数：</span></span><br><span class="line"><span class="comment">//     @oldfd:旧的文件描述符</span></span><br><span class="line"><span class="comment">// 返回值：成功返回新的文件描述符，失败返回-1置位错误码</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">dup2</span><span class="params">(<span class="type">int</span> oldfd, <span class="type">int</span> newfd)</span>;</span><br><span class="line"><span class="comment">// 功能：将oldfd重定向到newfd中，newfd是用户自己指定的，如果newfd</span></span><br><span class="line"><span class="comment">//     之前被分配过在使用前会关闭它们。</span></span><br><span class="line"><span class="comment">// 参数：</span></span><br><span class="line"><span class="comment">//     @oldfd:旧的文件描述符</span></span><br><span class="line"><span class="comment">//     @newfd:新的文件描述符</span></span><br><span class="line"><span class="comment">// 返回值：成功返回新的文件描述符，失败返回-1置位错误码</span></span><br></pre></td></tr></table></figure>
<p><code>dup</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;head.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span>* argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> fd;</span><br><span class="line">    <span class="keyword">if</span> ((fd = open(<span class="string">&quot;./daemon.log&quot;</span>, O_RDWR | O_CREAT | O_APPEND, <span class="number">0666</span>)) == <span class="number">-1</span>)</span><br><span class="line">        PRINT_ERR(<span class="string">&quot;open error&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//关闭标准输入，标准输出，标准出错</span></span><br><span class="line">    close(<span class="number">0</span>);</span><br><span class="line">    close(<span class="number">1</span>);</span><br><span class="line">    close(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//将0,1,2重定向到文件fd中</span></span><br><span class="line">    dup(fd);</span><br><span class="line">    dup(fd);</span><br><span class="line">    dup(fd);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;hello daemon dup process...\n&quot;</span>);</span><br><span class="line">    fflush(<span class="built_in">stdout</span>);</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>,<span class="string">&quot;this is test daemon dup stderr...\n&quot;</span>);</span><br><span class="line">    lseek(fd,<span class="number">0</span>,SEEK_SET);</span><br><span class="line">    <span class="type">char</span> ch;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%c&quot;</span>,&amp;ch);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;ch = %c\n&quot;</span>,ch);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>dup2</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;head.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span>* argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> fd;</span><br><span class="line">    <span class="keyword">if</span> ((fd = open(<span class="string">&quot;./daemon.log&quot;</span>, O_RDWR | O_CREAT | O_APPEND, <span class="number">0666</span>)) == <span class="number">-1</span>)</span><br><span class="line">        PRINT_ERR(<span class="string">&quot;open error&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    dup2(fd,<span class="number">0</span>);</span><br><span class="line">    dup2(fd,<span class="number">1</span>);</span><br><span class="line">    dup2(fd,<span class="number">2</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;hello daemon dup process...\n&quot;</span>);</span><br><span class="line">    fflush(<span class="built_in">stdout</span>);</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>,<span class="string">&quot;this is test daemon dup stderr...\n&quot;</span>);</span><br><span class="line">    lseek(fd,<span class="number">0</span>,SEEK_SET);</span><br><span class="line">    <span class="type">char</span> ch;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%c&quot;</span>,&amp;ch);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;ch = %c\n&quot;</span>,ch);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="守护进程创建的实例"><a href="#守护进程创建的实例" class="headerlink" title="守护进程创建的实例"></a>守护进程创建的实例</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;head.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span>* argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">pid_t</span> pid;</span><br><span class="line">    <span class="type">int</span> fd;</span><br><span class="line">    <span class="keyword">if</span> ((pid = fork()) == <span class="number">-1</span>) &#123;</span><br><span class="line">        PRINT_ERR(<span class="string">&quot;fork error&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (pid == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 1.孤儿进程</span></span><br><span class="line">        <span class="comment">// 2.设置会话id</span></span><br><span class="line">        <span class="keyword">if</span>(setsid()==<span class="number">-1</span>)</span><br><span class="line">            PRINT_ERR(<span class="string">&quot;setsid error&quot;</span>);</span><br><span class="line">        <span class="comment">// 3.切换目录(/var/log/)</span></span><br><span class="line">        <span class="keyword">if</span> (chdir(<span class="string">&quot;/&quot;</span>))</span><br><span class="line">            PRINT_ERR(<span class="string">&quot;chdir error&quot;</span>);</span><br><span class="line">        <span class="comment">// 4.修改掩码</span></span><br><span class="line">        umask(<span class="number">0</span>);</span><br><span class="line">        <span class="comment">// 5.创建日志文件</span></span><br><span class="line">        <span class="keyword">if</span> ((fd = open(<span class="string">&quot;./daemon.log&quot;</span>, O_RDWR | O_CREAT | O_APPEND, <span class="number">0666</span>)) == <span class="number">-1</span>)</span><br><span class="line">            PRINT_ERR(<span class="string">&quot;open error&quot;</span>);</span><br><span class="line">        <span class="comment">// 6.文件描述符重定向</span></span><br><span class="line">        dup2(fd,<span class="number">0</span>);</span><br><span class="line">        dup2(fd,<span class="number">1</span>);</span><br><span class="line">        dup2(fd,<span class="number">2</span>);</span><br><span class="line">        <span class="comment">// 7.开启自己的服务</span></span><br><span class="line">        <span class="type">char</span> s[] = <span class="string">&quot;i am test daemon process\n&quot;</span>;</span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">            write(<span class="number">1</span>,s,<span class="built_in">strlen</span>(s));</span><br><span class="line">            sleep(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 让父进程退出</span></span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h1 id="进程内程序替换函数"><a href="#进程内程序替换函数" class="headerlink" title="进程内程序替换函数"></a>进程内程序替换函数</h1><p>终端执行 <code>a.out</code> 程序, 首先会执行fork产生一个子进程，当产生子进程之后，子进程的 <code>.text</code>段存放的是终端的可执行程序，需要将这个段内的内容替换成 <code>a.out</code> 。此时就可以执行 <code>a.out</code> 应用程序了，以上的功能可以通过 <code>system</code> 完成。 </p>
<h2 id="system-函数"><a href="#system-函数" class="headerlink" title="system 函数"></a><code>system</code> 函数</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">system</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *command)</span>;</span><br><span class="line"><span class="comment">// 功能：首先会fork一个子进程，在子进程内执行command这个可执行程序</span></span><br><span class="line"><span class="comment">// 参数：</span></span><br><span class="line"><span class="comment">//     @command:可执行程序的路径及名字</span></span><br><span class="line"><span class="comment">// 返回值：</span></span><br><span class="line"><span class="comment">//    *如果command为NULL，如果终端可用返回非0，如果终端不可用返回0</span></span><br><span class="line"><span class="comment">//    *如果无法创建子进程，或者无法检索其状态，则返回值为-1。</span></span><br><span class="line"><span class="comment">//    *如果命令不能在子进程中执行，返回退出状态（效果和exit(status)一样的）</span></span><br><span class="line"><span class="comment">//    *如果所有系统调用都成功，则返回值是用于执行命令的子shell的终止状态。</span></span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;head.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span>* argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 首先会创建一个子进程，在子进程内执行&quot;/bin/ls&quot;可执行程序</span></span><br><span class="line">    <span class="comment">//  if(system(&quot;/bin/ls -l&quot;))</span></span><br><span class="line">    <span class="comment">//      PRINT_ERR(&quot;system error&quot;);</span></span><br><span class="line">	</span><br><span class="line">    <span class="comment">// if(system(&quot;./b.out&quot;))</span></span><br><span class="line">    <span class="comment">//     PRINT_ERR(&quot;system error&quot;);</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (system(<span class="string">&quot;./myshell.sh 111 222 333 4444 555&quot;</span>))</span><br><span class="line">        PRINT_ERR(<span class="string">&quot;system error&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="函数接口"><a href="#函数接口" class="headerlink" title="函数接口"></a>函数接口</h1><p><code>fopen</code> <code>fclose</code> <code>fgetc</code> <code>fputc</code> <code>fgets</code> <code>fputs</code> <code>fread</code> <code>fwrite</code> <code>fseek</code> <code>ftell</code> <code>rewind</code><br><code>perror</code> <code>strerror</code> <code>snprintf</code> <code>sprintf</code> <code>fprintf</code> <code>time</code> <code>localtime</code><br><code>open</code> <code>read</code> <code>write</code> <code>close</code> <code>lseek</code> <code>stat</code> <code>lstat</code> <code>getpwuid</code> <code>getgrgid</code><br><code>opendir</code> <code>readdir</code> <code>closedir</code><br><code>fork</code> <code>getpid</code> <code>getppid</code> <code>exit</code> <code>_exit</code> <code>wait</code> <code>waitpid</code> <code>dup</code> <code>dup2</code> <code>system</code><br><code>pthread_create</code> <code>pthread_self</code> <code>pthread_exit</code> <code>pthread_join</code> <code>pthread_detach</code> <code>pthread_cancel</code><br><code>pthread_mutex_init</code> <code>pthread_mutex_lock</code> <code>pthread_mutex_unlock</code> <code>pthread_mutex_destroy</code><br><code>sem_init</code> <code>sem_wait</code> <code>sem_post</code> <code>sem_destroy</code><br><code>pthread_cond_init</code> <code>pthread_cond_wait</code> <code>pthread_cond_signal</code><br><code>pthread_cond_broatcast</code> <code>pthread_cond_destroy</code><br><code>pipe</code> <code>mkfifo</code> <code>signal</code> <code>kill</code> <code>raise</code> <code>alarm</code><br><code>ftok</code> <code>msgget</code> <code>msgsnd</code> <code>msgrcv</code> <code>msgctl</code><br><code>shmget</code> <code>shmat</code> <code>shmdt</code> <code>shmctl</code><br><code>semget</code> <code>semctl</code> <code>semop</code></p>

    </div>

    
    
    

      <footer class="post-footer">

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2022/07/10/sys_select%E5%86%85%E9%83%A8%E5%AE%9E%E7%8E%B0/" rel="prev" title="sys_select 剖析">
      <i class="fa fa-chevron-left"></i> sys_select 剖析
    </a></div>
      <div class="post-nav-item">
    <a href="/2022/10/10/%E7%BA%BF%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1/" rel="next" title="线程以及线程间的竞态问题解决">
      线程以及线程间的竞态问题解决 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B"><span class="nav-number">1.</span> <span class="nav-text">进程</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B%E7%9A%84%E6%A6%82%E5%BF%B5"><span class="nav-number">1.1.</span> <span class="nav-text">进程的概念</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%A8%8B%E5%BA%8F%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">1.1.1.</span> <span class="nav-text">进程和程序的区别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B%E7%9A%84%E7%BB%84%E6%88%90"><span class="nav-number">1.1.2.</span> <span class="nav-text">进程的组成</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B%E7%9A%84%E7%A7%8D%E7%B1%BB"><span class="nav-number">1.1.3.</span> <span class="nav-text">进程的种类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#PID"><span class="nav-number">1.1.4.</span> <span class="nav-text">PID</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%89%B9%E6%AE%8APID%E7%9A%84%E8%BF%9B%E7%A8%8B"><span class="nav-number">1.1.5.</span> <span class="nav-text">特殊PID的进程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B%E7%9B%B8%E5%85%B3%E5%91%BD%E4%BB%A4"><span class="nav-number">1.1.6.</span> <span class="nav-text">进程相关命令</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B%E7%9A%84%E7%8A%B6%E6%80%81"><span class="nav-number">1.1.7.</span> <span class="nav-text">进程的状态</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B%E7%8A%B6%E6%80%81%E5%88%87%E6%8D%A2%E5%AE%9E%E4%BE%8B"><span class="nav-number">1.1.8.</span> <span class="nav-text">进程状态切换实例</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%88%9B%E5%BB%BA%E5%8F%8A%E7%89%B9%E7%82%B9"><span class="nav-number">1.2.</span> <span class="nav-text">进程的创建及特点</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E5%88%9B%E5%BB%BA%E8%BF%9B%E8%A1%8C"><span class="nav-number">1.2.1.</span> <span class="nav-text">如何创建进行</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%9B%E5%BB%BA%E8%BF%9B%E7%A8%8B%E7%9A%84API"><span class="nav-number">1.2.2.</span> <span class="nav-text">创建进程的API</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%9B%E5%BB%BA%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%AE%9E%E4%BE%8B"><span class="nav-number">1.2.3.</span> <span class="nav-text">创建进程的实例</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%9B%E5%BB%BA%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%AE%9E%E4%BE%8B-1"><span class="nav-number">1.2.4.</span> <span class="nav-text">创建进程的实例</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#fork-%E5%92%8C-%E7%BC%93%E5%86%B2%E5%8C%BA-%E7%BB%93%E5%90%88%E9%97%AE%E9%A2%98"><span class="nav-number">1.2.5.</span> <span class="nav-text">fork 和 缓冲区 结合问题</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%85%B3%E6%B3%A8-fork-%E8%BF%94%E5%9B%9E%E5%80%BC"><span class="nav-number">1.2.6.</span> <span class="nav-text">关注 fork 返回值</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%88%B6%E5%AD%90%E8%BF%9B%E7%A8%8B%E6%89%A7%E8%A1%8C%E5%85%88%E5%90%8E%E9%A1%BA%E5%BA%8F"><span class="nav-number">1.2.7.</span> <span class="nav-text">父子进程执行先后顺序</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%88%B6%E5%AD%90%E8%BF%9B%E7%A8%8B%E5%86%85%E5%AD%98%E7%A9%BA%E9%97%B4%E9%97%AE%E9%A2%98"><span class="nav-number">1.2.8.</span> <span class="nav-text">父子进程内存空间问题</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A4%9A%E8%BF%9B%E7%A8%8B%E7%BB%83%E4%B9%A0"><span class="nav-number">1.2.9.</span> <span class="nav-text">多进程练习</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B%E7%9B%B8%E5%85%B3%E7%9A%84API%E6%8E%A5%E5%8F%A3"><span class="nav-number">1.3.</span> <span class="nav-text">进程相关的API接口</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#getpid-getppid-%E5%87%BD%E6%95%B0"><span class="nav-number">1.3.1.</span> <span class="nav-text">getpid getppid 函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#exit-exit-%E5%87%BD%E6%95%B0"><span class="nav-number">1.3.2.</span> <span class="nav-text">exit _exit 函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#wait-waitpid-%E5%87%BD%E6%95%B0"><span class="nav-number">1.3.3.</span> <span class="nav-text">wait waitpid 函数</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B%E9%97%B4%E7%9A%84%E9%80%9A%E4%BF%A1"><span class="nav-number">2.</span> <span class="nav-text">进程间的通信</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1%E6%96%B9%E5%BC%8F%E7%AE%80%E4%BB%8B"><span class="nav-number">2.1.</span> <span class="nav-text">进程间通信方式简介</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%97%A0%E5%90%8D%E7%AE%A1%E9%81%93"><span class="nav-number">2.2.</span> <span class="nav-text">无名管道</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%97%A0%E5%90%8D%E7%AE%A1%E9%81%93%E9%80%9A%E4%BF%A1%E5%8E%9F%E7%90%86"><span class="nav-number">2.2.1.</span> <span class="nav-text">无名管道通信原理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%97%A0%E5%90%8D%E7%AE%A1%E9%81%93%E7%9A%84API"><span class="nav-number">2.2.2.</span> <span class="nav-text">无名管道的API</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%97%A0%E5%90%8D%E7%AE%A1%E9%81%93%E9%80%9A%E4%BF%A1%E7%89%B9%E7%82%B9"><span class="nav-number">2.2.3.</span> <span class="nav-text">无名管道通信特点</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9C%89%E5%90%8D%E7%AE%A1%E9%81%93"><span class="nav-number">2.3.</span> <span class="nav-text">有名管道</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9C%89%E5%90%8D%E7%AE%A1%E9%81%93%E9%80%9A%E4%BF%A1%E5%8E%9F%E7%90%86"><span class="nav-number">2.3.1.</span> <span class="nav-text">有名管道通信原理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9C%89%E5%90%8D%E7%AE%A1%E9%81%93%E7%9A%84API"><span class="nav-number">2.3.2.</span> <span class="nav-text">有名管道的API</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9C%89%E5%90%8D%E7%AE%A1%E9%81%93%E7%9A%84%E7%BB%83%E4%B9%A0"><span class="nav-number">2.3.3.</span> <span class="nav-text">有名管道的练习</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9C%89%E5%90%8D%E7%AE%A1%E9%81%93%E8%AF%BB%E5%86%99%E7%9A%84%E7%89%B9%E7%82%B9"><span class="nav-number">2.3.4.</span> <span class="nav-text">有名管道读写的特点</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BF%A1%E5%8F%B7"><span class="nav-number">2.4.</span> <span class="nav-text">信号</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BF%A1%E5%8F%B7%E7%AE%80%E4%BB%8B"><span class="nav-number">2.4.1.</span> <span class="nav-text">信号简介</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8F%91%E4%BF%A1%E5%8F%B7%E7%9A%84%E5%91%BD%E4%BB%A4"><span class="nav-number">2.4.2.</span> <span class="nav-text">发信号的命令</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BF%A1%E5%8F%B7%E7%9A%84%E6%9F%A5%E7%9C%8B%E6%96%B9%E5%BC%8F"><span class="nav-number">2.4.3.</span> <span class="nav-text">信号的查看方式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B8%B8%E7%94%A8%E7%9A%84%E4%BF%A1%E5%8F%B7"><span class="nav-number">2.4.4.</span> <span class="nav-text">常用的信号</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#signal-%E5%87%BD%E6%95%B0"><span class="nav-number">2.4.5.</span> <span class="nav-text">signal 函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BB%83%E4%B9%A0"><span class="nav-number">2.4.6.</span> <span class="nav-text">练习</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8F%91%E4%BF%A1%E5%8F%B7%E7%9B%B8%E5%85%B3%E5%87%BD%E6%95%B0"><span class="nav-number">2.4.7.</span> <span class="nav-text">发信号相关函数</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#IPC%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1%E7%9B%B8%E5%85%B3%E5%91%BD%E4%BB%A4"><span class="nav-number">2.5.</span> <span class="nav-text">IPC进程间通信相关命令</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#IPC%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1%E9%94%AE%E5%80%BC%E8%8E%B7%E5%8F%96%E5%8F%8A%E7%BB%84%E6%88%90"><span class="nav-number">2.6.</span> <span class="nav-text">IPC进程间通信键值获取及组成</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97"><span class="nav-number">2.7.</span> <span class="nav-text">消息队列</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E9%80%9A%E4%BF%A1%E5%8E%9F%E7%90%86"><span class="nav-number">2.7.1.</span> <span class="nav-text">消息队列通信原理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#msgget-msgsnd-msgrcv-msgctl"><span class="nav-number">2.7.2.</span> <span class="nav-text">msgget msgsnd msgrcv msgctl</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#msgctl-%E5%87%BD%E6%95%B0%E8%AF%A6%E8%A7%A3"><span class="nav-number">2.7.3.</span> <span class="nav-text">msgctl 函数详解</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%85%B1%E4%BA%AB%E5%86%85%E5%AD%98"><span class="nav-number">2.8.</span> <span class="nav-text">共享内存</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%85%B1%E4%BA%AB%E5%86%85%E5%AD%98%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86"><span class="nav-number">2.8.1.</span> <span class="nav-text">共享内存的工作原理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#shmget-shmat-shmdt-shmctl"><span class="nav-number">2.8.2.</span> <span class="nav-text">shmget shmat shmdt shmctl</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#shmctl-%E5%87%BD%E6%95%B0%E8%AF%A6%E8%A7%A3"><span class="nav-number">2.8.3.</span> <span class="nav-text">shmctl 函数详解</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BF%A1%E5%8F%B7%E7%81%AF%E9%9B%86"><span class="nav-number">2.9.</span> <span class="nav-text">信号灯集</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BF%A1%E5%8F%B7%E7%81%AF%E9%9B%86%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86"><span class="nav-number">2.9.1.</span> <span class="nav-text">信号灯集工作原理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#semget-semctl-semop"><span class="nav-number">2.9.2.</span> <span class="nav-text">semget semctl semop</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%AE%88%E6%8A%A4%E8%BF%9B%E7%A8%8B"><span class="nav-number">3.</span> <span class="nav-text">守护进程</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AE%88%E6%8A%A4%E8%BF%9B%E7%A8%8B%E5%88%9B%E5%BB%BA%E7%9A%84%E6%B5%81%E7%A8%8B"><span class="nav-number">3.1.</span> <span class="nav-text">守护进程创建的流程</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%96%87%E4%BB%B6%E6%8F%8F%E8%BF%B0%E7%AC%A6%E9%87%8D%E5%AE%9A%E5%90%91"><span class="nav-number">3.2.</span> <span class="nav-text">文件描述符重定向</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#dup-dup2-%E5%87%BD%E6%95%B0"><span class="nav-number">3.2.1.</span> <span class="nav-text">dup dup2 函数</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AE%88%E6%8A%A4%E8%BF%9B%E7%A8%8B%E5%88%9B%E5%BB%BA%E7%9A%84%E5%AE%9E%E4%BE%8B"><span class="nav-number">3.3.</span> <span class="nav-text">守护进程创建的实例</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B%E5%86%85%E7%A8%8B%E5%BA%8F%E6%9B%BF%E6%8D%A2%E5%87%BD%E6%95%B0"><span class="nav-number">4.</span> <span class="nav-text">进程内程序替换函数</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#system-%E5%87%BD%E6%95%B0"><span class="nav-number">4.1.</span> <span class="nav-text">system 函数</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%87%BD%E6%95%B0%E6%8E%A5%E5%8F%A3"><span class="nav-number">5.</span> <span class="nav-text">函数接口</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">XiaoMingMingBai</p>
  <div class="site-description" itemprop="description">选择有时候比努力更重要</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">13</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/xiaomingmingbai" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;xiaomingmingbai" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:xiaomingmingbai@outlook.com" title="E-Mail → mailto:xiaomingmingbai@outlook.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">XiaoMingMingBai</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-area"></i>
    </span>
    <span title="站点总字数">116k</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="站点阅读时长">3:30</span>
</div>
  <div class="powered-by">
    <!--由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动 -->
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  


  <script async src="/js/cursor/fireworks.js"></script>


</body>
</html>
